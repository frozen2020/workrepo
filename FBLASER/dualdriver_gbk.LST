C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER_GBK
OBJECT MODULE PLACED IN dualdriver_gbk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver_gbk.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          uint  count=1000;
  23          //uchar code tab1[]={"光纤激光控制器"};
  24          //uchar code tab2[]={"苏州德龙激光有限公司"};
  25          //uchar code tab3[]={"正在初始化"};
  26          //uchar code tab4[]={"请稍候......"};
  27          //uchar code tab5[]={"初始化完成"};
  28          //uchar code tab6[]={"SED:"};
  29          //uchar code tab7[]={"AMP:"};
  30          //uchar code tab8[]={"VOTEC:1.42v"};
  31          //uchar code tab9[]={"设定电流"};
  32          //uchar code tab10[]={"设定温度"};
  33          //uchar code tab11[]={"℃"};
  34          //uchar code tab12[]={"POW:"};
  35          //uchar code tab13[]={"设定功率"};
  36          //uchar code tab14[]={"℃ APC"};
  37          //uchar code tab15[]={"℃ ACC"};
  38          //uchar code tab16[]={"系统采集控制模式中  "};
  39          //uchar code tab17[]={"...................."};
  40          uchar idata  TEC_parameter1[6];
  41          uchar idata  TEC_parameter2[6];
  42          uchar idata  Diode_parameter1[6];
  43          uchar idata  Diode_parameter2[6];
  44          uchar idata  Power_parameter1[6];
  45          uchar idata  Power_parameter2[6];
  46          uchar  set_flag;
  47          
  48          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  49          
  50          uint   idata MCU_AD_code;
  51          uint   idata AD_code;
  52          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  53          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  54          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
  55          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 2   

  56          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  57          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  58          uint   init_current1;                       //种子源初始电流
  59          uint   init_current2;                       //放大级初始电流
  60          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅种子源 3：双路
  61          
  62          uint   idata Laser_Set_power1;             //设定种子源激光功率
  63          uint   idata Laser_Set_power2;             //设定放大级激光功率
  64          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  65          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  66          uint   idata Laser_meds_power1;            //种子源中间设定功率
  67          uint   idata Laser_meds_power2;            //放大级中间设定功率
  68          
  69          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  70          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  71          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  72          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  73          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  74          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  75          
  76          uint   idata Key_V;                         //按键电压
  77          
  78          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  79          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  80          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  81          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  82          
  83          
  84          
  85          uchar  t=0;                                 // 缓冲区数据段
  86          
  87          bit  read_flag=0;                           // 读取标志位
  88          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  89          
  90          
  91          //////////////////////////输入控制位/////////////////////////////////////////////////////
  92          
  93          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  94          
  95          
  96          
  97          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
  98          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
  99          sbit DOUT=P1^6;                      //AD串行输出
 100          
 101          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 102          
 103          //////////////////////////输出控制位/////////////////////////////////////////////////////
 104          sbit LDAC=P2^2;                      //DA装载信号
 105          sbit CSDA=P4^0;                      //DA选通信号
 106          sbit DINDA=P2^1;                     //DA串行数据输入
 107          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 108          sbit SCLK=P2^0;                      //DA时钟输入
 109          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 110          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 111          
 112          sbit FS=P3^7;                        //DA帧信号
 113          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 114          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 115          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
 116          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 117          sbit LIM2=P2^5;                      //激光二极管过流中断信号
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 3   

 118          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 119          sbit DCLK=P1^7;                      //AD时钟信号
 120          sbit ADIN=P1^5;                      //AD串行数据输入
 121          sbit CSAD=P2^4;                      //AD选通信号，L－选通
 122          sbit LCD_BUSY=P0^7;
 123          
 124          
 125          uint AD_Convert(uchar Channel);      //AD转换
 126          void DA_Convert(uchar Channel, uint Dcode);      //DA转换
 127          //void Set_TEC_TEMP(uint tempture);              //设定冷却温度
 128          void Set_laser_current(uchar Channel,uint current);    //设定激光二极管电流
 129          void Set_laser_power(uchar Channel,uint power);        //设定激光功率
 130          void MCU_ADC(BYTE CHN);                      //单片机内部AD转换
 131          //void Key_Button();                           //按键判别
 132          void TEC_V_Check();                          //TEC两端电压
 133          void Diode_curent_Check();                   //激光二极管电流检测
 134          void Laser_power_Check();                    //激光功率检测
 135          void Pdiod_V_Check();                        //激光二极管监测电压
 136          void TEC_Temp();                             //TEC温度
 137          void Error_Process();                        //异常处理
 138          void wr_lcd (uchar dat_comm,uchar content);
 139          //void Lcd_disp();
 140          void Pwm_Set(uint,uint,uint);
 141          void Sdio_check();                     // 加电流时状态检查
 142          
 143          void serial_initial();                 // 串口初始化
 144          void stat_initial();                   // 状态初始化
 145          void INT_0();                          // 外部中断0
 146          void delay(uint);                      // 长延时
 147          void delayR(uint);                     // 短延时
 148          void RS232();                          // 串口中断
 149          
 150          
 151          
 152          void command();                        // 指令判断
 153          void setfault();                       // 设置错误
 154          void setsucced();                      // 设置成功
 155          void alarm();                          // 警告
 156          
 157          
 158          
 159          /***************向串口发送一个字符串*****************/
 160          void send_string_com(uchar *str,uchar strlen)
 161          {
 162   1          uchar k=0;
 163   1          do
 164   1          {
 165   2              SBUF=*(str + k);
 166   2              while(TI==0);
 167   2              TI=0;
 168   2              k++;
 169   2          } while(k < strlen);
 170   1      }
 171          /************************************************************************/
 172          
 173          
 174          
 175          
 176          /***********以下是串口初始化程序********************************************/
 177          void serial_initial()
 178          {
 179   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 4   

 180   1      
 181   1            PCON |= 0x80;             //使能波特率倍速位SMOD
 182   1            SCON = 0x50;              //8位数据,可变波特率
 183   1            BRT = 0x64;               //设定独立波特率发生器重装值
 184   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 185   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 186   1            AUXR |= 0x10;             //启动独立波特率发生器
 187   1      
 188   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 189   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 190   1      
 191   1            IPH=0x14;
 192   1            IP=0x24;
 193   1            ES=1;
 194   1            ET0=1;
 195   1            IT0=1;
 196   1            EX0=1;
 197   1            IT1=1;
 198   1            EX1=1;
 199   1            EA=1;
 200   1            TL0 = 0x30;   //设置定时初值
 201   1            TH0 = 0xF8;   //设置定时初值
 202   1            TF0 = 0;    //清除TF0标志
 203   1            TR0 = 0;    //定时器0开始计时
 204   1      
 205   1            return;
 206   1      }
 207          
 208          /**********************************************************************/
 209          
 210          
 211          
 212          
 213          /***********以下是状态初始化程序*********************************/
 214          void stat_initial()
 215          {
 216   1      
 217   1           ADC_RES=0;
 218   1           ADC_RESL=0;
 219   1      
 220   1           read_flag=0;          //读取标志清零
 221   1           las_di_ok=0;
 222   1           t=0;
 223   1           set_flag=0;
 224   1           Sys_mod=1;
 225   1      
 226   1           AD_code=0;
 227   1      //     Laser_Set_curent=0;
 228   1           Laser_Fed_curent1=0;
 229   1           Laser_Fed_curent2=0;
 230   1           Laser_Fed_power1=0;
 231   1           Laser_Fed_power2=0;
 232   1      
 233   1      /**************DA引脚初始化*************************/
 234   1           CSDA=1;
 235   1           LDAC=1;
 236   1           FS=0;
 237   1           SCLK=0;
 238   1           DINDA=0;
 239   1      /**************************************************/
 240   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
 241   1           _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 5   

 242   1           DA_Convert(2,1273);
 243   1           _Nop();
 244   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
 245   1           _Nop();
 246   1           DA_Convert(1,1273);
 247   1      /**************************************************/
 248   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
 249   1      
 250   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
 251   1       {
 252   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
 253   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
 254   2      
 255   2        DA_Convert(3,25);                          // 种子源
 256   2         _Nop();
 257   2        DA_Convert(3,25);
 258   2      
 259   2        DA_Convert(0,25);                          // 放大级
 260   2         _Nop();
 261   2        DA_Convert(0,25);
 262   2       }
 263   1      //////////////////////////////////////////////////////////////////////////////////////////////
 264   1      
 265   1        else
 266   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
 267   1       {
 268   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
 269   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
 270   2      
 271   2        DA_Convert(3,92);                            // 种子源
 272   2         _Nop();
 273   2        DA_Convert(3,92);
 274   2      
 275   2        DA_Convert(0,89);                            // 放大级
 276   2        _Nop();
 277   2        DA_Convert(0,89);
 278   2       }
 279   1      //////////////////////////////////////////////////////////////////////////////////////////////
 280   1      
 281   1      
 282   1      
 283   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
 284   1           P1M1=0x07;
 285   1           P1M0=0x00;
 286   1      
 287   1           CSAD=1;
 288   1           DCLK=1;
 289   1           DOUT=1;
 290   1      
 291   1      
 292   1      
 293   1      
 294   1      
 295   1      /*************TEC控制器初始化*********************/
 296   1           SHDN1=1;
 297   1      //   TMPGD1=1;
 298   1           LIM1=1;
 299   1      
 300   1           SHDN2=1;
 301   1      //   TMPGD2=1;
 302   1           LIM2=1;
 303   1      /*************************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 6   

 304   1      
 305   1      /*    Power_parameter[0]='P';
 306   1            Power_parameter[1]='O';
 307   1            Power_parameter[2]='W';
 308   1            Power_parameter[3]=':';
 309   1      
 310   1            Diode_parameter[0]='L';
 311   1            Diode_parameter[1]='D';
 312   1            Diode_parameter[2]='C';
 313   1            Diode_parameter[3]=':';
 314   1            Diode_parameter[8]=0x20;
 315   1            Diode_parameter[9]=0x20;
 316   1      
 317   1            TEC_parameter[0]='T';
 318   1            TEC_parameter[1]='E';
 319   1            TEC_parameter[2]='C';
 320   1            TEC_parameter[3]=':';
 321   1      */
 322   1      
 323   1           TR0=0;
 324   1           ET0=0;
 325   1           TR1=0;
 326   1           ET1=0;
 327   1           EX0=0;
 328   1      
 329   1           return;
 330   1      }
 331          
 332          /***************************************************************/
 333          
 334          
 335          /**************************LCD初始化***************************/
 336          void init_lcd (void)
 337          {
 338   1      
 339   1        wr_lcd (comm,0x30);                    //设定工作方式
 340   1        delayR(50000);
 341   1        wr_lcd (comm,0x01);                    //清屏
 342   1        delayR(50000);
 343   1        wr_lcd (comm,0x06);                    //光标的移动方向
 344   1        delayR(50000);
 345   1        wr_lcd (comm,0x0c);                    //开显示
 346   1      }
 347          
 348          /*************************************************************/
 349          /**************************显示汉字或字符*********************/
 350          
 351          void chn_disp (uchar *chn,uchar num,uchar ADRS)
 352          {
 353   1          uchar i=0;
 354   1      //  wr_lcd (comm,0x30);
 355   1      //  delay(5);
 356   1          wr_lcd (comm,ADRS);
 357   1          for (i=0;i<num;i++)
 358   1          wr_lcd (dat,chn[i]);
 359   1          delay(2);
 360   1          return;
 361   1      }
 362          /*************************************************************/
 363          
 364          
 365          /***************************清DDRAM***************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 7   

 366          void clrram (void)
 367          {
 368   1        wr_lcd (comm,0x30);
 369   1        delayR(50000);
 370   1        wr_lcd (comm,0x01);
 371   1      }
 372          /************************************************************/
 373          
 374          
 375          
 376          /**************************判断忙标志位**********************/
 377          void chk_busy (void)
 378          {
 379   1        P0=0xff;
 380   1        _Nop();
 381   1        RS=0;
 382   1        RW=1;
 383   1         _Nop();
 384   1         _Nop();
 385   1         _Nop();
 386   1         _Nop();
 387   1        ENAB=1;
 388   1         _Nop();
 389   1         _Nop();
 390   1         _Nop();
 391   1         _Nop();
 392   1        while(LCD_BUSY==1);
 393   1        _Nop();
 394   1        ENAB=0;
 395   1      }
 396          
 397          /************************************************************/
 398          
 399          /**************************LCD写操作*************************/
 400          void wr_lcd (uchar dat_comm,uchar content)
 401          {
 402   1        chk_busy ();
 403   1        if(dat_comm)
 404   1         {
 405   2          RS=1;                 //data
 406   2          RW=0;                 //write
 407   2         }
 408   1        else
 409   1         {
 410   2          RS=0;                //command
 411   2          RW=0;                //write
 412   2         }
 413   1        P0=content;            
 414   1        _Nop();
 415   1        _Nop();
 416   1        _Nop();
 417   1        _Nop();
 418   1        ENAB=1;
 419   1        _Nop();
 420   1        _Nop();
 421   1        _Nop();
 422   1        _Nop();
 423   1        ENAB=0;
 424   1      }
 425          /************************************************************/
 426          
 427          /****************************操作指令执行***********************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 8   

 428          void command()
 429          {
 430   1      
 431   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
 432   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
 433   1              {
 434   2                 stat_initial();
 435   2                 serial_initial();
 436   2                 setsucced();
 437   2              }
 438   1      
 439   1      ///////////////////////////////////设定电流////////////////////////////////////////////
 440   1             else if((inbuf[0]=='S')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='O')&&(inbuf[4]=='='))
 441   1      
 442   1                 {
 443   2                     uint dio_cu;
 444   2                     uchar CH;
 445   2      
 446   2                     if(inbuf[7]==0x0d)                                        //格式为SDIO=N
 447   2                    {
 448   3                       dio_cu=inbuf[6]-48;
 449   3      
 450   3      
 451   3                    }
 452   2                     else if(inbuf[8]==0x0d)                                   //格式为SDIO=NN
 453   2                    {
 454   3                       dio_cu=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 455   3      
 456   3                    }
 457   2                    else if(inbuf[9]==0x0d)                                    //格式为SDIO=NNN
 458   2                    {
 459   3                       dio_cu=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 460   3      
 461   3                    }
 462   2      
 463   2                    else                                                    //格式为SDIO=NNNN
 464   2                    {
 465   3                        setfault();
 466   3                        goto setcf;
 467   3                    }
 468   2      
 469   2                    if(inbuf[5]=='S')
 470   2                    {
 471   3                      CH=3;                                     //种子源SEED
 472   3                      Set_laser_current(CH,dio_cu);
 473   3                      setsucced();
 474   3                    }
 475   2                    else if(inbuf[5]=='A')
 476   2                    {
 477   3                      CH=0;                                    //放大级AMP
 478   3                      Set_laser_current(CH,dio_cu);
 479   3                      setsucced();
 480   3                    }
 481   2                    else setfault();
 482   2      
 483   2      setcf:       _Nop();
 484   2      
 485   2                 }
 486   1      
 487   1      
 488   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
 489   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 9   

 490   1      
 491   1                 {
 492   2                     uint init_current;
 493   2                     uchar CH;
 494   2      
 495   2                     if(inbuf[7]==0x0d)                                        //格式为SDIO=N
 496   2                    {
 497   3                       init_current=inbuf[6]-48;
 498   3      
 499   3      
 500   3                    }
 501   2                     else if(inbuf[8]==0x0d)                                   //格式为SDIO=NN
 502   2                    {
 503   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 504   3      
 505   3                    }
 506   2                    else if(inbuf[9]==0x0d)                                    //格式为SDIO=NNN
 507   2                    {
 508   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 509   3      
 510   3                    }
 511   2      
 512   2                    else                                                    //格式为SDIO=NNNN
 513   2                    {
 514   3                        setfault();
 515   3                        goto seticf;
 516   3                    }
 517   2      
 518   2                    if(inbuf[5]=='S')
 519   2                    {
 520   3                      init_current1=init_current;
 521   3                    }
 522   2                    else if(inbuf[5]=='A')
 523   2                    {
 524   3                      init_current2=init_current;
 525   3                    }
 526   2                    else setfault();
 527   2      
 528   2      seticf:       _Nop();
 529   2      
 530   2                 }
 531   1      
 532   1      
 533   1      
 534   1      ///////////////////////////////////设定初始化模式 0/1/2/3 ////////////////////////////////////////////
 535   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
 536   1      
 537   1                 {   
 538   2                     uint init_flag_temp;
 539   2                     uchar CH;
 540   2      
 541   2                     if(inbuf[6]==0x0d)                                        //格式为SDIO=N
 542   2                    {
 543   3                       init_flag_temp=inbuf[5]-48;
 544   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
 545   3                        goto setief;
 546   3                      else
 547   3                        init_flag=init_flag_temp;
 548   3                    }
 549   2                    else                                                    //格式为SDIO=NNNN
 550   2                    {
 551   3                        setfault();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 10  

 552   3                        goto setief;
 553   3                    }
 554   2      
 555   2      setief:       _Nop();
 556   2      
 557   2                 }
 558   1      
 559   1      
 560   1       //////////////////////////////设定功率//////////////////////////////////////////////////
 561   1              else if((inbuf[0]=='S')&&(inbuf[1]=='P')&&(inbuf[2]=='O')&&(inbuf[3]=='W')&&(inbuf[4]=='='))
 562   1                  {
 563   2                     uint las_pow;
 564   2                     uchar CHH;
 565   2                     if(inbuf[6]==0x0d)                                        //格式为SPOW=N
 566   2                    {
 567   3                       las_pow=(uint)(inbuf[5]-48);
 568   3      
 569   3                    }
 570   2                     else if(inbuf[7]==0x0d)                                   //格式为SPOW=NN
 571   2                    {
 572   3                       las_pow=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 573   3      
 574   3                    }
 575   2                    else if(inbuf[8]==0x0d)                                    //格式为SPOW=NNN
 576   2                    {
 577   3                       las_pow=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 578   3      
 579   3                    }
 580   2      
 581   2                    else                                                      //格式为SPOW=NNNN
 582   2                    {
 583   3                        setfault();
 584   3                        goto setpf;
 585   3                    }
 586   2      
 587   2                    if(inbuf[5]=='S')
 588   2                    {
 589   3                      CH=3;                                     //种子源SEED
 590   3                      Set_laser_power(CHH,las_pow);
 591   3                      setsucced();
 592   3                    }
 593   2                    else if(inbuf[5]=='A')
 594   2                    {
 595   3                      CH=0;                                    //放大级AMP
 596   3                      Set_laser_power(CHH,las_pow);
 597   3                      setsucced();
 598   3                    }
 599   2                    else setfault();
 600   2      
 601   2      setpf:       _Nop();
 602   2      
 603   2      
 604   2                  }
 605   1       ////////////////////////////////////////////////////////////////////////////////////////
 606   1       //////////////////////////////设定温度//////////////////////////////////////////////////
 607   1              else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='P')&&(inbuf[4]=='='))
 608   1                 {
 609   2                    uint  tmp_tec=0;
 610   2                    uint kt=0;
 611   2                    if(inbuf[8]==0x0d)
 612   2                    {
 613   3                       tmp_tec=(inbuf[6]-48)*10+(inbuf[7]-48);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 11  

 614   3      
 615   3      
 616   3      
 617   3      
 618   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
 619   3      
 620   3                    }
 621   2                    else if(inbuf[10]==0x0d)
 622   2                    {
 623   3                       tmp_tec=(inbuf[6]-48)*10+(inbuf[7]-48);
 624   3      
 625   3                       kt=((tmp_tec-15)*691+(inbuf[9]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[9]-48)*59/5+90;
 626   3      
 627   3                    }
 628   2      
 629   2                    else
 630   2                    {
 631   3                       setfault();
 632   3                       goto settf;
 633   3                    }
 634   2      
 635   2                     if(inbuf[5]=='S')
 636   2                    {
 637   3                      DA_Convert(2,kt);                         //种子源SEED
 638   3                      _Nop();
 639   3                      DA_Convert(2,kt);
 640   3                      setsucced();
 641   3                    }
 642   2                    else if(inbuf[5]=='A')
 643   2                    {
 644   3                      DA_Convert(1,kt);                         //放大级AMP
 645   3                      _Nop();
 646   3                      DA_Convert(1,kt);
 647   3                      setsucced();
 648   3                    }
 649   2                    else setfault();
 650   2      
 651   2      settf:       _Nop();
 652   2      
 653   2      
 654   2                 }
 655   1      
 656   1       ////////////////////////////////////////////////////////////////////////////////////////
 657   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
 658   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
 659   1               {
 660   2                     uint pwm_pulserate;
 661   2                   
 662   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
 663   2                    {
 664   3                       pwm_pulserate=inbuf[5]-48;
 665   3      
 666   3      
 667   3                    }
 668   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
 669   2                    {
 670   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 671   3      
 672   3                    }
 673   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 674   2                    {
 675   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 12  

 676   3      
 677   3                    }
 678   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 679   2                    {
 680   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 681   3      
 682   3                    }
 683   2                    else                                                    //格式为PURA=NNNN
 684   2                    {
 685   3                        setfault();
 686   3                        goto setprf;
 687   3                    }
 688   2                      Pwm_Set(1,1,1);
 689   2                      setsucced();
 690   2      setprf:       _Nop();
 691   2      
 692   2                 }
 693   1                ////////////////////////////////////////////////////////////////////////////////////////
 694   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
 695   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
 696   1               {
 697   2                     uint pwm_pulserate;
 698   2                   
 699   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
 700   2                    {
 701   3                       pwm_pulserate=inbuf[5]-48;
 702   3      
 703   3      
 704   3                    }
 705   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
 706   2                    {
 707   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 708   3      
 709   3                    }
 710   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 711   2                    {
 712   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 713   3      
 714   3                    }
 715   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 716   2                    {
 717   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 718   3      
 719   3                    }
 720   2                    else                                                    //格式为PUWI=NNNN
 721   2                    {
 722   3                        setfault();
 723   3                        goto setpwf;
 724   3                    }
 725   2                        Pwm_Set(1,1,1);
 726   2                      setsucced();
 727   2      setpwf:       _Nop();
 728   2      
 729   2                 }
 730   1      
 731   1                 ////////////////////////////////////////////////////////////////////////////////////////
 732   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
 733   1              else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='='))
 734   1               {
 735   2                     uint pwm_pulserate;
 736   2                   
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 13  

 737   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
 738   2                    {
 739   3                       pwm_pulserate=inbuf[5]-48;
 740   3      
 741   3      
 742   3                    }
 743   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
 744   2                    {
 745   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 746   3      
 747   3                    }
 748   2                    else                                                    //格式为DELY=NNNN
 749   2                    {
 750   3                        setfault();
 751   3                        goto setpdf;
 752   3                    }
 753   2                      Pwm_Set(1,1,1);
 754   2                      setsucced();
 755   2      setpdf:       _Nop();
 756   2      
 757   2                 }
 758   1      
 759   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
 760   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
 761   1      
 762   1                 {
 763   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
 764   2                    {
 765   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
 766   3                       setsucced();
 767   3                    }
 768   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
 769   2                    {
 770   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
 771   3                       setsucced();
 772   3                    }
 773   2                    setfault();
 774   2      
 775   2                 }
 776   1      
 777   1       //////////////////////////////////强制关电流///////////////////////////////////////
 778   1      
 779   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
 780   1      
 781   1                 {
 782   2                    if(inbuf[7]==0x0d)
 783   2                    {
 784   3                       if(inbuf[5]=='S')
 785   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
 786   3                       else  if(inbuf[5]=='A')
 787   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
 788   3                       else
 789   3                        {
 790   4                         setfault();
 791   4                         goto setdf;
 792   4                        }
 793   3                       if (!LIM1)
 794   3                       {
 795   4                         Set_laser_current(3,50);
 796   4                         setsucced();
 797   4                        }
 798   3                       else if(!LIM2)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 14  

 799   3                       {
 800   4                         Set_laser_current(0,50);
 801   4                         setsucced();
 802   4                        }
 803   3                       else
 804   3                        {
 805   4                         setfault();
 806   4                         goto setdf;
 807   4                        }
 808   3                    }
 809   2                    else
 810   2                       setfault();
 811   2      setdf:       _Nop();
 812   2                 }
 813   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
 814   1            else if((inbuf[0]=='D')&&(inbuf[1]=='I')&&(inbuf[2]=='O')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
 815   1      
 816   1                 {
 817   2      
 818   2                    if(Laser_Fed_curent1<10)
 819   2                    {
 820   3                      inbuf[4]='S';
 821   3                      inbuf[5]='=';
 822   3                      inbuf[6]=(uchar)(Laser_Fed_curent1)+48;
 823   3                      inbuf[7]=0x0d;
 824   3                      inbuf[8]=0x0a;
 825   3                      send_string_com(inbuf,9);
 826   3                    }else if (Laser_Fed_curent1<100)
 827   2                    {
 828   3                      inbuf[4]='S';
 829   3                      inbuf[5]='=';
 830   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 /10)+48;
 831   3                      inbuf[7]=(uchar)(Laser_Fed_curent1 %10)+48;
 832   3                      inbuf[8]=0x0d;
 833   3                      inbuf[9]=0x0a;
 834   3                      send_string_com(inbuf,10);
 835   3                    }else if (Laser_Fed_curent1<1000)
 836   2                    {
 837   3                      inbuf[4]='S';
 838   3                      inbuf[5]='=';
 839   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 /100)+48;
 840   3                      inbuf[7]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 841   3                      inbuf[8]=(uchar)(Laser_Fed_curent1 %10)+48;
 842   3                      inbuf[9]=0x0d;
 843   3                      inbuf[10]=0x0a;
 844   3                      send_string_com(inbuf,11);
 845   3                    }
 846   2                    else
 847   2                      setfault();
 848   2       //////////////////////////////////////////////////////////
 849   2                     if(Laser_Fed_curent2<10)
 850   2                    {
 851   3                      inbuf[4]='A';
 852   3                      inbuf[5]='=';
 853   3                      inbuf[6]=(uchar)(Laser_Fed_curent2)+48;
 854   3                      inbuf[7]=0x0d;
 855   3                      inbuf[8]=0x0a;
 856   3                      send_string_com(inbuf,9);
 857   3                    }else if (Laser_Fed_curent2<100)
 858   2                    {
 859   3                      inbuf[4]='A';
 860   3                      inbuf[5]='=';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 15  

 861   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 /10)+48;
 862   3                      inbuf[7]=(uchar)(Laser_Fed_curent2 %10)+48;
 863   3                      inbuf[8]=0x0d;
 864   3                      inbuf[9]=0x0a;
 865   3                      send_string_com(inbuf,10);
 866   3                    }else if (Laser_Fed_curent2<1000)
 867   2                    {
 868   3                      inbuf[4]='A';
 869   3                      inbuf[5]='=';
 870   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 /100)+48;
 871   3                      inbuf[7]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 872   3                      inbuf[8]=(uchar)(Laser_Fed_curent2 %10)+48;
 873   3                      inbuf[9]=0x0d;
 874   3                      inbuf[10]=0x0a;
 875   3                      send_string_com(inbuf,11);
 876   3                    }
 877   2                    else
 878   2                      setfault();
 879   2      
 880   2                 }
 881   1      
 882   1      
 883   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
 884   1            else if((inbuf[0]=='L')&&(inbuf[1]=='A')&&(inbuf[2]=='P')&&(inbuf[3]=='O')&&(inbuf[4]=='?'))
 885   1      
 886   1                 {
 887   2      
 888   2                    if(Laser_Fed_power1<10)
 889   2                    {
 890   3                      inbuf[4]='S';
 891   3                      inbuf[5]='=';
 892   3                      inbuf[6]=(uchar)(Laser_Fed_power1)+48;
 893   3                      inbuf[7]=0x0d;
 894   3                      inbuf[8]=0x0a;
 895   3                      send_string_com(inbuf,9);
 896   3                    }else if (Laser_Fed_power1<100)
 897   2                    {
 898   3                      inbuf[4]='S';
 899   3                      inbuf[5]='=';
 900   3                      inbuf[6]=(uchar)(Laser_Fed_power1 /10)+48;
 901   3                      inbuf[7]=(uchar)(Laser_Fed_power1 %10)+48;
 902   3                      inbuf[8]=0x0d;
 903   3                      inbuf[9]=0x0a;
 904   3                      send_string_com(inbuf,10);
 905   3                    }else if (Laser_Fed_power1<1000)
 906   2                    {
 907   3                      inbuf[4]='S';
 908   3                      inbuf[5]='=';
 909   3                      inbuf[6]=(uchar)(Laser_Fed_power1 /100)+48;
 910   3                      inbuf[7]=(uchar)((Laser_Fed_power1 /10)%10)+48;
 911   3                      inbuf[8]=(uchar)(Laser_Fed_power1 %10)+48;
 912   3                      inbuf[9]=0x0d;
 913   3                      inbuf[10]=0x0a;
 914   3                      send_string_com(inbuf,11);
 915   3                    }
 916   2                    else
 917   2                      setfault();
 918   2      
 919   2                     if(Laser_Fed_power2<10)
 920   2                    {
 921   3                      inbuf[4]='A';
 922   3                      inbuf[5]='=';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 16  

 923   3                      inbuf[6]=(uchar)(Laser_Fed_power2)+48;
 924   3                      inbuf[7]=0x0d;
 925   3                      inbuf[8]=0x0a;
 926   3                      send_string_com(inbuf,9);
 927   3                    }else if (Laser_Fed_power2<100)
 928   2                    {
 929   3                      inbuf[4]='A';
 930   3                      inbuf[5]='=';
 931   3                      inbuf[6]=(uchar)(Laser_Fed_power2 /10)+48;
 932   3                      inbuf[7]=(uchar)(Laser_Fed_power2 %10)+48;
 933   3                      inbuf[8]=0x0d;
 934   3                      inbuf[9]=0x0a;
 935   3                      send_string_com(inbuf,10);
 936   3                    }else if (Laser_Fed_power2<1000)
 937   2                    {
 938   3                      inbuf[4]='A';
 939   3                      inbuf[5]='=';
 940   3                      inbuf[6]=(uchar)(Laser_Fed_power2 /100)+48;
 941   3                      inbuf[7]=(uchar)((Laser_Fed_power2 /10)%10)+48;
 942   3                      inbuf[8]=(uchar)(Laser_Fed_power2 %10)+48;
 943   3                      inbuf[9]=0x0d;
 944   3                      inbuf[10]=0x0a;
 945   3                      send_string_com(inbuf,11);
 946   3                    }
 947   2                    else
 948   2                      setfault();
 949   2      
 950   2                 }
 951   1      
 952   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
 953   1            else if((inbuf[0]=='T')&&(inbuf[1]=='E')&&(inbuf[2]=='C')&&(inbuf[3]=='P')&&(inbuf[4]=='?'))
 954   1      
 955   1                 {
 956   2      
 957   2                    uint ky;
 958   2      //              TEC_Temp();
 959   2      
 960   2                    ky=(uint)(TEC_Fed_Tempture1);
 961   2      
 962   2                    if (ky<1000)
 963   2                    {
 964   3                      inbuf[4]='S';
 965   3                      inbuf[5]='=';
 966   3                      inbuf[6]=ky/100+48;
 967   3                      inbuf[7]=(ky/10)%10+48;
 968   3                      inbuf[8]='.';
 969   3                      inbuf[9]=ky%10+48;
 970   3                      inbuf[10]=0x0d;
 971   3                      inbuf[11]=0x0a;
 972   3                      send_string_com(inbuf,12);
 973   3                    }
 974   2                    else
 975   2                     alarm();
 976   2      
 977   2                   ky=(uint)(TEC_Fed_Tempture2);
 978   2      
 979   2                    if (ky<1000)
 980   2                    {
 981   3                      inbuf[4]='A';
 982   3                      inbuf[5]='=';
 983   3                      inbuf[6]=ky/100+48;
 984   3                      inbuf[7]=(ky/10)%10+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 17  

 985   3                      inbuf[8]='.';
 986   3                      inbuf[9]=ky%10+48;
 987   3                      inbuf[10]=0x0d;
 988   3                      inbuf[11]=0x0a;
 989   3                      send_string_com(inbuf,12);
 990   3                    }
 991   2                    else
 992   2                     alarm();
 993   2      
 994   2                 }
 995   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
 996   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
 997   1      
 998   1                 {
 999   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1000   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1001   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1002   2      
1003   2                    inbuf[4]='S';
1004   2                    inbuf[5]='=';
1005   2                    inbuf[6]=inbuf[6]+48;
1006   2                    inbuf[7]='.';
1007   2                    inbuf[8]=inbuf[8]+48;
1008   2                    inbuf[9]=inbuf[9]+48;
1009   2                    inbuf[10]=0x0d;
1010   2                    inbuf[11]=0x0a;
1011   2      
1012   2                    send_string_com(inbuf,12);
1013   2      
1014   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1015   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1016   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1017   2      
1018   2                    inbuf[4]='A';
1019   2                    inbuf[5]='=';
1020   2                    inbuf[6]=inbuf[6]+48;
1021   2                    inbuf[7]='.';
1022   2                    inbuf[8]=inbuf[8]+48;
1023   2                    inbuf[9]=inbuf[9]+48;
1024   2                    inbuf[10]=0x0d;
1025   2                    inbuf[11]=0x0a;
1026   2      
1027   2                    send_string_com(inbuf,12);
1028   2      
1029   2      
1030   2                 }
1031   1      
1032   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1033   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1034   1      
1035   1                 {
1036   2      
1037   2      
1038   2      
1039   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1040   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1041   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1042   2      
1043   2                    inbuf[4]='S';
1044   2                    inbuf[5]='=';
1045   2                    inbuf[6]=inbuf[6]+48;
1046   2                    inbuf[7]='.';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 18  

1047   2                    inbuf[8]=inbuf[8]+48;
1048   2                    inbuf[9]=inbuf[9]+48;
1049   2                    inbuf[10]=0x0d;
1050   2                    inbuf[11]=0x0a;
1051   2      
1052   2                    send_string_com(inbuf,12);
1053   2      
1054   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1055   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1056   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1057   2      
1058   2                    inbuf[4]='A';
1059   2                    inbuf[5]='=';
1060   2                    inbuf[6]=inbuf[6]+48;
1061   2                    inbuf[7]='.';
1062   2                    inbuf[8]=inbuf[8]+48;
1063   2                    inbuf[9]=inbuf[9]+48;
1064   2                    inbuf[10]=0x0d;
1065   2                    inbuf[11]=0x0a;
1066   2      
1067   2                    send_string_com(inbuf,12);
1068   2      
1069   2                 }
1070   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1071   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1072   1      
1073   1                 {
1074   2                    if (TMPGD1)
1075   2                    {
1076   3                      inbuf[4]='S';
1077   3                      inbuf[5]=' ';
1078   3                      inbuf[6]='O';
1079   3                      inbuf[7]='K';
1080   3                      inbuf[8]=0x0d;
1081   3                      inbuf[9]=0x0a;
1082   3                      send_string_com(inbuf,10);
1083   3                    }
1084   2      
1085   2                    else
1086   2                    {
1087   3                      inbuf[4]='S';
1088   3                      inbuf[5]=' ';
1089   3                      inbuf[6]='N';
1090   3                      inbuf[7]='O';
1091   3                      inbuf[8]=0x0d;
1092   3                      inbuf[9]=0x0a;
1093   3                      send_string_com(inbuf,10);
1094   3                    }
1095   2      
1096   2                    if (TMPGD2)
1097   2                    {
1098   3                      inbuf[4]='A';
1099   3                      inbuf[5]=' ';
1100   3                      inbuf[6]='O';
1101   3                      inbuf[7]='K';
1102   3                      inbuf[8]=0x0d;
1103   3                      inbuf[9]=0x0a;
1104   3                      send_string_com(inbuf,10);
1105   3                    }
1106   2      
1107   2                    else
1108   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 19  

1109   3                      inbuf[4]='A';
1110   3                      inbuf[5]=' ';
1111   3                      inbuf[6]='N';
1112   3                      inbuf[7]='O';
1113   3                      inbuf[8]=0x0d;
1114   3                      inbuf[9]=0x0a;
1115   3                      send_string_com(inbuf,10);
1116   3                    }
1117   2      
1118   2                 }
1119   1      
1120   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1121   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1122   1      
1123   1                 {
1124   2                    if (SHDN1)
1125   2                    {
1126   3                      inbuf[0]='T';
1127   3                      inbuf[1]='E';
1128   3                      inbuf[2]='C';
1129   3                      inbuf[3]='1';
1130   3                      inbuf[4]=' ';
1131   3                      inbuf[5]='O';
1132   3                      inbuf[6]='N';
1133   3                      inbuf[7]=0x0d;
1134   3                      inbuf[8]=0x0a;
1135   3                      send_string_com(inbuf,9);
1136   3                    }
1137   2      
1138   2                    else
1139   2                    {
1140   3                      inbuf[0]='T';
1141   3                      inbuf[1]='E';
1142   3                      inbuf[2]='C';
1143   3                      inbuf[3]='1';
1144   3                      inbuf[4]=' ';
1145   3                      inbuf[5]='O';
1146   3                      inbuf[6]='F';
1147   3                      inbuf[7]='F';
1148   3                      inbuf[8]=0x0d;
1149   3                      inbuf[9]=0x0a;
1150   3                      send_string_com(inbuf,10);
1151   3                    }
1152   2      
1153   2                    if (SHDN2)
1154   2                    {
1155   3                      inbuf[0]='T';
1156   3                      inbuf[1]='E';
1157   3                      inbuf[2]='C';
1158   3                      inbuf[3]='2';
1159   3                      inbuf[4]=' ';
1160   3                      inbuf[5]='O';
1161   3                      inbuf[6]='N';
1162   3                      inbuf[7]=0x0d;
1163   3                      inbuf[8]=0x0a;
1164   3                      send_string_com(inbuf,9);
1165   3                    }
1166   2      
1167   2                    else
1168   2                    {
1169   3                      inbuf[0]='T';
1170   3                      inbuf[1]='E';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 20  

1171   3                      inbuf[2]='C';
1172   3                      inbuf[3]='2';
1173   3                      inbuf[4]=' ';
1174   3                      inbuf[5]='O';
1175   3                      inbuf[6]='F';
1176   3                      inbuf[7]='F';
1177   3                      inbuf[8]=0x0d;
1178   3                      inbuf[9]=0x0a;
1179   3                      send_string_com(inbuf,10);
1180   3                    }
1181   2                 }
1182   1      
1183   1      ///////////////////////////////////////////////////////////////////////////////////
1184   1      
1185   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1186   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1187   1      
1188   1                 {
1189   2                    if (CONT_MOD)
1190   2                    {
1191   3                      inbuf[0]='M';
1192   3                      inbuf[1]='O';
1193   3                      inbuf[2]='D';
1194   3                      inbuf[3]='=';
1195   3                      inbuf[4]='A';
1196   3                      inbuf[5]='P';
1197   3                      inbuf[6]='C';
1198   3                      inbuf[7]=0x0d;
1199   3                      inbuf[8]=0x0a;
1200   3                      send_string_com(inbuf,9);
1201   3                    }
1202   2      
1203   2                    else
1204   2                    {
1205   3                      inbuf[0]='M';
1206   3                      inbuf[1]='O';
1207   3                      inbuf[2]='D';
1208   3                      inbuf[3]='=';
1209   3                      inbuf[4]='A';
1210   3                      inbuf[5]='C';
1211   3                      inbuf[6]='C';
1212   3                      inbuf[7]=0x0d;
1213   3                      inbuf[8]=0x0a;
1214   3                      send_string_com(inbuf,9);
1215   3                    }
1216   2                 }
1217   1      
1218   1      
1219   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1220   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1221   1            {
1222   2                 if(inbuf[6]==0x0d)
1223   2                    {
1224   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1225   3                       setsucced();
1226   3                    }
1227   2                 else
1228   2                    setfault();
1229   2            }
1230   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1231   1      
1232   1            else
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 21  

1233   1             setfault();                              //设置错误
1234   1      
1235   1      
1236   1      
1237   1           return;
1238   1      
1239   1      }
*** WARNING C280 IN LINE 493 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
*** WARNING C280 IN LINE 539 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
1240          /*******************************************************************************/
1241          
1242          
1243          
1244          
1245          
1246          /*****************************设置显示****************************************
1247          void Lcd_disp()
1248          {
1249           wr_lcd (comm,0x30);                    //设定工作方式
1250           delay(1);
1251           wr_lcd (comm,0x01);                    //清屏
1252           delay(1);
1253           wr_lcd (comm,0x0d);                    //开显示
1254           delay(1);
1255           wr_lcd (comm,0x10);
1256           delay(30);
1257          
1258           if(CONT_MOD)                          //CONT_MOD: 1 APC, 0 ACC
1259          
1260          //*****************APC模式显示设定功率*********************************
1261           {
1262             chn_disp (tab13,8,0x80);
1263             delayR(50);
1264             chn_disp (Power_parameter1,6,0x84);
1265           }
1266          
1267          //********************************************************************
1268           else
1269          //****************ACC模式显示电流设定**********************************
1270           {
1271            chn_disp (tab9,8,0x80);
1272            delayR(50);
1273            chn_disp (Diode_parameter1,6,0x84);
1274          
1275           }
1276          //*********************************************************************
1277          
1278           delayR(50);
1279          
1280          //*****************显示设定温度****************************************
1281          
1282           delayR(50);
1283           chn_disp (TEC_parameter1,4,0x94);
1284           delayR(50);
1285           chn_disp (tab11,2,0x96);
1286           delayR(50);
1287          // wr_lcd (comm,0x90);
1288          //********************************************************************
1289          
1290          }
1291          /**************************************************************************
1292          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 22  

1293          
1294          /*****************************判断按键电压*********************************
1295          void Key_Button()
1296          {
1297            uchar kk=10;
1298            uchar tec_a=0;
1299            uchar tec_b=0;
1300            Key_V=0;
1301          
1302          
1303          
1304          
1305            return;
1306          }
1307          
1308          /**************************************************************************/
1309          
1310          /**********************二极管电流监测**************************************/
1311          void Diode_curent_Check()
1312          {
1313   1          uchar k=16;
1314   1      //    float a,b;
1315   1          AD_inbuf[0]=0;
1316   1          AD_inbuf[1]=0;
1317   1          do
1318   1          {
1319   2            AD_code=AD_Convert(0);                  //种子源电流
1320   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
1321   2      
1322   2            AD_code=AD_Convert(3);                  //放大级电流
1323   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
1324   2      
1325   2            k--;
1326   2          }while(k);
1327   1      
1328   1      
1329   1          AD_inbuf[0]=AD_inbuf[0]/16;
1330   1          AD_inbuf[1]=AD_inbuf[1]/16;
1331   1      
1332   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
1333   1          Laser_meds_curent1=Laser_Fed_curent1;
1334   1          if (Laser_Fed_curent1<10)
1335   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
1336   2              Diode_parameter1[1]=0x6d;
1337   2              Diode_parameter1[2]=0x41;
1338   2              Diode_parameter1[3]=0x20;
1339   2              Diode_parameter1[4]=0x20;
1340   2      
1341   2            } else if(Laser_Fed_curent1<100)
1342   1      
1343   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
1344   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
1345   2              Diode_parameter1[2]=0x6d;
1346   2              Diode_parameter1[3]=0x41;
1347   2              Diode_parameter1[4]=0x20;
1348   2            } else if(Laser_Fed_curent1<1000)
1349   1      
1350   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
1351   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
1352   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
1353   2              Diode_parameter1[3]=0x6d;
1354   2              Diode_parameter1[4]=0x41;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 23  

1355   2            }
1356   1      
1357   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
1358   1          Laser_meds_curent2=Laser_Fed_curent2;
1359   1          if (Laser_Fed_curent2<10)
1360   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
1361   2              Diode_parameter2[1]=0x6d;
1362   2              Diode_parameter2[2]=0x41;
1363   2              Diode_parameter2[3]=0x20;
1364   2              Diode_parameter2[4]=0x20;
1365   2      
1366   2            } else if(Laser_Fed_curent2<100)
1367   1      
1368   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
1369   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
1370   2              Diode_parameter2[2]=0x6d;
1371   2              Diode_parameter2[3]=0x41;
1372   2              Diode_parameter2[4]=0x20;
1373   2            } else if(Laser_Fed_curent2<1000)
1374   1      
1375   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
1376   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
1377   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
1378   2              Diode_parameter2[3]=0x6d;
1379   2              Diode_parameter2[4]=0x41;
1380   2            }
1381   1      
1382   1          return;
1383   1      }
1384          /**************************************************************************/
1385          /*****************************激光功率检测*********************************/
1386          void Laser_power_Check()
1387          {
1388   1      
1389   1          uchar k=10;
1390   1          float a,b;
1391   1          AD_inbuf[8]=0;
1392   1          AD_inbuf[9]=0;
1393   1          do
1394   1          {
1395   2            AD_code=AD_Convert(1);                  //种子源
1396   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
1397   2      
1398   2            AD_code=AD_Convert(4);                  //放大级
1399   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
1400   2            k--;
1401   2          }while(k);
1402   1      
1403   1      
1404   1      
1405   1          AD_inbuf[8]=AD_inbuf[8]/10;
1406   1          AD_inbuf[9]=AD_inbuf[9]/10;
1407   1      
1408   1          AD_code=AD_inbuf[8];
1409   1          a=(float)(AD_code);
1410   1          a=a*2.5;
1411   1          a=a/4096+0.02015;
1412   1          b=a*a*117.314+275.543*a-0.806;
1413   1      
1414   1          Laser_Fed_power1=(uint)(b);
1415   1          Laser_meds_power1=Laser_Fed_power1;
1416   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 24  

1417   1          if (Laser_Fed_power1<10)
1418   1            { Power_parameter1[0]=Laser_Fed_power1+48;
1419   2              Power_parameter1[1]=0x6d;
1420   2              Power_parameter1[2]=0x77;
1421   2              Power_parameter1[3]=0x20;
1422   2              Power_parameter1[4]=0x20;
1423   2              Power_parameter1[5]=0x20;
1424   2      
1425   2            } else if(Laser_Fed_power1<100)
1426   1      
1427   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
1428   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
1429   2              Power_parameter1[2]=0x6d;
1430   2              Power_parameter1[3]=0x77;
1431   2              Power_parameter1[4]=0x20;
1432   2              Power_parameter1[5]=0x20;
1433   2            } else if(Laser_Fed_power1<1000)
1434   1      
1435   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
1436   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
1437   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
1438   2              Power_parameter1[3]=0x6d;
1439   2              Power_parameter1[4]=0x77;
1440   2              Power_parameter1[5]=0x20;
1441   2            }
1442   1      
1443   1          AD_code=AD_inbuf[9];
1444   1          a=(float)(AD_code);
1445   1          a=a*2.5;
1446   1          a=a/4096+0.02015;
1447   1          b=a*a*117.314+275.543*a-0.806;
1448   1      
1449   1          Laser_Fed_power2=(uint)(b);
1450   1          Laser_meds_power2=Laser_Fed_power2;
1451   1      
1452   1          if (Laser_Fed_power2<10)
1453   1            { Power_parameter2[0]=Laser_Fed_power2+48;
1454   2              Power_parameter2[1]=0x6d;
1455   2              Power_parameter2[2]=0x77;
1456   2              Power_parameter2[3]=0x20;
1457   2              Power_parameter2[4]=0x20;
1458   2              Power_parameter2[5]=0x20;
1459   2      
1460   2            } else if(Laser_Fed_power2<100)
1461   1      
1462   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
1463   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
1464   2              Power_parameter2[2]=0x6d;
1465   2              Power_parameter2[3]=0x77;
1466   2              Power_parameter2[4]=0x20;
1467   2              Power_parameter2[5]=0x20;
1468   2            } else if(Laser_Fed_power2<1000)
1469   1      
1470   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
1471   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
1472   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
1473   2              Power_parameter2[3]=0x6d;
1474   2              Power_parameter2[4]=0x77;
1475   2              Power_parameter2[5]=0x20;
1476   2            }
1477   1      
1478   1          return;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 25  

1479   1      
1480   1      
1481   1      
1482   1      }
1483          /**************************************************************************/
1484          
1485          
1486          /*****************************当前冷却温度*********************************/
1487          void TEC_Temp()
1488          {
1489   1          uint  tx1=0;
1490   1          uint  tx2=0;
1491   1          uchar kt=16;
1492   1          AD_inbuf[6]=0;
1493   1          AD_inbuf[7]=0;
1494   1          do
1495   1          {
1496   2            AD_code=AD_Convert(2);        //种子源TEC温度
1497   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
1498   2      
1499   2            AD_code=AD_Convert(5);        //放大级TEC温度
1500   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
1501   2            kt--;
1502   2          }while(kt);
1503   1      
1504   1           AD_inbuf[6]=AD_inbuf[6]/16;
1505   1           AD_inbuf[7]=AD_inbuf[7]/16;
1506   1           TEC_meds_tempture1=AD_inbuf[6];
1507   1           TEC_meds_tempture2=AD_inbuf[7];
1508   1      
1509   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
1510   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
1511   1           tx1= (uint)(TEC_Fed_Tempture1);
1512   1           TEC_meds_tempture1=tx1;
1513   1           tx2= (uint)(TEC_Fed_Tempture2);
1514   1           TEC_meds_tempture2=tx2;
1515   1      
1516   1           TEC_parameter1[0]=tx1 /100+48;
1517   1           TEC_parameter1[1]=(tx1 /10)%10+48;
1518   1           TEC_parameter1[2]=0x2e;
1519   1           TEC_parameter1[3]=tx1 %10+48;
1520   1      
1521   1      
1522   1           TEC_parameter2[0]=tx2 /100+48;
1523   1           TEC_parameter2[1]=(tx2 /10)%10+48;
1524   1           TEC_parameter2[2]=0x2e;
1525   1           TEC_parameter2[3]=tx2 %10+48;
1526   1      
1527   1      
1528   1        return;
1529   1      }
1530          
1531          /**************************************************************************/
1532          
1533          /*****************************当前TEC两端电压******************************/
1534          void TEC_V_Check()                                                 //???????????????????????
1535          {
1536   1          uchar kk=20;
1537   1          AD_inbuf[4]=0;
1538   1          AD_inbuf[5]=0;
1539   1          do
1540   1          {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 26  

1541   2            MCU_ADC(1);
1542   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
1543   2            MCU_ADC(2);
1544   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
1545   2            kk--;
1546   2          }while(kk);
1547   1      
1548   1      
1549   1           TEC_VO1=AD_inbuf[4]/20 ;
1550   1           TEC_VO1=TEC_VO1*5;
1551   1           TEC_VO2=AD_inbuf[4]/20 ;
1552   1           TEC_VO2=TEC_VO2*5;
1553   1      
1554   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
1555   1      //     TEC_parameter[1]=0x2e;
1556   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
1557   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
1558   1      //     TEC_parameter[4]=0xa0;
1559   1      //     TEC_parameter[5]=0x56;
1560   1          return;
1561   1      }
1562          
1563          /**************************************************************************/
1564          
1565          /*****************************监测二极管电压******************************/
1566          void Pdiod_V_Check()
1567          {
1568   1          uchar kk=10;
1569   1          AD_inbuf[2]=0;
1570   1          AD_inbuf[3]=0;
1571   1          do
1572   1          {
1573   2            AD_code=AD_Convert(1);             //种子源激光二极管
1574   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
1575   2      
1576   2            AD_code=AD_Convert(4);             //放大级激光二极管
1577   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
1578   2            kk--;
1579   2          }while(kk);
1580   1      
1581   1           PDiode_V1= AD_inbuf[2]/10;
1582   1           PDiode_V2= AD_inbuf[3]/10;
1583   1           PDiode_V1=(PDiode_V1*5)/2;
1584   1           PDiode_V2=(PDiode_V2*5)/2;
1585   1          return;
1586   1      }
1587          /**************************************************************************/
1588          
1589          
1590          
1591          /*******************************设定温度值*************************************
1592          
1593          void Set_TEC_TEMP(uint tempture)
1594          {
1595               uint kt;
1596          
1597                kt=(uint)((tempture-15)*4096/35);
1598                DA_Convert(1,kt);
1599          
1600          
1601          
1602          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 27  

1603             return;
1604          }
1605          
1606          
1607          /******************************************************************************/
1608          
1609          /*****************************设定功率值**********************************/
1610          void Set_laser_power(uchar Channel,uint power)
1611          {
1612   1        float  u,v;
1613   1        uint   temp_p;
1614   1      
1615   1        if (power<3) power=3;
1616   1        if (power>600) power=600;
1617   1        u=(float)(power);
1618   1        v=(u*u/1000)*3.46;
1619   1        v=6.5068*u+29.61-v;
1620   1        temp_p=(uint)(v);
1621   1      
1622   1      
1623   1        if(Channel==3)                                         //设定种子源功率
1624   1        {
1625   2      
1626   2          if(SHDN1)
1627   2           {
1628   3      
1629   3                DA_Convert(3,temp_p);
1630   3                _Nop();
1631   3                DA_Convert(3,temp_p);
1632   3           }
1633   2      
1634   2           Laser_Set_power1=power;
1635   2         }
1636   1      
1637   1      
1638   1          else if(Channel==0)
1639   1        {
1640   2      
1641   2          if(SHDN2)                                             //设定放大级功率
1642   2           {
1643   3      
1644   3                DA_Convert(0,temp_p);
1645   3                _Nop();
1646   3                DA_Convert(0,temp_p);
1647   3           }
1648   2      
1649   2           Laser_Set_power2=power;
1650   2         }
1651   1      
1652   1         else  _Nop();
1653   1      
1654   1         Laser_power_Check();
1655   1      
1656   1      
1657   1          return;
1658   1      
1659   1      }
1660          
1661          
1662          /*************************************************************************/
1663          
1664          /*****************************设定电流值**********************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 28  

1665          
1666          void Set_laser_current(uchar Channel,uint current)
1667          {
1668   1      
1669   1          uint tmp_c1;
1670   1      
1671   1          if (current<30) current=30;
1672   1          if (current>900) current=900;
1673   1      
1674   1      
1675   1      
1676   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
1677   1      
1678   1      
1679   1      
1680   1      
1681   1      
1682   1          if(Channel==3)
1683   1          {
1684   2             if(SHDN1)
1685   2             {
1686   3      
1687   3                  DA_Convert(3,tmp_c1);
1688   3                  _Nop();
1689   3                  DA_Convert(3,tmp_c1);
1690   3      
1691   3                  Laser_Set_curent1=current;
1692   3             }
1693   2      
1694   2             _Nop();
1695   2          }
1696   1      
1697   1          else if(Channel==0)
1698   1          {
1699   2             if(SHDN2)
1700   2             {
1701   3      
1702   3                  DA_Convert(0,tmp_c1);
1703   3                  _Nop();
1704   3                  DA_Convert(0,tmp_c1);
1705   3      
1706   3                  Laser_Set_curent2=current;
1707   3             }
1708   2      
1709   2             _Nop();
1710   2          }
1711   1      
1712   1      
1713   1      
1714   1      
1715   1      /*
1716   1        if (tmp_c1>tmp_c0)
1717   1          {
1718   1            do
1719   1            {
1720   1      
1721   1              while(!TMPGD)
1722   1              {
1723   1                TEC_Temp();
1724   1                if(tx>280)
1725   1              {
1726   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 29  

1727   1                send_string_com(inbuf1,9);
1728   1                t=0;
1729   1                SHDN=0;
1730   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
1731   1                tmp_c1=246;
1732   1                Laser_Set_curent=30;
1733   1                 do
1734   1               {
1735   1                tmp_c0=tmp_c0-2;
1736   1                DA_Convert(0,tmp_c0);
1737   1                m++;
1738   1      
1739   1                 if(m==240)
1740   1                 {
1741   1                  Diode_curent_Check();
1742   1                  TEC_Temp();
1743   1                  chn_disp (tab6,6,0x80);
1744   1                  delayR(500);
1745   1                  chn_disp (Diode_parameter,6,0x83);
1746   1                  delayR(500);
1747   1                  chn_disp (tab7,4,0x90);
1748   1                  delayR(500);
1749   1                  chn_disp (TEC_parameter,4,0x92);
1750   1                  delayR(100);
1751   1                  chn_disp (tab11,2,0x94);
1752   1                  m=0;
1753   1                 }
1754   1                 delayR(10000);
1755   1                 }while(tmp_c0-tmp_c1);
1756   1                 chn_disp (inbuf1,7,0x96);
1757   1                 goto quit;
1758   1               }
1759   1              }
1760   1      
1761   1      
1762   1              
1763   1      
1764   1      
1765   1           if(m==160)
1766   1          {
1767   1           TEC_Temp();
1768   1           Diode_curent_Check();
1769   1           chn_disp (tab6,6,0x80);
1770   1           delayR(500);
1771   1           chn_disp (Diode_parameter,6,0x83);
1772   1           delayR(500);
1773   1           chn_disp (tab7,4,0x90);
1774   1           delayR(500);
1775   1           chn_disp (TEC_parameter,4,0x92);
1776   1           delayR(100);
1777   1           chn_disp (tab11,2,0x94);
1778   1           m=0;
1779   1          }
1780   1      
1781   1      
1782   1      
1783   1      
1784   1      
1785   1      
1786   1      
1787   1             delayR(10000);
1788   1            }while((tmp_c1-tmp_c0)&& SHDN);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 30  

1789   1      
1790   1             delayR(180);
1791   1      
1792   1          }
1793   1        else if(tmp_c1<tmp_c0)
1794   1      
1795   1          {
1796   1             do
1797   1            {
1798   1              
1799   1           if(m==160)
1800   1           {
1801   1           Diode_curent_Check();
1802   1           TEC_Temp();
1803   1           chn_disp (tab6,6,0x80);
1804   1           delayR(500);
1805   1           chn_disp (Diode_parameter,6,0x83);
1806   1           delayR(500);
1807   1           chn_disp (tab7,4,0x90);
1808   1           delayR(500);
1809   1           chn_disp (TEC_parameter,4,0x92);
1810   1           delayR(100);
1811   1           chn_disp (tab11,2,0x94);
1812   1           m=0;
1813   1           }
1814   1           delayR(10000);
1815   1            }while(tmp_c0-tmp_c1);
1816   1      
1817   1           delay(100);
1818   1      
1819   1          }        */
1820   1          Diode_curent_Check();
1821   1      
1822   1      
1823   1          return;
1824   1      
1825   1      }
1826          
1827          /***************************************************************************/
1828          
1829          /*****************************外部AD转换程序*******************************/
1830          uint AD_Convert(uchar Channel)
1831          {
1832   1         uchar i,Dath,Datl,temp,Contbit;
1833   1         uint Dat_ad;
1834   1         Dath=0;
1835   1         Datl=0;
1836   1         temp=0;
1837   1         Dat_ad=0;
1838   1         switch (Channel)                        //  内部REF
1839   1          {
1840   2              case 0:Contbit=0x00;break;
1841   2              case 1:Contbit=0x08;break;
1842   2              case 2:Contbit=0x10;break;
1843   2              case 3:Contbit=0x18;break;
1844   2              case 4:Contbit=0x20;break;
1845   2              case 5:Contbit=0x28;break;
1846   2              case 6:Contbit=0x30;break;
1847   2              case 7:Contbit=0x38;break;
1848   2              default: break;
1849   2          }
1850   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 31  

1851   1          CSAD=0;
1852   1          _Nop();
1853   1          DCLK=1;
1854   1      
1855   1         for(i=0;i<8;i++)
1856   1         {
1857   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
1858   2      
1859   2            DCLK=0;
1860   2            _Nop();
1861   2            DCLK=1;
1862   2            _Nop();
1863   2      
1864   2         }
1865   1      
1866   1          CSAD=1;
1867   1          _Nop();
1868   1      
1869   1          CSAD=0;
1870   1          _Nop();
1871   1      
1872   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
1873   1          {
1874   2            ADIN=(bit)(Contbit&(0x80>>i));
1875   2      
1876   2            DCLK=0;
1877   2            _Nop();
1878   2            DCLK=1;
1879   2            _Nop();
1880   2            Dath=DOUT;
1881   2            Dath=Dath<<(7-i);
1882   2            temp=temp|Dath;
1883   2          }
1884   1      
1885   1           Dath=temp;
1886   1           temp=0;
1887   1          for(i=0;i<8;i++)
1888   1          {
1889   2            DCLK=0;
1890   2            _Nop();
1891   2            DCLK=1;
1892   2            Datl=DOUT;
1893   2            Datl=Datl<<(7-i);
1894   2            temp=temp|Datl;
1895   2            _Nop();
1896   2      
1897   2          }
1898   1      
1899   1           Datl=temp;
1900   1           Dat_ad=(Dath*256+Datl)&0x0fff;
1901   1      
1902   1           CSAD=1;
1903   1      
1904   1      
1905   1      
1906   1            _Nop();
1907   1      
1908   1            return(Dat_ad);
1909   1      }
1910          
1911          
1912          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 32  

1913          /**************************************************************************/
1914          /*****************************外部PWM设置程序*******************************/
1915          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
1916          { 
1917   1        //脉宽1单位为10NS
1918   1        //延迟1单位为10NS
1919   1        //频率1单位为1KHZ
1920   1      
1921   1        //
1922   1      }
*** WARNING C280 IN LINE 1915 OF DUALDRIVER_GBK.C: 'pwm_pulserate': unreferenced local variable
*** WARNING C280 IN LINE 1915 OF DUALDRIVER_GBK.C: 'pwm_pulsewidth': unreferenced local variable
*** WARNING C280 IN LINE 1915 OF DUALDRIVER_GBK.C: 'pwm_pulsedelay': unreferenced local variable
1923          /**************************************************************************/
1924          /*****************************外部DA转换程序*******************************/
1925          void DA_Convert(uchar Channel, uint Dcode)
1926          {
1927   1      
1928   1        uint  Comdat=0;
1929   1         uchar i;
1930   1         switch (Channel)
1931   1          {
1932   2              case 0:Comdat=Dcode+0x1000;break;
1933   2              case 1:Comdat=Dcode+0x5000;break;
1934   2              case 2:Comdat=Dcode+0x9000;break;
1935   2              case 3:Comdat=Dcode+0xd000;break;
1936   2              default: break;
1937   2          }
1938   1      
1939   1          LDAC=1;                               //数据刷新
1940   1          _Nop();
1941   1          CSDA=0;                               //片选有效
1942   1          FS=1;
1943   1          _Nop();
1944   1          FS=0;
1945   1         for(i=0;i<16;i++)
1946   1        {
1947   2             DINDA=(bit)(Comdat&0x8000);
1948   2             SCLK=1;
1949   2             Comdat=Comdat<<1;
1950   2             _Nop();
1951   2             SCLK=0;
1952   2      
1953   2         }
1954   1      
1955   1         LDAC=0;
1956   1         _Nop();
1957   1         CSDA=1;                             //片选无效
1958   1         Dcode=0;
1959   1        return;
1960   1      
1961   1      }
1962          /**************************************************************************/
1963          
1964          
1965          /*****************************单片机内部AD********************************/
1966           void MCU_ADC(BYTE CHN)
1967           {
1968   1          BYTE    AD_finished;
1969   1          switch (CHN)
1970   1          {
1971   2              case 0: P1ASF=0x01;break;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 33  

1972   2              case 1: P1ASF=0x02;break;
1973   2              case 2:P1ASF=0x04;break;
1974   2              case 3:P1ASF=0x08;break;
1975   2              case 7:P1ASF=0x80;break;
1976   2      
1977   2              default: break;
1978   2          }
1979   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
1980   1          ADC_RES=0;
1981   1          ADC_RESL=0;
1982   1      
1983   1          CHN &= 0x07;                        //0000,0111 清0高5位
1984   1      
1985   1          ADC_CONTR =ADC_SPEEDH ;
1986   1          _nop_();
1987   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
1988   1          _nop_();
1989   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
1990   1          delayR(10);
1991   1          ADC_CONTR |= 0x08;
1992   1          delayR(10);
1993   1          AD_finished = 0;
1994   1          while (AD_finished ==0 )            //等待A/D转换结束
1995   1          {
1996   2            AD_finished = (ADC_CONTR & 0x10);
1997   2          }
1998   1          ADC_CONTR &= 0xE7;
1999   1      
2000   1          P1ASF=0x00;
2001   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
2002   1      
2003   1          return;
2004   1       }
2005          
2006          /*************************************************************************/
2007          
2008          
2009          
2010          void Error_Process()
2011          {
2012   1      
2013   1       _Nop();
2014   1       return;
2015   1      
2016   1      }
2017          
2018          
2019          
2020          /*********以下是长延时程序***********************************************/
2021          
2022          void delay(uint delay_k)
2023          {
2024   1          uint k0=0;
2025   1          do
2026   1          {
2027   2          do{k0--;}while(k0);
2028   2          delay_k--;
2029   2          }while(delay_k);
2030   1      
2031   1      }
2032          
2033          /*********以下是短延时程序***********************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 34  

2034          void delayR(uint delay_k)
2035          {
2036   1          do{delay_k--;}while(delay_k);
2037   1      
2038   1      
2039   1      }
2040          
2041          /*********************************************************************/
2042          
2043          /**************************以下是外部中断0程序************************/
2044           void INT_0() interrupt 0 using 0
2045           {
2046   1          if (!LIM1)
2047   1          Error_Process();
2048   1          else  _Nop();
2049   1      
2050   1          if (!LIM2)
2051   1          Error_Process();
2052   1          else  _Nop();
2053   1          return;
2054   1       }
2055          /*********************************************************************/
2056          
2057          /***************************以下是外部中断1程序***********************/
2058          void INT_1() interrupt 2 using 1
2059          {
2060   1        _Nop();
2061   1        //chn_disp (tab16,20,0x80);
2062   1        //delayR(10000);
2063   1        //chn_disp (tab17,20,0x90);
2064   1        //delay(1000);
2065   1      }
2066          /***********************************************************************/
2067          
2068          
2069          
2070          
2071          
2072          /*****************以下是串口中断程序*******************************/
2073          
2074          void RS232() interrupt 4 using 3
2075          {
2076   1      
2077   1         if(RI)
2078   1         {
2079   2              RI=0;
2080   2      
2081   2              if (SBUF==0x0A)
2082   2              {
2083   3                   read_flag=1;
2084   3      
2085   3                }
2086   2      
2087   2              else
2088   2              {
2089   3      
2090   3      
2091   3                   inbuf[t]=SBUF;
2092   3                   t++;
2093   3      
2094   3      
2095   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 35  

2096   3              }
2097   2      
2098   2         }
2099   1      
2100   1           return;
2101   1      }
2102          
2103          /**********************************************************************/
2104          
2105          /*****************定时器中断程序*******************************/
2106          
2107          void tm0_isr() interrupt 1 using 1
2108          {               
2109   1           TL0 = 0x30;   //设置定时初值
2110   1           TH0 = 0xF8;   //设置定时初值
2111   1           if (count-- == 0)               //1ms * 1000 -> 1s
2112   1           {
2113   2           count = 1000;               //reset counter
2114   2           }
2115   1      }
2116          
2117          /*************************设置错误***************************/
2118          void setfault()
2119          {
2120   1      
2121   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
2122   1      
2123   1        send_string_com(inbuf1,10);
2124   1      
2125   1        t=0;
2126   1      }
2127          /*************************************************************/
2128          
2129          
2130          /*************************设置成功***************************/
2131          void setsucced()
2132          {
2133   1      
2134   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
2135   1      
2136   1        send_string_com(inbuf1,11);
2137   1        t=0;
2138   1        return;
2139   1      }
2140          /*************************************************************/
2141          
2142          
2143          
2144          
2145          
2146          
2147          /********************************警告*************************/
2148          void alarm()
2149          {
2150   1         uchar t=6;
2151   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
2152   1      
2153   1         send_string_com(inbuf1,7);
2154   1        do
2155   1        {
2156   2         delay(50);
2157   2         t--;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 36  

2158   2        }while(t);
2159   1         send_string_com(inbuf1,5);
2160   1         t=6;
2161   1         do
2162   1        {
2163   2         delay(50);
2164   2         t--;
2165   2        }while(t);
2166   1         send_string_com(inbuf1,5);
2167   1      
2168   1      }
2169          /*************************************************************/
2170          
2171          
2172          
2173          /************************主程序*******************************/
2174          void main()
2175          {
2176   1         uchar  i=10;
2177   1         uchar  tmp0=0;
2178   1      // setsucced();
2179   1      // delay(5000);
2180   1      // setsucced();
2181   1      // delay(5000);
2182   1      // setsucced();
2183   1         stat_initial();                               //状态初始划
2184   1         serial_initial();                             //串口初始化
2185   1      // delay(20000);
2186   1      // setsucced();
2187   1      // delay(5000);
2188   1      // setsucced();
2189   1      // delay(5000);
2190   1      // setsucced();
2191   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2192   1      
2193   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2194   1       {
2195   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2196   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2197   2      
2198   2        DA_Convert(3,25);                          // 种子源
2199   2         _Nop();
2200   2        DA_Convert(3,25);
2201   2      
2202   2        DA_Convert(0,25);                          // 放大级
2203   2         _Nop();
2204   2        DA_Convert(0,25);
2205   2       }
2206   1      //////////////////////////////////////////////////////////////////////////////////////////////
2207   1      
2208   1        else
2209   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2210   1       {
2211   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2212   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
2213   2      
2214   2        DA_Convert(3,88);                            // 种子源
2215   2         _Nop();
2216   2        DA_Convert(3,88);
2217   2      
2218   2        DA_Convert(0,88);                            // 放大级
2219   2        _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 37  

2220   2        DA_Convert(0,88);
2221   2       }
2222   1      //////////////////////////////////////////////////////////////////////////////////////////////
2223   1      ///////////////////////////////////上电开始显示//////////////////////////////////////////////tang
2224   1       /*  init_lcd ();
2225   1         delay(5);
2226   1         wr_lcd (comm,0x30);
2227   1         delay(30);                                    //需要足够的等待延时
2228   1         chn_disp (tab1,14,0x80);
2229   1         delay(5);
2230   1         chn_disp (tab2,20,0x90);
2231   1         delay(5);
2232   1         clrram();
2233   1         delay(5);
2234   1         chn_disp (tab3,10,0x80);
2235   1         chn_disp (tab4,12,0x90);
2236   1      
2237   1         clrram();
2238   1         delay(10);
2239   1         chn_disp (tab5,10,0x80);
2240   1         delay(5);
2241   1      */////////////////////////////////////////////////////////////////////////////////////////////
2242   1      
2243   1      
2244   1      
2245   1        do
2246   1         {
2247   2      
2248   2           delay(1);
2249   2      
2250   2           if(read_flag)
2251   2            {
2252   3              command();                        //指令识别
2253   3              read_flag=0;                      //取数标志清0
2254   3              t=0;
2255   3            }
2256   2      
2257   2           _Nop();
2258   2      
2259   2      
2260   2          if(Sys_mod)
2261   2       {
2262   3      
2263   3      
2264   3      /***************************检查按键**************************************/
2265   3      
2266   3       // Key_Button();  tang
2267   3      
2268   3      
2269   3      ///////////////////////////////////////////////////////////////////////////
2270   3      
2271   3      /***************************检查当前实际功率值****************************/
2272   3       //Laser_power_Check(); tang
2273   3      
2274   3      
2275   3      /*************************************************************************/
2276   3      /***************************检测当前实际电流值****************************/
2277   3      
2278   3       Diode_curent_Check();
2279   3      
2280   3      
2281   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 38  

2282   3      
2283   3      ///////////////////////////////////////////////////////////////////////////
2284   3      
2285   3      
2286   3      /***************************检测当前冷却温度******************************/
2287   3         TEC_Temp();
2288   3      
2289   3      
2290   3      
2291   3         if(TEC_meds_tempture1>280)
2292   3      
2293   3         {
2294   4      
2295   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2296   4           if(CONT_MOD)
2297   4           {
2298   5           Set_laser_power(0,3);       //tang
2299   5           Set_laser_power(3,3);
2300   5           }
2301   4           else
2302   4           {
2303   5           Set_laser_current(0,30);
2304   5           Set_laser_current(3,30);
2305   5           }
2306   4           SHDN1=0;
2307   4           SHDN2=0;
2308   4           send_string_com(inbuf1,9);
2309   4           t=0;
2310   4           chn_disp (inbuf1,7,0x86);
2311   4         }
2312   3      
2313   3         if(TEC_meds_tempture2>280)
2314   3      
2315   3         {
2316   4      
2317   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2318   4           if(CONT_MOD)
2319   4           {
2320   5           Set_laser_power(0,3);       //tang
2321   5           Set_laser_power(3,3);
2322   5           }
2323   4           else
2324   4           {
2325   5           Set_laser_current(0,30);
2326   5           Set_laser_current(3,30);
2327   5           }
2328   4           SHDN1=0;
2329   4           
2330   4           SHDN2=0;
2331   4           send_string_com(inbuf1,9);
2332   4           t=0;
2333   4           chn_disp (inbuf1,7,0x96);
2334   4         }
2335   3      //////////////////////////////////////////////////////////////////////////
2336   3      
2337   3      
2338   3      /***************************检测监测二极管反馈电压************************/
2339   3      
2340   3       Pdiod_V_Check();
2341   3      
2342   3      
2343   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 39  

2344   3      //////////////////////////////////////////////////////////////////////////
2345   3      
2346   3      
2347   3      /***************************检测TEC温控是否完成**************************/
2348   3      
2349   3      
2350   3      
2351   3      
2352   3      
2353   3      /////////////////////////////////////////////////////////////////////////
2354   3      
2355   3      
2356   3      /***************************检测TEC两端电压是否正常*********************/
2357   3      
2358   3        TEC_V_Check();
2359   3      
2360   3        if( TEC_VO1>3.1) Error_Process();
2361   3        if( TEC_VO2>3.1) Error_Process();
2362   3      
2363   3      ////////////////////////////////////////////////////////////////////////
2364   3      
2365   3      
2366   3      /****************************LCD显示***********************************
2367   3      
2368   3      
2369   3           chn_disp (tab6,4,0x80);
2370   3           delayR(50);
2371   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2372   3           delayR(50);
2373   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2374   3      
2375   3      
2376   3           chn_disp (tab7,4,0x90);
2377   3           delayR(50);
2378   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2379   3           delayR(50);
2380   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2381   3      
2382   3      
2383   3      
2384   3      
2385   3      
2386   3           if(CONT_MOD)
2387   3           {
2388   3              chn_disp (tab14,6,0x87);
2389   3              delayR(50);
2390   3              chn_disp (tab14,6,0x97);
2391   3            }
2392   3           else
2393   3           {
2394   3              chn_disp (tab15,6,0x87);
2395   3              delayR(50);
2396   3              chn_disp (tab15,6,0x97);
2397   3           }
2398   3      
2399   3      //////////////////////////////////////////////////////////////////////*/
2400   3      }
2401   2      
2402   2      else
2403   2      {
2404   3          // chn_disp (tab16,20,0x80);
2405   3         // delayR(10000);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/03/2013 13:55:49 PAGE 40  

2406   3          // chn_disp (tab17,20,0x90);
2407   3      }
2408   2      
2409   2          }while(1);
2410   1      
2411   1      
2412   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7554    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40     100
   IDATA SIZE       =    114    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)

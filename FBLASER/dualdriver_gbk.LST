C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER_GBK
OBJECT MODULE PLACED IN dualdriver_gbk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver_gbk.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          uint  count=1000;
  23          //uchar code tab1[]={"光纤激光控制器"};
  24          //uchar code tab2[]={"苏州德龙激光有限公司"};
  25          //uchar code tab3[]={"正在初始化"};
  26          //uchar code tab4[]={"请稍候......"};
  27          //uchar code tab5[]={"初始化完成"};
  28          //uchar code tab6[]={"SED:"};
  29          //uchar code tab7[]={"AMP:"};
  30          //uchar code tab8[]={"VOTEC:1.42v"};
  31          //uchar code tab9[]={"设定电流"};
  32          //uchar code tab10[]={"设定温度"};
  33          //uchar code tab11[]={"℃"};
  34          //uchar code tab12[]={"POW:"};
  35          //uchar code tab13[]={"设定功率"};
  36          //uchar code tab14[]={"℃ APC"};
  37          //uchar code tab15[]={"℃ ACC"};
  38          //uchar code tab16[]={"系统采集控制模式中  "};
  39          //uchar code tab17[]={"...................."};
  40          uchar idata  TEC_parameter1[6];
  41          uchar idata  TEC_parameter2[6];
  42          uchar idata  Diode_parameter1[6];
  43          uchar idata  Diode_parameter2[6];
  44          uchar idata  Power_parameter1[6];
  45          uchar idata  Power_parameter2[6];
  46          uchar  set_flag;
  47          
  48          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  49          
  50          uint   idata MCU_AD_code;
  51          uint   idata AD_code;
  52          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  53          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  54          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
  55          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 2   

  56          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  57          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  58          uint   init_current1;                       //种子源初始电流
  59          uint   init_current2;                       //放大级初始电流
  60          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅种子源 3：双路
  61          
  62          uint   idata Laser_Set_power1;             //设定种子源激光功率
  63          uint   idata Laser_Set_power2;             //设定放大级激光功率
  64          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  65          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  66          uint   idata Laser_meds_power1;            //种子源中间设定功率
  67          uint   idata Laser_meds_power2;            //放大级中间设定功率
  68          
  69          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  70          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  71          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  72          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  73          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  74          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  75          
  76          uint   idata Key_V;                         //按键电压
  77          
  78          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  79          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  80          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  81          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  82          uint   pwm_pulserate;
  83          uint   pwm_pulsewidth;
  84          uint   pwm_pulsedelay;
  85          
  86          
  87          uchar  t=0;                                 // 缓冲区数据段
  88          
  89          bit  read_flag=0;                           // 读取标志位
  90          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  91          
  92          
  93          //////////////////////////输入控制位/////////////////////////////////////////////////////
  94          
  95          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  96          
  97          
  98          
  99          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
 100          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
 101          sbit DOUT=P1^6;                      //AD串行输出
 102          
 103          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 104          
 105          //////////////////////////输出控制位/////////////////////////////////////////////////////
 106          sbit LDAC=P2^2;                      //DA装载信号
 107          sbit CSDA=P4^0;                      //DA选通信号
 108          sbit DINDA=P2^1;                     //DA串行数据输入
 109          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 110          sbit SCLK=P2^0;                      //DA时钟输入
 111          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 112          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 113          
 114          sbit FS=P3^7;                        //DA帧信号
 115          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 116          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 117          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 3   

 118          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 119          sbit LIM2=P2^5;                      //激光二极管过流中断信号
 120          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 121          sbit DCLK=P1^7;                      //AD时钟信号
 122          sbit ADIN=P1^5;                      //AD串行数据输入
 123          sbit CSAD=P2^4;                      //AD选通信号，L－选通 
 124          
 125          uint AD_Convert(uchar Channel);      //AD转换
 126          void DA_Convert(uchar Channel, uint Dcode);      //DA转换
 127          //void Set_TEC_TEMP(uint tempture);              //设定冷却温度
 128          void Set_laser_current(uchar Channel,uint current);    //设定激光二极管电流
 129          void Set_laser_power(uchar Channel,uint power);        //设定激光功率
 130          void MCU_ADC(BYTE CHN);                      //单片机内部AD转换
 131          //void Key_Button();                           //按键判别
 132          void TEC_V_Check();                          //TEC两端电压
 133          void Diode_curent_Check();                   //激光二极管电流检测
 134          void Laser_power_Check();                    //激光功率检测
 135          void Pdiod_V_Check();                        //激光二极管监测电压
 136          void TEC_Temp();                             //TEC温度
 137          void Error_Process();                        //异常处理
 138          void wr_lcd (uchar dat_comm,uchar content);
 139          //void Lcd_disp();
 140          void Pwm_Set(uint,uint,uint);
 141          void Sdio_check();                     // 加电流时状态检查
 142          
 143          void serial_initial();                 // 串口初始化
 144          void stat_initial();                   // 状态初始化
 145          void INT_0();                          // 外部中断0
 146          void delay(uint);                      // 长延时
 147          void delayR(uint);                     // 短延时
 148          void RS232();                          // 串口中断
 149          
 150          
 151          
 152          void command();                        // 指令判断
 153          void setfault();                       // 设置错误
 154          void setsucced();                      // 设置成功
 155          void alarm();                          // 警告
 156          
 157          
 158          
 159          /***************向串口发送一个字符串*****************/
 160          void send_string_com(uchar *str,uchar strlen)
 161          {
 162   1          uchar k=0;
 163   1          do
 164   1          {
 165   2              SBUF=*(str + k);
 166   2              while(TI==0);
 167   2              TI=0;
 168   2              k++;
 169   2          } while(k < strlen);
 170   1      }
 171          /************************************************************************/
 172          
 173          
 174          
 175          
 176          /***********以下是串口初始化程序********************************************/
 177          void serial_initial()
 178          {
 179   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 4   

 180   1      
 181   1            PCON |= 0x80;             //使能波特率倍速位SMOD
 182   1            SCON = 0x50;              //8位数据,可变波特率
 183   1            BRT = 0x64;               //设定独立波特率发生器重装值
 184   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 185   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 186   1            AUXR |= 0x10;             //启动独立波特率发生器
 187   1      
 188   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 189   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 190   1      
 191   1            IPH=0x14;
 192   1            IP=0x24;
 193   1            ES=1;
 194   1            ET0=1;
 195   1            IT0=1;
 196   1            EX0=1;
 197   1            IT1=1;
 198   1            EX1=1;
 199   1            EA=1;
 200   1            TL0 = 0x30;   //设置定时初值
 201   1            TH0 = 0xF8;   //设置定时初值
 202   1            TF0 = 0;    //清除TF0标志
 203   1            TR0 = 0;    //定时器0开始计时
 204   1      
 205   1            return;
 206   1      }
 207          
 208          /**********************************************************************/
 209          
 210          
 211          
 212          
 213          /***********以下是状态初始化程序*********************************/
 214          void stat_initial()
 215          {
 216   1      
 217   1           ADC_RES=0;
 218   1           ADC_RESL=0;
 219   1      
 220   1           read_flag=0;          //读取标志清零
 221   1           las_di_ok=0;
 222   1           t=0;
 223   1           set_flag=0;
 224   1           Sys_mod=1;
 225   1      
 226   1           AD_code=0;
 227   1      //     Laser_Set_curent=0;
 228   1           Laser_Fed_curent1=0;
 229   1           Laser_Fed_curent2=0;
 230   1           Laser_Fed_power1=0;
 231   1           Laser_Fed_power2=0;
 232   1      
 233   1      /**************DA引脚初始化*************************/
 234   1           CSDA=1;
 235   1           LDAC=1;
 236   1           FS=0;
 237   1           SCLK=0;
 238   1           DINDA=0;
 239   1      /**************************************************/
 240   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
 241   1           _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 5   

 242   1           DA_Convert(2,1273);
 243   1           _Nop();
 244   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
 245   1           _Nop();
 246   1           DA_Convert(1,1273);
 247   1      /**************************************************/
 248   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
 249   1      
 250   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
 251   1       {
 252   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
 253   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
 254   2      
 255   2        DA_Convert(3,25);                          // 种子源
 256   2         _Nop();
 257   2        DA_Convert(3,25);
 258   2      
 259   2        DA_Convert(0,25);                          // 放大级
 260   2         _Nop();
 261   2        DA_Convert(0,25);
 262   2       }
 263   1      //////////////////////////////////////////////////////////////////////////////////////////////
 264   1      
 265   1        else
 266   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
 267   1       {
 268   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
 269   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
 270   2      
 271   2        DA_Convert(3,92);                            // 种子源
 272   2         _Nop();
 273   2        DA_Convert(3,92);
 274   2      
 275   2        DA_Convert(0,89);                            // 放大级
 276   2        _Nop();
 277   2        DA_Convert(0,89);
 278   2       }
 279   1      //////////////////////////////////////////////////////////////////////////////////////////////
 280   1      
 281   1      
 282   1      
 283   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
 284   1           P1M1=0x07;
 285   1           P1M0=0x00;
 286   1      
 287   1           CSAD=1;
 288   1           DCLK=1;
 289   1           DOUT=1;
 290   1      
 291   1      
 292   1      
 293   1      
 294   1      
 295   1      /*************TEC控制器初始化*********************/
 296   1           SHDN1=1;
 297   1      //   TMPGD1=1;
 298   1           LIM1=1;
 299   1      
 300   1           SHDN2=1;
 301   1      //   TMPGD2=1;
 302   1           LIM2=1;
 303   1      /*************************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 6   

 304   1      
 305   1      /*    Power_parameter[0]='P';
 306   1            Power_parameter[1]='O';
 307   1            Power_parameter[2]='W';
 308   1            Power_parameter[3]=':';
 309   1      
 310   1            Diode_parameter[0]='L';
 311   1            Diode_parameter[1]='D';
 312   1            Diode_parameter[2]='C';
 313   1            Diode_parameter[3]=':';
 314   1            Diode_parameter[8]=0x20;
 315   1            Diode_parameter[9]=0x20;
 316   1      
 317   1            TEC_parameter[0]='T';
 318   1            TEC_parameter[1]='E';
 319   1            TEC_parameter[2]='C';
 320   1            TEC_parameter[3]=':';
 321   1      */
 322   1      
 323   1           TR0=0;
 324   1           ET0=0;
 325   1           TR1=0;
 326   1           ET1=0;
 327   1           EX0=0;
 328   1      
 329   1           return;
 330   1      }
 331          
 332          /***************************************************************/
 333          
 334          
 335          
 336          /****************************操作指令执行***********************/
 337          void command()
 338          {
 339   1      
 340   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
 341   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
 342   1              {
 343   2                 stat_initial();
 344   2                 serial_initial();
 345   2                 setsucced();
 346   2              }
 347   1      
 348   1      ///////////////////////////////////设定电流////////////////////////////////////////////
 349   1             else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='='))
 350   1      
 351   1                 {
 352   2                     uint dio_cu;
 353   2                     uchar CH;
 354   2      
 355   2                     if(inbuf[5]==0x0d)                                        //格式为LD1(2)=N
 356   2                    {
 357   3                       dio_cu=inbuf[4]-48;
 358   3      
 359   3      
 360   3                    }
 361   2                     else if(inbuf[6]==0x0d)                                   //格式为LD1(2)=NN
 362   2                    {
 363   3                       dio_cu=(uint)((inbuf[4]-48)*10+(inbuf[5]-48));
 364   3      
 365   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 7   

 366   2                    else if(inbuf[7]==0x0d)                                    //格式为LD1(2)=NNN
 367   2                    {
 368   3                       dio_cu=(uint)((inbuf[4]-48)*100+(inbuf[5]-48)*10+(inbuf[6]-48));
 369   3      
 370   3                    }
 371   2      
 372   2                    else                                                    //格式为LD1(2)=NNNN
 373   2                    {
 374   3                        setfault();
 375   3                        goto setcf;
 376   3                    }
 377   2      
 378   2                    if(inbuf[2]=='1')
 379   2                    {
 380   3                      CH=3;                                     //种子源SEED
 381   3                      Set_laser_current(CH,dio_cu);
 382   3                      setsucced();
 383   3                    }
 384   2                    else if(inbuf[2]=='2')
 385   2                    {
 386   3                      CH=0;                                    //放大级AMP
 387   3                      Set_laser_current(CH,dio_cu);
 388   3                      setsucced();
 389   3                    }
 390   2                    else setfault();
 391   2      
 392   2      setcf:       _Nop();
 393   2      
 394   2                 }
 395   1      
 396   1      
 397   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
 398   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
 399   1      
 400   1                 {
 401   2                     uint init_current;
 402   2                     uchar CH;
 403   2      
 404   2                     if(inbuf[7]==0x0d)                                        //格式为INIC=N
 405   2                    {
 406   3                       init_current=inbuf[6]-48;
 407   3      
 408   3      
 409   3                    }
 410   2                     else if(inbuf[8]==0x0d)                                   //格式为INIC=NN
 411   2                    {
 412   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 413   3      
 414   3                    }
 415   2                    else if(inbuf[9]==0x0d)                                    //格式为INIC=NNN
 416   2                    {
 417   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 418   3      
 419   3                    }
 420   2      
 421   2                    else                                                    //格式为INIC=NNNN
 422   2                    {
 423   3                        setfault();
 424   3                        goto seticf;
 425   3                    }
 426   2      
 427   2                    if(inbuf[5]=='S')
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 8   

 428   2                    {
 429   3                      init_current1=init_current;
 430   3                    }
 431   2                    else if(inbuf[5]=='A')
 432   2                    {
 433   3                      init_current2=init_current;
 434   3                    }
 435   2                    else setfault();
 436   2      
 437   2      seticf:       _Nop();
 438   2      
 439   2                 }
 440   1      
 441   1      
 442   1      
 443   1      ///////////////////////////////////设定初始化模式 0/1/2/3 ////////////////////////////////////////////
 444   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
 445   1      
 446   1                 {   
 447   2                     uint init_flag_temp;
 448   2                     uchar CH;
 449   2      
 450   2                     if(inbuf[6]==0x0d)                                        
 451   2                    {
 452   3                       init_flag_temp=inbuf[5]-48;
 453   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
 454   3                        goto setief;
 455   3                      else
 456   3                        init_flag=init_flag_temp;
 457   3                    }
 458   2                    else                                                    
 459   2                    {
 460   3                        setfault();
 461   3                        goto setief;
 462   3                    }
 463   2      
 464   2      setief:       _Nop();
 465   2      
 466   2                 }
 467   1      
 468   1      
 469   1       //////////////////////////////设定功率//////////////////////////////////////////////////
 470   1              else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 471   1                  {
 472   2                     uint las_pow;
 473   2                     uchar CHH;
 474   2                     if(inbuf[4]==0x0d)                                        //格式为P1(2)=N
 475   2                    {
 476   3                       las_pow=(uint)(inbuf[3]-48);
 477   3      
 478   3                    }
 479   2                     else if(inbuf[5]==0x0d)                                   //格式为P1(2)=NN
 480   2                    {
 481   3                       las_pow=(uint)((inbuf[3]-48)*10+(inbuf[4]-48));
 482   3      
 483   3                    }
 484   2                    else if(inbuf[6]==0x0d)                                    //格式为P1(2)=NNN
 485   2                    {
 486   3                       las_pow=(uint)((inbuf[3]-48)*100+(inbuf[4]-48)*10+(inbuf[5]-48));
 487   3      
 488   3                    }
 489   2      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 9   

 490   2                    else                                                      //格式为P1(2)=NNNN
 491   2                    {
 492   3                        setfault();
 493   3                        goto setpf;
 494   3                    }
 495   2      
 496   2                    if(inbuf[2]=='1')
 497   2                    {
 498   3                      CH=3;                                     //种子源SEED
 499   3                      Set_laser_power(CHH,las_pow);
 500   3                      setsucced();
 501   3                    }
 502   2                    else if(inbuf[2]=='2')
 503   2                    {
 504   3                      CH=0;                                    //放大级AMP
 505   3                      Set_laser_power(CHH,las_pow);
 506   3                      setsucced();
 507   3                    }
 508   2                    else setfault();
 509   2      
 510   2      setpf:       _Nop();
 511   2      
 512   2      
 513   2                  }
 514   1       ////////////////////////////////////////////////////////////////////////////////////////
 515   1       //////////////////////////////设定温度//////////////////////////////////////////////////
 516   1              else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 517   1                 {
 518   2                    uint  tmp_tec=0;
 519   2                    uint kt=0;
 520   2                    if(inbuf[5]==0x0d)
 521   2                    {
 522   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 523   3      
 524   3      
 525   3      
 526   3      
 527   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
 528   3      
 529   3                    }
 530   2                    else if(inbuf[7]==0x0d)
 531   2                    {
 532   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 533   3      
 534   3                       kt=((tmp_tec-15)*691+(inbuf[6]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[6]-48)*59/5+90;
 535   3      
 536   3                    }
 537   2      
 538   2                    else
 539   2                    {
 540   3                       setfault();
 541   3                       goto settf;
 542   3                    }
 543   2      
 544   2                     if(inbuf[1]=='1')
 545   2                    {
 546   3                      DA_Convert(2,kt);                         //种子源SEED
 547   3                      _Nop();
 548   3                      DA_Convert(2,kt);
 549   3                      setsucced();
 550   3                    }
 551   2                    else if(inbuf[1]=='2')
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 10  

 552   2                    {
 553   3                      DA_Convert(1,kt);                         //放大级AMP
 554   3                      _Nop();
 555   3                      DA_Convert(1,kt);
 556   3                      setsucced();
 557   3                    }
 558   2                    else setfault();
 559   2      
 560   2      settf:       _Nop();
 561   2      
 562   2      
 563   2                 }
 564   1      
 565   1       ////////////////////////////////////////////////////////////////////////////////////////
 566   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
 567   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
 568   1               {
 569   2                     
 570   2                   
 571   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
 572   2                    {
 573   3                       pwm_pulserate=inbuf[5]-48;
 574   3      
 575   3      
 576   3                    }
 577   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
 578   2                    {
 579   3                       pwm_pulserate=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 580   3      
 581   3                    }
 582   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 583   2                    {
 584   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 585   3      
 586   3                    }
 587   2                  
 588   2                    else                                                    //格式为PURA=NNNN
 589   2                    {
 590   3                        setfault();
 591   3                        goto setprf;
 592   3                    }
 593   2                      Pwm_Set(pwm_pulserate,0,0);
 594   2                      setsucced();
 595   2      setprf:       _Nop();
 596   2      
 597   2                 }
 598   1                ////////////////////////////////////////////////////////////////////////////////////////
 599   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
 600   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
 601   1               {
 602   2                    
 603   2                   
 604   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
 605   2                    {
 606   3                       pwm_pulsewidth=inbuf[5]-48;
 607   3      
 608   3      
 609   3                    }
 610   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
 611   2                    {
 612   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 11  

 613   3      
 614   3                    }
 615   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 616   2                    {
 617   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 618   3      
 619   3                    }
 620   2                  
 621   2                    else                                                    //格式为PUWI=NNNN
 622   2                    {
 623   3                        setfault();
 624   3                        goto setpwf;
 625   3                    }
 626   2                        Pwm_Set(0,pwm_pulsewidth,0);
 627   2                      setsucced();
 628   2      setpwf:       _Nop();
 629   2      
 630   2                 }
 631   1      
 632   1                 ////////////////////////////////////////////////////////////////////////////////////////
 633   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
 634   1              else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='='))
 635   1               {
 636   2                   
 637   2                   
 638   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
 639   2                    {
 640   3                       pwm_pulsedelay=inbuf[5]-48;
 641   3      
 642   3      
 643   3                    }
 644   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
 645   2                    {
 646   3                       pwm_pulsedelay=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 647   3      
 648   3                    }
 649   2                    else                                                    //格式为DELY=NNNN
 650   2                    {
 651   3                        setfault();
 652   3                        goto setpdf;
 653   3                    }
 654   2                      Pwm_Set(0,0,pwm_pulsedelay);
 655   2                      setsucced();
 656   2      setpdf:       _Nop();
 657   2      
 658   2                 }
 659   1      
 660   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
 661   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
 662   1      
 663   1                 {
 664   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
 665   2                    {
 666   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
 667   3                       setsucced();
 668   3                    }
 669   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
 670   2                    {
 671   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
 672   3                       setsucced();
 673   3                    }
 674   2                    setfault();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 12  

 675   2      
 676   2                 }
 677   1      
 678   1       //////////////////////////////////强制关电流///////////////////////////////////////
 679   1      
 680   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
 681   1      
 682   1                 {
 683   2                    if(inbuf[7]==0x0d)
 684   2                    {
 685   3                       if(inbuf[5]=='S')
 686   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
 687   3                       else  if(inbuf[5]=='A')
 688   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
 689   3                       else
 690   3                        {
 691   4                         setfault();
 692   4                         goto setdf;
 693   4                        }
 694   3                       if (!LIM1)
 695   3                       {
 696   4                         Set_laser_current(3,50);
 697   4                         setsucced();
 698   4                        }
 699   3                       else if(!LIM2)
 700   3                       {
 701   4                         Set_laser_current(0,50);
 702   4                         setsucced();
 703   4                        }
 704   3                       else
 705   3                        {
 706   4                         setfault();
 707   4                         goto setdf;
 708   4                        }
 709   3                    }
 710   2                    else
 711   2                       setfault();
 712   2      setdf:       _Nop();
 713   2                 }
 714   1      //////////////////////////////////总查询（电流、温度、功率）/////////////////////////////////
 715   1            else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&((inbuf[2]=='A')&&(inbuf[3]=='T'))&&(inbuf[4]=='E')&&(inbu
             -f[5]=='?'))
 716   1       {
 717   2                    uint ky;
 718   2      //              TEC_Temp();
 719   2                    inbuf[0]= 0x0d;
 720   2                    send_string_com(inbuf,1);
 721   2                      inbuf[0] ='L';
 722   2                      inbuf[1] ='D';
 723   2                      inbuf[2] ='1';
 724   2                      inbuf[3] ='=';
 725   2                  if(Laser_Fed_curent1<10)
 726   2                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 727   3                      inbuf[5]=0x0d;
 728   3                      inbuf[6]=0x0a;
 729   3                      send_string_com(inbuf,7);
 730   3                    }else if (Laser_Fed_curent1<100)
 731   2                    { 
 732   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 733   3                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 734   3                      inbuf[6]=0x0d;
 735   3                      inbuf[7]=0x0a;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 13  

 736   3                      send_string_com(inbuf,8);
 737   3                    }else if (Laser_Fed_curent1<1000)
 738   2                    {
 739   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 740   3                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 741   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 742   3                      inbuf[7]=0x0d;
 743   3                      inbuf[8]=0x0a;
 744   3                      send_string_com(inbuf,9);
 745   3                    }
 746   2                    else
 747   2                      setfault();
 748   2      
 749   2                      inbuf[0] ='L';
 750   2                      inbuf[1] ='D';
 751   2                      inbuf[2] ='2';
 752   2                      inbuf[3] ='=';
 753   2                  if(Laser_Fed_curent2<10)
 754   2                    {
 755   3                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 756   3                      inbuf[5]=0x0d;
 757   3                      inbuf[6]=0x0a;
 758   3                      send_string_com(inbuf,7);
 759   3                    }else if (Laser_Fed_curent2<100)
 760   2                    {
 761   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
 762   3                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
 763   3                      inbuf[6]=0x0d;
 764   3                      inbuf[7]=0x0a;
 765   3                      send_string_com(inbuf,8);
 766   3                    }else if (Laser_Fed_curent2<1000)
 767   2                    {
 768   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
 769   3                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 770   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
 771   3                      inbuf[7]=0x0d;
 772   3                      inbuf[8]=0x0a;
 773   3                      send_string_com(inbuf,9);
 774   3                    }
 775   2                    else
 776   2                      setfault();
 777   2                    inbuf[0]= 0x0d;
 778   2                    send_string_com(inbuf,1);
 779   2                      inbuf[0] ='P';
 780   2                      inbuf[1] ='1';
 781   2                      inbuf[2] ='=';
 782   2                if(Laser_Fed_power1<10)
 783   2                    {
 784   3                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
 785   3                      inbuf[4]=0x0d;
 786   3                      inbuf[5]=0x0a;
 787   3                      send_string_com(inbuf,6);
 788   3                    }else if (Laser_Fed_power1<100)
 789   2                    {
 790   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
 791   3                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
 792   3                      inbuf[5]=0x0d;
 793   3                      inbuf[6]=0x0a;
 794   3                      send_string_com(inbuf,7);
 795   3                    }else if (Laser_Fed_power1<1000)
 796   2                    {
 797   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 14  

 798   3                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
 799   3                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
 800   3                      inbuf[6]=0x0d;
 801   3                      inbuf[7]=0x0a;
 802   3                      send_string_com(inbuf,8);
 803   3                    }
 804   2                    else
 805   2                      setfault();
 806   2                      
 807   2                      inbuf[0] ='P';
 808   2                      inbuf[1] ='2';
 809   2                      inbuf[2] ='=';
 810   2                    if(Laser_Fed_power2<10)
 811   2                    {
 812   3                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
 813   3                      inbuf[4]=0x0d;
 814   3                      inbuf[5]=0x0a;
 815   3                      send_string_com(inbuf,6);
 816   3                    }else if (Laser_Fed_power2<100)
 817   2                    {
 818   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
 819   3                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
 820   3                      inbuf[5]=0x0d;
 821   3                      inbuf[6]=0x0a;
 822   3                      send_string_com(inbuf,7);
 823   3                    }else if (Laser_Fed_power2<1000)
 824   2                    {
 825   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
 826   3                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
 827   3                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
 828   3                      inbuf[6]=0x0d;
 829   3                      inbuf[7]=0x0a;
 830   3                      send_string_com(inbuf,8);
 831   3                    }
 832   2                    else
 833   2                      setfault();
 834   2      
 835   2                      inbuf[0]= 0x0d;
 836   2                      send_string_com(inbuf,1);
 837   2                      ky=(uint)(TEC_Fed_Tempture1);
 838   2                      inbuf[0] ='T';
 839   2                      inbuf[1] ='1';
 840   2                      inbuf[2] ='=';
 841   2                    if (ky<1000)
 842   2                    {
 843   3                      inbuf[3]  =ky/100+48;
 844   3                      inbuf[4]  =(ky/10)%10+48;
 845   3                      inbuf[5]  ='.';
 846   3                      inbuf[6]  =ky%10+48;
 847   3                      inbuf[7] =0x0d;
 848   3                      inbuf[8] =0x0a;
 849   3                      send_string_com(inbuf,9);
 850   3                    }
 851   2                    else
 852   2                     alarm();
 853   2                  
 854   2                     
 855   2                      ky=(uint)(TEC_Fed_Tempture2);
 856   2                      inbuf[0] ='T';
 857   2                      inbuf[1] ='2';
 858   2                      inbuf[2] ='=';
 859   2                    if (ky<1000)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 15  

 860   2                    {
 861   3                      inbuf[3]  =ky/100+48;
 862   3                      inbuf[4]  =(ky/10)%10+48;
 863   3                      inbuf[5]  ='.';
 864   3                      inbuf[6]  =ky%10+48;
 865   3                      inbuf[7] =0x0d;
 866   3                      inbuf[8] =0x0a;
 867   3                      send_string_com(inbuf,9);
 868   3                    }
 869   2                    else
 870   2                     alarm();
 871   2                     inbuf[0]= 0x0d;
 872   2                    send_string_com(inbuf,1);
 873   2                   if (TMPGD1)
 874   2                    {
 875   3                      inbuf[0]='T';
 876   3                      inbuf[1]='1';
 877   3                      inbuf[2]='O';
 878   3                      inbuf[3]='K';
 879   3                      inbuf[4]=0x0d;
 880   3                      inbuf[5]=0x0a;
 881   3                      send_string_com(inbuf,6);
 882   3                    }
 883   2      
 884   2                    else
 885   2                    {
 886   3                      inbuf[0]='T';
 887   3                      inbuf[1]='1';
 888   3                      inbuf[2]='N';
 889   3                      inbuf[3]='O';
 890   3                      inbuf[4]=0x0d;
 891   3                      inbuf[5]=0x0a;
 892   3                      send_string_com(inbuf,6);
 893   3                    }
 894   2      
 895   2                    if (TMPGD2)
 896   2                    {
 897   3                      inbuf[0]='T';
 898   3                      inbuf[1]='2';
 899   3                      inbuf[2]='O';
 900   3                      inbuf[3]='K';
 901   3                      inbuf[4]=0x0d;
 902   3                      inbuf[5]=0x0a;
 903   3                      send_string_com(inbuf,6);
 904   3                    }
 905   2      
 906   2                    else
 907   2                    {
 908   3                      inbuf[0]='T';
 909   3                      inbuf[1]='2';
 910   3                      inbuf[2]='N';
 911   3                      inbuf[3]='O';
 912   3                      inbuf[4]=0x0d;
 913   3                      inbuf[5]=0x0a;
 914   3                      send_string_com(inbuf,6);
 915   3                    }
 916   2      
 917   2                     inbuf[0] ='R';
 918   2                      inbuf[1] ='A';
 919   2                      inbuf[2] ='T';
 920   2                      inbuf[3] ='E';
 921   2                      inbuf[4] ='=';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 16  

 922   2                      inbuf[5]  =pwm_pulserate/10+48;
 923   2                      inbuf[6]  =pwm_pulserate%10+48;
 924   2                      inbuf[7]  ='K';
 925   2                      inbuf[8] =0x0d;
 926   2                      inbuf[9] =0x0a;
 927   2                      send_string_com(inbuf,10);
 928   2                    
 929   2                      inbuf[0] ='W';
 930   2                      inbuf[1] ='I';
 931   2                      inbuf[2] ='D';
 932   2                      inbuf[3] ='T';
 933   2                      inbuf[4] ='H';
 934   2                      inbuf[5]  ='=';
 935   2                      inbuf[6]  =pwm_pulsewidth%10+48;
 936   2                      inbuf[7]  ='L';
 937   2                      inbuf[8] =0x0d;
 938   2                      inbuf[9] =0x0a;
 939   2                      send_string_com(inbuf,10);
 940   2                      
 941   2                      inbuf[0] ='D';
 942   2                      inbuf[1] ='E';
 943   2                      inbuf[2] ='L';
 944   2                      inbuf[3] ='A';
 945   2                      inbuf[4] ='Y';
 946   2                      inbuf[5]  ='=';
 947   2                      inbuf[6]  =pwm_pulsedelay%10+48;
 948   2                      inbuf[7]  ='L';
 949   2                      inbuf[8] =0x0d;
 950   2                      inbuf[9] =0x0a;
 951   2                      send_string_com(inbuf,10);
 952   2      }
 953   1      
 954   1      
 955   1      
 956   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
 957   1            else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='?'))
 958   1                 {
 959   2                  if(inbuf[2]=='1')
 960   2                  {   inbuf[0] ='L';
 961   3                      inbuf[1] ='D';
 962   3                      inbuf[2] ='1';
 963   3                      inbuf[3] ='=';
 964   3                  if(Laser_Fed_curent1<10)
 965   3                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 966   4                      inbuf[5]=0x0d;
 967   4                      inbuf[6]=0x0a;
 968   4                      send_string_com(inbuf,7);
 969   4                    }else if (Laser_Fed_curent1<100)
 970   3                    { 
 971   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 972   4                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 973   4                      inbuf[6]=0x0d;
 974   4                      inbuf[7]=0x0a;
 975   4                      send_string_com(inbuf,8);
 976   4                    }else if (Laser_Fed_curent1<1000)
 977   3                    {
 978   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 979   4                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 980   4                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 981   4                      inbuf[7]=0x0d;
 982   4                      inbuf[8]=0x0a;
 983   4                      send_string_com(inbuf,9);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 17  

 984   4                    }
 985   3                    else
 986   3                      setfault();
 987   3      
 988   3                     }
 989   2       //////////////////////////////////////////////////////////
 990   2                  else if(inbuf[2]=='2')
 991   2                    {  inbuf[0] ='L';
 992   3                      inbuf[1] ='D';
 993   3                      inbuf[2] ='2';
 994   3                      inbuf[3] ='=';
 995   3                  if(Laser_Fed_curent2<10)
 996   3                    {
 997   4                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 998   4                      inbuf[5]=0x0d;
 999   4                      inbuf[6]=0x0a;
1000   4                      send_string_com(inbuf,7);
1001   4                    }else if (Laser_Fed_curent2<100)
1002   3                    {
1003   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
1004   4                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
1005   4                      inbuf[6]=0x0d;
1006   4                      inbuf[7]=0x0a;
1007   4                      send_string_com(inbuf,8);
1008   4                    }else if (Laser_Fed_curent2<1000)
1009   3                    {
1010   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
1011   4                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
1012   4                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
1013   4                      inbuf[7]=0x0d;
1014   4                      inbuf[8]=0x0a;
1015   4                      send_string_com(inbuf,9);
1016   4                    }
1017   3                    else
1018   3                      setfault();
1019   3                 }
1020   2               }
1021   1      
1022   1      
1023   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
1024   1            else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1025   1      
1026   1                 {
1027   2                  if(inbuf[1]=='1')
1028   2                    {
1029   3                     inbuf[0] ='P';
1030   3                      inbuf[1] ='1';
1031   3                      inbuf[2] ='=';
1032   3                    if(Laser_Fed_power1<10)
1033   3                    {
1034   4                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
1035   4                      inbuf[4]=0x0d;
1036   4                      inbuf[5]=0x0a;
1037   4                      send_string_com(inbuf,6);
1038   4                    }else if (Laser_Fed_power1<100)
1039   3                    {
1040   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
1041   4                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
1042   4                      inbuf[5]=0x0d;
1043   4                      inbuf[6]=0x0a;
1044   4                      send_string_com(inbuf,7);
1045   4                    }else if (Laser_Fed_power1<1000)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 18  

1046   3                    {
1047   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
1048   4                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
1049   4                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
1050   4                      inbuf[6]=0x0d;
1051   4                      inbuf[7]=0x0a;
1052   4                      send_string_com(inbuf,8);
1053   4                    }
1054   3                    else
1055   3                      setfault();
1056   3                      
1057   3                    }
1058   2                    else if(inbuf[1]=='2')
1059   2                     {
1060   3                      inbuf[0] ='P';
1061   3                      inbuf[1] ='2';
1062   3                      inbuf[2] ='=';
1063   3                    if(Laser_Fed_power2<10)
1064   3                    {
1065   4                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
1066   4                      inbuf[4]=0x0d;
1067   4                      inbuf[5]=0x0a;
1068   4                      send_string_com(inbuf,6);
1069   4                    }else if (Laser_Fed_power2<100)
1070   3                    {
1071   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
1072   4                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
1073   4                      inbuf[5]=0x0d;
1074   4                      inbuf[6]=0x0a;
1075   4                      send_string_com(inbuf,7);
1076   4                    }else if (Laser_Fed_power2<1000)
1077   3                    {
1078   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
1079   4                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
1080   4                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
1081   4                      inbuf[6]=0x0d;
1082   4                      inbuf[7]=0x0a;
1083   4                      send_string_com(inbuf,8);
1084   4                    }
1085   3                    else
1086   3                      setfault();
1087   3                  }
1088   2                 }
1089   1      
1090   1      ///////////////////////////////////查询PWM情况////////////////////////////////
1091   1            else if((inbuf[0]=='P')&&((inbuf[1]=='W')&&(inbuf[2]=='M'))&&(inbuf[3]=='?'))
1092   1                 {
1093   2      
1094   2                      inbuf[0] ='R';
1095   2                      inbuf[1] ='A';
1096   2                      inbuf[2] ='T';
1097   2                      inbuf[3] ='E';
1098   2                      inbuf[4] ='=';
1099   2                      inbuf[5]  =pwm_pulserate/10+48;
1100   2                      inbuf[6]  =pwm_pulserate%10+48;
1101   2                      inbuf[7]  ='K';
1102   2                      inbuf[8] =0x0d;
1103   2                      inbuf[9] =0x0a;
1104   2                      send_string_com(inbuf,10);
1105   2                    
1106   2                      inbuf[0] ='W';
1107   2                      inbuf[1] ='I';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 19  

1108   2                      inbuf[2] ='D';
1109   2                      inbuf[3] ='T';
1110   2                      inbuf[4] ='H';
1111   2                      inbuf[5]  ='=';
1112   2                      inbuf[6]  =pwm_pulsewidth%10+48;
1113   2                      inbuf[7]  ='L';
1114   2                      inbuf[8] =0x0d;
1115   2                      inbuf[9] =0x0a;
1116   2                      send_string_com(inbuf,10);
1117   2                      
1118   2                      inbuf[0] ='D';
1119   2                      inbuf[1] ='E';
1120   2                      inbuf[2] ='L';
1121   2                      inbuf[3] ='A';
1122   2                      inbuf[4] ='Y';
1123   2                      inbuf[5]  ='=';
1124   2                      inbuf[6]  =pwm_pulsedelay%10+48;
1125   2                      inbuf[7]  ='L';
1126   2                      inbuf[8] =0x0d;
1127   2                      inbuf[9] =0x0a;
1128   2                      send_string_com(inbuf,10);
1129   2                 }
1130   1               
1131   1      
1132   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
1133   1            else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1134   1                 {
1135   2      
1136   2                    uint ky;
1137   2      //              TEC_Temp();
1138   2                    if (inbuf[1]=='1')
1139   2                    {  ky=(uint)(TEC_Fed_Tempture1);
1140   3                      inbuf[0] ='T';
1141   3                      inbuf[1] ='1';
1142   3                      inbuf[2] ='=';
1143   3                    if (ky<1000)
1144   3                    {
1145   4                      inbuf[3]  =ky/100+48;
1146   4                      inbuf[4]  =(ky/10)%10+48;
1147   4                      inbuf[5]  ='.';
1148   4                      inbuf[6]  =ky%10+48;
1149   4                      inbuf[7] =0x0d;
1150   4                      inbuf[8] =0x0a;
1151   4                      send_string_com(inbuf,9);
1152   4                    }
1153   3                    else
1154   3                     alarm();  
1155   3                    }
1156   2                  else if (inbuf[1]=='2')
1157   2                    { 
1158   3                      ky=(uint)(TEC_Fed_Tempture2);
1159   3                      inbuf[0] ='T';
1160   3                      inbuf[1] ='2';
1161   3                      inbuf[2] ='=';
1162   3                    if (ky<1000)
1163   3                    {
1164   4                      inbuf[3]  =ky/100+48;
1165   4                      inbuf[4]  =(ky/10)%10+48;
1166   4                      inbuf[5]  ='.';
1167   4                      inbuf[6]  =ky%10+48;
1168   4                      inbuf[7] =0x0d;
1169   4                      inbuf[8] =0x0a;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 20  

1170   4                      send_string_com(inbuf,9);
1171   4                    }
1172   3                    else
1173   3                     alarm();
1174   3                 }
1175   2               }
1176   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
1177   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1178   1      
1179   1                 {
1180   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1181   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1182   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1183   2      
1184   2                    inbuf[4]='S';
1185   2                    inbuf[5]='=';
1186   2                    inbuf[6]=inbuf[6]+48;
1187   2                    inbuf[7]='.';
1188   2                    inbuf[8]=inbuf[8]+48;
1189   2                    inbuf[9]=inbuf[9]+48;
1190   2                    inbuf[10]=0x0d;
1191   2                    inbuf[11]=0x0a;
1192   2      
1193   2                    send_string_com(inbuf,12);
1194   2      
1195   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1196   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1197   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1198   2      
1199   2                    inbuf[4]='A';
1200   2                    inbuf[5]='=';
1201   2                    inbuf[6]=inbuf[6]+48;
1202   2                    inbuf[7]='.';
1203   2                    inbuf[8]=inbuf[8]+48;
1204   2                    inbuf[9]=inbuf[9]+48;
1205   2                    inbuf[10]=0x0d;
1206   2                    inbuf[11]=0x0a;
1207   2      
1208   2                    send_string_com(inbuf,12);
1209   2      
1210   2      
1211   2                 }
1212   1      
1213   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1214   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1215   1      
1216   1                 {
1217   2      
1218   2      
1219   2      
1220   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1221   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1222   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1223   2      
1224   2                    inbuf[4]='S';
1225   2                    inbuf[5]='=';
1226   2                    inbuf[6]=inbuf[6]+48;
1227   2                    inbuf[7]='.';
1228   2                    inbuf[8]=inbuf[8]+48;
1229   2                    inbuf[9]=inbuf[9]+48;
1230   2                    inbuf[10]=0x0d;
1231   2                    inbuf[11]=0x0a;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 21  

1232   2      
1233   2                    send_string_com(inbuf,12);
1234   2      
1235   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1236   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1237   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1238   2      
1239   2                    inbuf[4]='A';
1240   2                    inbuf[5]='=';
1241   2                    inbuf[6]=inbuf[6]+48;
1242   2                    inbuf[7]='.';
1243   2                    inbuf[8]=inbuf[8]+48;
1244   2                    inbuf[9]=inbuf[9]+48;
1245   2                    inbuf[10]=0x0d;
1246   2                    inbuf[11]=0x0a;
1247   2      
1248   2                    send_string_com(inbuf,12);
1249   2      
1250   2                 }
1251   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1252   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1253   1      
1254   1                 {
1255   2                    if (TMPGD1)
1256   2                    {
1257   3                      inbuf[4]='S';
1258   3                      inbuf[5]=' ';
1259   3                      inbuf[6]='O';
1260   3                      inbuf[7]='K';
1261   3                      inbuf[8]=0x0d;
1262   3                      inbuf[9]=0x0a;
1263   3                      send_string_com(inbuf,10);
1264   3                    }
1265   2      
1266   2                    else
1267   2                    {
1268   3                      inbuf[4]='S';
1269   3                      inbuf[5]=' ';
1270   3                      inbuf[6]='N';
1271   3                      inbuf[7]='O';
1272   3                      inbuf[8]=0x0d;
1273   3                      inbuf[9]=0x0a;
1274   3                      send_string_com(inbuf,10);
1275   3                    }
1276   2      
1277   2                    if (TMPGD2)
1278   2                    {
1279   3                      inbuf[4]='A';
1280   3                      inbuf[5]=' ';
1281   3                      inbuf[6]='O';
1282   3                      inbuf[7]='K';
1283   3                      inbuf[8]=0x0d;
1284   3                      inbuf[9]=0x0a;
1285   3                      send_string_com(inbuf,10);
1286   3                    }
1287   2      
1288   2                    else
1289   2                    {
1290   3                      inbuf[4]='A';
1291   3                      inbuf[5]=' ';
1292   3                      inbuf[6]='N';
1293   3                      inbuf[7]='O';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 22  

1294   3                      inbuf[8]=0x0d;
1295   3                      inbuf[9]=0x0a;
1296   3                      send_string_com(inbuf,10);
1297   3                    }
1298   2      
1299   2                 }
1300   1      
1301   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1302   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1303   1      
1304   1                 {
1305   2                    if (SHDN1)
1306   2                    {
1307   3                      inbuf[0]='T';
1308   3                      inbuf[1]='E';
1309   3                      inbuf[2]='C';
1310   3                      inbuf[3]='1';
1311   3                      inbuf[4]=' ';
1312   3                      inbuf[5]='O';
1313   3                      inbuf[6]='N';
1314   3                      inbuf[7]=0x0d;
1315   3                      inbuf[8]=0x0a;
1316   3                      send_string_com(inbuf,9);
1317   3                    }
1318   2      
1319   2                    else
1320   2                    {
1321   3                      inbuf[0]='T';
1322   3                      inbuf[1]='E';
1323   3                      inbuf[2]='C';
1324   3                      inbuf[3]='1';
1325   3                      inbuf[4]=' ';
1326   3                      inbuf[5]='O';
1327   3                      inbuf[6]='F';
1328   3                      inbuf[7]='F';
1329   3                      inbuf[8]=0x0d;
1330   3                      inbuf[9]=0x0a;
1331   3                      send_string_com(inbuf,10);
1332   3                    }
1333   2      
1334   2                    if (SHDN2)
1335   2                    {
1336   3                      inbuf[0]='T';
1337   3                      inbuf[1]='E';
1338   3                      inbuf[2]='C';
1339   3                      inbuf[3]='2';
1340   3                      inbuf[4]=' ';
1341   3                      inbuf[5]='O';
1342   3                      inbuf[6]='N';
1343   3                      inbuf[7]=0x0d;
1344   3                      inbuf[8]=0x0a;
1345   3                      send_string_com(inbuf,9);
1346   3                    }
1347   2      
1348   2                    else
1349   2                    {
1350   3                      inbuf[0]='T';
1351   3                      inbuf[1]='E';
1352   3                      inbuf[2]='C';
1353   3                      inbuf[3]='2';
1354   3                      inbuf[4]=' ';
1355   3                      inbuf[5]='O';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 23  

1356   3                      inbuf[6]='F';
1357   3                      inbuf[7]='F';
1358   3                      inbuf[8]=0x0d;
1359   3                      inbuf[9]=0x0a;
1360   3                      send_string_com(inbuf,10);
1361   3                    }
1362   2                 }
1363   1      
1364   1      ///////////////////////////////////////////////////////////////////////////////////
1365   1      
1366   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1367   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1368   1      
1369   1                 {
1370   2                    if (CONT_MOD)
1371   2                    {
1372   3                      inbuf[0]='M';
1373   3                      inbuf[1]='O';
1374   3                      inbuf[2]='D';
1375   3                      inbuf[3]='=';
1376   3                      inbuf[4]='A';
1377   3                      inbuf[5]='P';
1378   3                      inbuf[6]='C';
1379   3                      inbuf[7]=0x0d;
1380   3                      inbuf[8]=0x0a;
1381   3                      send_string_com(inbuf,9);
1382   3                    }
1383   2      
1384   2                    else
1385   2                    {
1386   3                      inbuf[0]='M';
1387   3                      inbuf[1]='O';
1388   3                      inbuf[2]='D';
1389   3                      inbuf[3]='=';
1390   3                      inbuf[4]='A';
1391   3                      inbuf[5]='C';
1392   3                      inbuf[6]='C';
1393   3                      inbuf[7]=0x0d;
1394   3                      inbuf[8]=0x0a;
1395   3                      send_string_com(inbuf,9);
1396   3                    }
1397   2                 }
1398   1      
1399   1      
1400   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1401   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1402   1            {
1403   2                 if(inbuf[6]==0x0d)
1404   2                    {
1405   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1406   3                       setsucced();
1407   3                    }
1408   2                 else
1409   2                    setfault();
1410   2            }
1411   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1412   1      
1413   1            else
1414   1             setfault();                              //设置错误
1415   1      
1416   1      
1417   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 24  

1418   1           return;
1419   1      
1420   1      }
*** WARNING C280 IN LINE 402 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
*** WARNING C280 IN LINE 448 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
1421          /*******************************************************************************/
1422          
1423          
1424          
1425          
1426          
1427          /*****************************设置显示****************************************
1428          void Lcd_disp()
1429          {
1430           wr_lcd (comm,0x30);                    //设定工作方式
1431           delay(1);
1432           wr_lcd (comm,0x01);                    //清屏
1433           delay(1);
1434           wr_lcd (comm,0x0d);                    //开显示
1435           delay(1);
1436           wr_lcd (comm,0x10);
1437           delay(30);
1438          
1439           if(CONT_MOD)                          //CONT_MOD: 1 APC, 0 ACC
1440          
1441          //*****************APC模式显示设定功率*********************************
1442           {
1443             chn_disp (tab13,8,0x80);
1444             delayR(50);
1445             chn_disp (Power_parameter1,6,0x84);
1446           }
1447          
1448          //********************************************************************
1449           else
1450          //****************ACC模式显示电流设定**********************************
1451           {
1452            chn_disp (tab9,8,0x80);
1453            delayR(50);
1454            chn_disp (Diode_parameter1,6,0x84);
1455          
1456           }
1457          //*********************************************************************
1458          
1459           delayR(50);
1460          
1461          //*****************显示设定温度****************************************
1462          
1463           delayR(50);
1464           chn_disp (TEC_parameter1,4,0x94);
1465           delayR(50);
1466           chn_disp (tab11,2,0x96);
1467           delayR(50);
1468          // wr_lcd (comm,0x90);
1469          //********************************************************************
1470          
1471          }
1472          /**************************************************************************
1473          
1474          
1475          /*****************************判断按键电压*********************************
1476          void Key_Button()
1477          {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 25  

1478            uchar kk=10;
1479            uchar tec_a=0;
1480            uchar tec_b=0;
1481            Key_V=0;
1482          
1483          
1484          
1485          
1486            return;
1487          }
1488          
1489          /**************************************************************************/
1490          
1491          /**********************二极管电流监测**************************************/
1492          void Diode_curent_Check()
1493          {
1494   1          uchar k=16;
1495   1      //    float a,b;
1496   1          AD_inbuf[0]=0;
1497   1          AD_inbuf[1]=0;
1498   1          do
1499   1          {
1500   2            AD_code=AD_Convert(0);                  //种子源电流
1501   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
1502   2      
1503   2            AD_code=AD_Convert(3);                  //放大级电流
1504   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
1505   2      
1506   2            k--;
1507   2          }while(k);
1508   1      
1509   1      
1510   1          AD_inbuf[0]=AD_inbuf[0]/16;
1511   1          AD_inbuf[1]=AD_inbuf[1]/16;
1512   1      
1513   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
1514   1          Laser_meds_curent1=Laser_Fed_curent1;
1515   1          if (Laser_Fed_curent1<10)
1516   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
1517   2              Diode_parameter1[1]=0x6d;
1518   2              Diode_parameter1[2]=0x41;
1519   2              Diode_parameter1[3]=0x20;
1520   2              Diode_parameter1[4]=0x20;
1521   2      
1522   2            } else if(Laser_Fed_curent1<100)
1523   1      
1524   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
1525   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
1526   2              Diode_parameter1[2]=0x6d;
1527   2              Diode_parameter1[3]=0x41;
1528   2              Diode_parameter1[4]=0x20;
1529   2            } else if(Laser_Fed_curent1<1000)
1530   1      
1531   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
1532   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
1533   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
1534   2              Diode_parameter1[3]=0x6d;
1535   2              Diode_parameter1[4]=0x41;
1536   2            }
1537   1      
1538   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
1539   1          Laser_meds_curent2=Laser_Fed_curent2;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 26  

1540   1          if (Laser_Fed_curent2<10)
1541   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
1542   2              Diode_parameter2[1]=0x6d;
1543   2              Diode_parameter2[2]=0x41;
1544   2              Diode_parameter2[3]=0x20;
1545   2              Diode_parameter2[4]=0x20;
1546   2      
1547   2            } else if(Laser_Fed_curent2<100)
1548   1      
1549   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
1550   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
1551   2              Diode_parameter2[2]=0x6d;
1552   2              Diode_parameter2[3]=0x41;
1553   2              Diode_parameter2[4]=0x20;
1554   2            } else if(Laser_Fed_curent2<1000)
1555   1      
1556   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
1557   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
1558   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
1559   2              Diode_parameter2[3]=0x6d;
1560   2              Diode_parameter2[4]=0x41;
1561   2            }
1562   1      
1563   1          return;
1564   1      }
1565          /**************************************************************************/
1566          /*****************************激光功率检测*********************************/
1567          void Laser_power_Check()
1568          {
1569   1      
1570   1          uchar k=10;
1571   1          float a,b;
1572   1          AD_inbuf[8]=0;
1573   1          AD_inbuf[9]=0;
1574   1          do
1575   1          {
1576   2            AD_code=AD_Convert(1);                  //种子源
1577   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
1578   2      
1579   2            AD_code=AD_Convert(4);                  //放大级
1580   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
1581   2            k--;
1582   2          }while(k);
1583   1      
1584   1      
1585   1      
1586   1          AD_inbuf[8]=AD_inbuf[8]/10;
1587   1          AD_inbuf[9]=AD_inbuf[9]/10;
1588   1      
1589   1          AD_code=AD_inbuf[8];
1590   1          a=(float)(AD_code);
1591   1          a=a*2.5;
1592   1          a=a/4096+0.02015;
1593   1          b=a*a*117.314+275.543*a-0.806;
1594   1      
1595   1          Laser_Fed_power1=(uint)(b);
1596   1          Laser_meds_power1=Laser_Fed_power1;
1597   1      
1598   1          if (Laser_Fed_power1<10)
1599   1            { Power_parameter1[0]=Laser_Fed_power1+48;
1600   2              Power_parameter1[1]=0x6d;
1601   2              Power_parameter1[2]=0x77;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 27  

1602   2              Power_parameter1[3]=0x20;
1603   2              Power_parameter1[4]=0x20;
1604   2              Power_parameter1[5]=0x20;
1605   2      
1606   2            } else if(Laser_Fed_power1<100)
1607   1      
1608   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
1609   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
1610   2              Power_parameter1[2]=0x6d;
1611   2              Power_parameter1[3]=0x77;
1612   2              Power_parameter1[4]=0x20;
1613   2              Power_parameter1[5]=0x20;
1614   2            } else if(Laser_Fed_power1<1000)
1615   1      
1616   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
1617   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
1618   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
1619   2              Power_parameter1[3]=0x6d;
1620   2              Power_parameter1[4]=0x77;
1621   2              Power_parameter1[5]=0x20;
1622   2            }
1623   1      
1624   1          AD_code=AD_inbuf[9];
1625   1          a=(float)(AD_code);
1626   1          a=a*2.5;
1627   1          a=a/4096+0.02015;
1628   1          b=a*a*117.314+275.543*a-0.806;
1629   1      
1630   1          Laser_Fed_power2=(uint)(b);
1631   1          Laser_meds_power2=Laser_Fed_power2;
1632   1      
1633   1          if (Laser_Fed_power2<10)
1634   1            { Power_parameter2[0]=Laser_Fed_power2+48;
1635   2              Power_parameter2[1]=0x6d;
1636   2              Power_parameter2[2]=0x77;
1637   2              Power_parameter2[3]=0x20;
1638   2              Power_parameter2[4]=0x20;
1639   2              Power_parameter2[5]=0x20;
1640   2      
1641   2            } else if(Laser_Fed_power2<100)
1642   1      
1643   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
1644   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
1645   2              Power_parameter2[2]=0x6d;
1646   2              Power_parameter2[3]=0x77;
1647   2              Power_parameter2[4]=0x20;
1648   2              Power_parameter2[5]=0x20;
1649   2            } else if(Laser_Fed_power2<1000)
1650   1      
1651   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
1652   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
1653   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
1654   2              Power_parameter2[3]=0x6d;
1655   2              Power_parameter2[4]=0x77;
1656   2              Power_parameter2[5]=0x20;
1657   2            }
1658   1      
1659   1          return;
1660   1      
1661   1      
1662   1      
1663   1      }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 28  

1664          /**************************************************************************/
1665          
1666          
1667          /*****************************当前冷却温度*********************************/
1668          void TEC_Temp()
1669          {
1670   1          uint  tx1=0;
1671   1          uint  tx2=0;
1672   1          uchar kt=16;
1673   1          AD_inbuf[6]=0;
1674   1          AD_inbuf[7]=0;
1675   1          do
1676   1          {
1677   2            AD_code=AD_Convert(2);        //种子源TEC温度
1678   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
1679   2      
1680   2            AD_code=AD_Convert(5);        //放大级TEC温度
1681   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
1682   2            kt--;
1683   2          }while(kt);
1684   1      
1685   1           AD_inbuf[6]=AD_inbuf[6]/16;
1686   1           AD_inbuf[7]=AD_inbuf[7]/16;
1687   1           TEC_meds_tempture1=AD_inbuf[6];
1688   1           TEC_meds_tempture2=AD_inbuf[7];
1689   1      
1690   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
1691   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
1692   1           tx1= (uint)(TEC_Fed_Tempture1);
1693   1           TEC_meds_tempture1=tx1;
1694   1           tx2= (uint)(TEC_Fed_Tempture2);
1695   1           TEC_meds_tempture2=tx2;
1696   1      
1697   1           TEC_parameter1[0]=tx1 /100+48;
1698   1           TEC_parameter1[1]=(tx1 /10)%10+48;
1699   1           TEC_parameter1[2]=0x2e;
1700   1           TEC_parameter1[3]=tx1 %10+48;
1701   1      
1702   1      
1703   1           TEC_parameter2[0]=tx2 /100+48;
1704   1           TEC_parameter2[1]=(tx2 /10)%10+48;
1705   1           TEC_parameter2[2]=0x2e;
1706   1           TEC_parameter2[3]=tx2 %10+48;
1707   1      
1708   1      
1709   1        return;
1710   1      }
1711          
1712          /**************************************************************************/
1713          
1714          /*****************************当前TEC两端电压******************************/
1715          void TEC_V_Check()                                                 //???????????????????????
1716          {
1717   1          uchar kk=20;
1718   1          AD_inbuf[4]=0;
1719   1          AD_inbuf[5]=0;
1720   1          do
1721   1          {
1722   2            MCU_ADC(1);
1723   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
1724   2            MCU_ADC(2);
1725   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 29  

1726   2            kk--;
1727   2          }while(kk);
1728   1      
1729   1      
1730   1           TEC_VO1=AD_inbuf[4]/20 ;
1731   1           TEC_VO1=TEC_VO1*5;
1732   1           TEC_VO2=AD_inbuf[4]/20 ;
1733   1           TEC_VO2=TEC_VO2*5;
1734   1      
1735   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
1736   1      //     TEC_parameter[1]=0x2e;
1737   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
1738   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
1739   1      //     TEC_parameter[4]=0xa0;
1740   1      //     TEC_parameter[5]=0x56;
1741   1          return;
1742   1      }
1743          
1744          /**************************************************************************/
1745          
1746          /*****************************监测二极管电压******************************/
1747          void Pdiod_V_Check()
1748          {
1749   1          uchar kk=10;
1750   1          AD_inbuf[2]=0;
1751   1          AD_inbuf[3]=0;
1752   1          do
1753   1          {
1754   2            AD_code=AD_Convert(1);             //种子源激光二极管
1755   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
1756   2      
1757   2            AD_code=AD_Convert(4);             //放大级激光二极管
1758   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
1759   2            kk--;
1760   2          }while(kk);
1761   1      
1762   1           PDiode_V1= AD_inbuf[2]/10;
1763   1           PDiode_V2= AD_inbuf[3]/10;
1764   1           PDiode_V1=(PDiode_V1*5)/2;
1765   1           PDiode_V2=(PDiode_V2*5)/2;
1766   1          return;
1767   1      }
1768          /**************************************************************************/
1769          
1770          
1771          
1772          /*******************************设定温度值*************************************
1773          
1774          void Set_TEC_TEMP(uint tempture)
1775          {
1776               uint kt;
1777          
1778                kt=(uint)((tempture-15)*4096/35);
1779                DA_Convert(1,kt);
1780          
1781          
1782          
1783          
1784             return;
1785          }
1786          
1787          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 30  

1788          /******************************************************************************/
1789          
1790          /*****************************设定功率值**********************************/
1791          void Set_laser_power(uchar Channel,uint power)
1792          {
1793   1        float  u,v;
1794   1        uint   temp_p;
1795   1      
1796   1        if (power<3) power=3;
1797   1        if (power>600) power=600;
1798   1        u=(float)(power);
1799   1        v=(u*u/1000)*3.46;
1800   1        v=6.5068*u+29.61-v;
1801   1        temp_p=(uint)(v);
1802   1      
1803   1      
1804   1        if(Channel==3)                                         //设定种子源功率
1805   1        {
1806   2      
1807   2          if(SHDN1)
1808   2           {
1809   3      
1810   3                DA_Convert(3,temp_p);
1811   3                _Nop();
1812   3                DA_Convert(3,temp_p);
1813   3           }
1814   2      
1815   2           Laser_Set_power1=power;
1816   2         }
1817   1      
1818   1      
1819   1          else if(Channel==0)
1820   1        {
1821   2      
1822   2          if(SHDN2)                                             //设定放大级功率
1823   2           {
1824   3      
1825   3                DA_Convert(0,temp_p);
1826   3                _Nop();
1827   3                DA_Convert(0,temp_p);
1828   3           }
1829   2      
1830   2           Laser_Set_power2=power;
1831   2         }
1832   1      
1833   1         else  _Nop();
1834   1      
1835   1         Laser_power_Check();
1836   1      
1837   1      
1838   1          return;
1839   1      
1840   1      }
1841          
1842          
1843          /*************************************************************************/
1844          
1845          /*****************************设定电流值**********************************/
1846          
1847          void Set_laser_current(uchar Channel,uint current)
1848          {
1849   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 31  

1850   1          uint tmp_c1;
1851   1      
1852   1          if (current<30) current=30;
1853   1          if (current>900) current=900;
1854   1      
1855   1      
1856   1      
1857   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
1858   1      
1859   1      
1860   1      
1861   1      
1862   1      
1863   1          if(Channel==3)
1864   1          {
1865   2             if(SHDN1)
1866   2             {
1867   3      
1868   3                  DA_Convert(3,tmp_c1);
1869   3                  _Nop();
1870   3                  DA_Convert(3,tmp_c1);
1871   3      
1872   3                  Laser_Set_curent1=current;
1873   3             }
1874   2      
1875   2             _Nop();
1876   2          }
1877   1      
1878   1          else if(Channel==0)
1879   1          {
1880   2             if(SHDN2)
1881   2             {
1882   3      
1883   3                  DA_Convert(0,tmp_c1);
1884   3                  _Nop();
1885   3                  DA_Convert(0,tmp_c1);
1886   3      
1887   3                  Laser_Set_curent2=current;
1888   3             }
1889   2      
1890   2             _Nop();
1891   2          }
1892   1      
1893   1      
1894   1      
1895   1      
1896   1      /*
1897   1        if (tmp_c1>tmp_c0)
1898   1          {
1899   1            do
1900   1            {
1901   1      
1902   1              while(!TMPGD)
1903   1              {
1904   1                TEC_Temp();
1905   1                if(tx>280)
1906   1              {
1907   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
1908   1                send_string_com(inbuf1,9);
1909   1                t=0;
1910   1                SHDN=0;
1911   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 32  

1912   1                tmp_c1=246;
1913   1                Laser_Set_curent=30;
1914   1                 do
1915   1               {
1916   1                tmp_c0=tmp_c0-2;
1917   1                DA_Convert(0,tmp_c0);
1918   1                m++;
1919   1      
1920   1                 if(m==240)
1921   1                 {
1922   1                  Diode_curent_Check();
1923   1                  TEC_Temp();
1924   1                  chn_disp (tab6,6,0x80);
1925   1                  delayR(500);
1926   1                  chn_disp (Diode_parameter,6,0x83);
1927   1                  delayR(500);
1928   1                  chn_disp (tab7,4,0x90);
1929   1                  delayR(500);
1930   1                  chn_disp (TEC_parameter,4,0x92);
1931   1                  delayR(100);
1932   1                  chn_disp (tab11,2,0x94);
1933   1                  m=0;
1934   1                 }
1935   1                 delayR(10000);
1936   1                 }while(tmp_c0-tmp_c1);
1937   1                 chn_disp (inbuf1,7,0x96);
1938   1                 goto quit;
1939   1               }
1940   1              }
1941   1      
1942   1      
1943   1              
1944   1      
1945   1      
1946   1           if(m==160)
1947   1          {
1948   1           TEC_Temp();
1949   1           Diode_curent_Check();
1950   1           chn_disp (tab6,6,0x80);
1951   1           delayR(500);
1952   1           chn_disp (Diode_parameter,6,0x83);
1953   1           delayR(500);
1954   1           chn_disp (tab7,4,0x90);
1955   1           delayR(500);
1956   1           chn_disp (TEC_parameter,4,0x92);
1957   1           delayR(100);
1958   1           chn_disp (tab11,2,0x94);
1959   1           m=0;
1960   1          }
1961   1      
1962   1      
1963   1      
1964   1      
1965   1      
1966   1      
1967   1      
1968   1             delayR(10000);
1969   1            }while((tmp_c1-tmp_c0)&& SHDN);
1970   1      
1971   1             delayR(180);
1972   1      
1973   1          }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 33  

1974   1        else if(tmp_c1<tmp_c0)
1975   1      
1976   1          {
1977   1             do
1978   1            {
1979   1              
1980   1           if(m==160)
1981   1           {
1982   1           Diode_curent_Check();
1983   1           TEC_Temp();
1984   1           chn_disp (tab6,6,0x80);
1985   1           delayR(500);
1986   1           chn_disp (Diode_parameter,6,0x83);
1987   1           delayR(500);
1988   1           chn_disp (tab7,4,0x90);
1989   1           delayR(500);
1990   1           chn_disp (TEC_parameter,4,0x92);
1991   1           delayR(100);
1992   1           chn_disp (tab11,2,0x94);
1993   1           m=0;
1994   1           }
1995   1           delayR(10000);
1996   1            }while(tmp_c0-tmp_c1);
1997   1      
1998   1           delay(100);
1999   1      
2000   1          }        */
2001   1          Diode_curent_Check();
2002   1      
2003   1      
2004   1          return;
2005   1      
2006   1      }
2007          
2008          /***************************************************************************/
2009          
2010          /*****************************外部AD转换程序*******************************/
2011          uint AD_Convert(uchar Channel)
2012          {
2013   1         uchar i,Dath,Datl,temp,Contbit;
2014   1         uint Dat_ad;
2015   1         Dath=0;
2016   1         Datl=0;
2017   1         temp=0;
2018   1         Dat_ad=0;
2019   1         switch (Channel)                        //  内部REF
2020   1          {
2021   2              case 0:Contbit=0x00;break;
2022   2              case 1:Contbit=0x08;break;
2023   2              case 2:Contbit=0x10;break;
2024   2              case 3:Contbit=0x18;break;
2025   2              case 4:Contbit=0x20;break;
2026   2              case 5:Contbit=0x28;break;
2027   2              case 6:Contbit=0x30;break;
2028   2              case 7:Contbit=0x38;break;
2029   2              default: break;
2030   2          }
2031   1      
2032   1          CSAD=0;
2033   1          _Nop();
2034   1          DCLK=1;
2035   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 34  

2036   1         for(i=0;i<8;i++)
2037   1         {
2038   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
2039   2      
2040   2            DCLK=0;
2041   2            _Nop();
2042   2            DCLK=1;
2043   2            _Nop();
2044   2      
2045   2         }
2046   1      
2047   1          CSAD=1;
2048   1          _Nop();
2049   1      
2050   1          CSAD=0;
2051   1          _Nop();
2052   1      
2053   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
2054   1          {
2055   2            ADIN=(bit)(Contbit&(0x80>>i));
2056   2      
2057   2            DCLK=0;
2058   2            _Nop();
2059   2            DCLK=1;
2060   2            _Nop();
2061   2            Dath=DOUT;
2062   2            Dath=Dath<<(7-i);
2063   2            temp=temp|Dath;
2064   2          }
2065   1      
2066   1           Dath=temp;
2067   1           temp=0;
2068   1          for(i=0;i<8;i++)
2069   1          {
2070   2            DCLK=0;
2071   2            _Nop();
2072   2            DCLK=1;
2073   2            Datl=DOUT;
2074   2            Datl=Datl<<(7-i);
2075   2            temp=temp|Datl;
2076   2            _Nop();
2077   2      
2078   2          }
2079   1      
2080   1           Datl=temp;
2081   1           Dat_ad=(Dath*256+Datl)&0x0fff;
2082   1      
2083   1           CSAD=1;
2084   1      
2085   1      
2086   1      
2087   1            _Nop();
2088   1      
2089   1            return(Dat_ad);
2090   1      }
2091          
2092          
2093          
2094          /**************************************************************************/
2095          /*****************************外部PWM设置程序*******************************/
2096          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
2097          { 
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 35  

2098   1        uchar pulserate,pulsewidth,pulsedelay;
2099   1      
2100   1        if (pwm_pulserate>0)
2101   1        {
2102   2          pulserate=1000000/pwm_pulserate/12.5/32;             //80M晶振
2103   2          if(pulserate>255)
2104   2            pulserate=255;
2105   2          P0=pulserate;
2106   2          RW=1;
2107   2      
2108   2          RS=0;
2109   2          delayR(10);
2110   2          ENAB=1;
2111   2          delayR(10);
2112   2          ENAB=0;
2113   2          delayR(10);
2114   2          RW=0;
2115   2          RS=0;
2116   2        }
2117   1        
2118   1        if (pwm_pulsewidth>0)
2119   1        {
2120   2          pulsewidth=pwm_pulsewidth   ;      //80M晶振
2121   2          if (pulsewidth>7)
2122   2            pulsewidth=7;
2123   2          P0=pulsewidth;
2124   2          RW=0;
2125   2          RS=1;
2126   2          delayR(10);
2127   2          ENAB=1;
2128   2          delayR(10);
2129   2          ENAB=0;
2130   2          delayR(10);
2131   2          RW=0;
2132   2          RS=0;
2133   2        }
2134   1        
2135   1        if (pwm_pulsedelay>0)
2136   1        {
2137   2          pulsedelay= pwm_pulsedelay ;                 //80M晶振
2138   2          if (pulsedelay>7)
2139   2            pulsedelay=7;
2140   2          P0=pulsedelay;
2141   2          RW=1;
2142   2          RS=1;
2143   2          delayR(10);
2144   2          ENAB=1;
2145   2          delayR(10);
2146   2          ENAB=0;
2147   2          delayR(10);
2148   2          RW=0;
2149   2          RS=0;
2150   2          
2151   2      
2152   2      
2153   2        }
2154   1      
2155   1      
2156   1      
2157   1      }
2158          /**************************************************************************/
2159          /*****************************外部DA转换程序*******************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 36  

2160          void DA_Convert(uchar Channel, uint Dcode)
2161          {
2162   1      
2163   1        uint  Comdat=0;
2164   1         uchar i;
2165   1         switch (Channel)
2166   1          {
2167   2              case 0:Comdat=Dcode+0x1000;break;
2168   2              case 1:Comdat=Dcode+0x5000;break;
2169   2              case 2:Comdat=Dcode+0x9000;break;
2170   2              case 3:Comdat=Dcode+0xd000;break;
2171   2              default: break;
2172   2          }
2173   1      
2174   1          LDAC=1;                               //数据刷新
2175   1          _Nop();
2176   1          CSDA=0;                               //片选有效
2177   1          FS=1;
2178   1          _Nop();
2179   1          FS=0;
2180   1         for(i=0;i<16;i++)
2181   1        {
2182   2             DINDA=(bit)(Comdat&0x8000);
2183   2             SCLK=1;
2184   2             Comdat=Comdat<<1;
2185   2             _Nop();
2186   2             SCLK=0;
2187   2      
2188   2         }
2189   1      
2190   1         LDAC=0;
2191   1         _Nop();
2192   1         CSDA=1;                             //片选无效
2193   1         Dcode=0;
2194   1        return;
2195   1      
2196   1      }
2197          /**************************************************************************/
2198          
2199          
2200          /*****************************单片机内部AD********************************/
2201           void MCU_ADC(BYTE CHN)
2202           {
2203   1          BYTE    AD_finished;
2204   1          switch (CHN)
2205   1          {
2206   2              case 0: P1ASF=0x01;break;
2207   2              case 1: P1ASF=0x02;break;
2208   2              case 2:P1ASF=0x04;break;
2209   2              case 3:P1ASF=0x08;break;
2210   2              case 7:P1ASF=0x80;break;
2211   2      
2212   2              default: break;
2213   2          }
2214   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
2215   1          ADC_RES=0;
2216   1          ADC_RESL=0;
2217   1      
2218   1          CHN &= 0x07;                        //0000,0111 清0高5位
2219   1      
2220   1          ADC_CONTR =ADC_SPEEDH ;
2221   1          _nop_();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 37  

2222   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
2223   1          _nop_();
2224   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
2225   1          delayR(10);
2226   1          ADC_CONTR |= 0x08;
2227   1          delayR(10);
2228   1          AD_finished = 0;
2229   1          while (AD_finished ==0 )            //等待A/D转换结束
2230   1          {
2231   2            AD_finished = (ADC_CONTR & 0x10);
2232   2          }
2233   1          ADC_CONTR &= 0xE7;
2234   1      
2235   1          P1ASF=0x00;
2236   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
2237   1      
2238   1          return;
2239   1       }
2240          
2241          /*************************************************************************/
2242          
2243          
2244          
2245          void Error_Process()
2246          {
2247   1      
2248   1       _Nop();
2249   1       return;
2250   1      
2251   1      }
2252          
2253          
2254          
2255          /*********以下是长延时程序***********************************************/
2256          
2257          void delay(uint delay_k)
2258          {
2259   1          uint k0=0;
2260   1          do
2261   1          {
2262   2          do{k0--;}while(k0);
2263   2          delay_k--;
2264   2          }while(delay_k);
2265   1      
2266   1      }
2267          
2268          /*********以下是短延时程序***********************************************/
2269          void delayR(uint delay_k)
2270          {
2271   1          do{delay_k--;}while(delay_k);
2272   1      
2273   1      
2274   1      }
2275          
2276          /*********************************************************************/
2277          
2278          /**************************以下是外部中断0程序************************/
2279           void INT_0() interrupt 0 using 0
2280           {
2281   1          if (!LIM1)
2282   1          Error_Process();
2283   1          else  _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 38  

2284   1      
2285   1          if (!LIM2)
2286   1          Error_Process();
2287   1          else  _Nop();
2288   1          return;
2289   1       }
2290          /*********************************************************************/
2291          
2292          /***************************以下是外部中断1程序***********************/
2293          void INT_1() interrupt 2 using 1
2294          {
2295   1        _Nop();
2296   1        //chn_disp (tab16,20,0x80);
2297   1        //delayR(10000);
2298   1        //chn_disp (tab17,20,0x90);
2299   1        //delay(1000);
2300   1      }
2301          /***********************************************************************/
2302          
2303          
2304          
2305          
2306          
2307          /*****************以下是串口中断程序*******************************/
2308          
2309          void RS232() interrupt 4 using 3
2310          {
2311   1      
2312   1         if(RI)
2313   1         {
2314   2              RI=0;
2315   2      
2316   2              if (SBUF==0x0A)
2317   2              {
2318   3                   read_flag=1;
2319   3      
2320   3                }
2321   2      
2322   2              else
2323   2              {
2324   3      
2325   3      
2326   3                   inbuf[t]=SBUF;
2327   3                   t++;
2328   3      
2329   3      
2330   3      
2331   3              }
2332   2      
2333   2         }
2334   1      
2335   1           return;
2336   1      }
2337          
2338          /**********************************************************************/
2339          
2340          /*****************定时器中断程序*******************************/
2341          
2342          void tm0_isr() interrupt 1 using 1
2343          {               
2344   1           TL0 = 0x30;   //设置定时初值
2345   1           TH0 = 0xF8;   //设置定时初值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 39  

2346   1           if (count-- == 0)               //1ms * 1000 -> 1s
2347   1           {
2348   2           count = 1000;               //reset counter
2349   2           }
2350   1      }
2351          
2352          /*************************设置错误***************************/
2353          void setfault()
2354          {
2355   1      
2356   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
2357   1      
2358   1        send_string_com(inbuf1,10);
2359   1      
2360   1        t=0;
2361   1      }
2362          /*************************************************************/
2363          
2364          
2365          /*************************设置成功***************************/
2366          void setsucced()
2367          {
2368   1      
2369   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
2370   1      
2371   1        send_string_com(inbuf1,11);
2372   1        t=0;
2373   1        return;
2374   1      }
2375          /*************************************************************/
2376          
2377          
2378          
2379          
2380          
2381          
2382          /********************************警告*************************/
2383          void alarm()
2384          {
2385   1         uchar t=6;
2386   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
2387   1      
2388   1         send_string_com(inbuf1,7);
2389   1        do
2390   1        {
2391   2         delay(50);
2392   2         t--;
2393   2        }while(t);
2394   1         send_string_com(inbuf1,5);
2395   1         t=6;
2396   1         do
2397   1        {
2398   2         delay(50);
2399   2         t--;
2400   2        }while(t);
2401   1         send_string_com(inbuf1,5);
2402   1      
2403   1      }
2404          /*************************************************************/
2405          
2406          
2407          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 40  

2408          /************************主程序*******************************/
2409          void main()
2410          {
2411   1         uchar  i=10;
2412   1         uchar  tmp0=0;
2413   1      // setsucced();
2414   1      // delay(5000);
2415   1      // setsucced();
2416   1      // delay(5000);
2417   1      // setsucced();
2418   1         stat_initial();                               //状态初始划
2419   1         serial_initial();                             //串口初始化
2420   1      // delay(20000);
2421   1      // setsucced();
2422   1      // delay(5000);
2423   1      // setsucced();
2424   1      // delay(5000);
2425   1      // setsucced();
2426   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2427   1      
2428   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2429   1       {
2430   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2431   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2432   2      
2433   2        DA_Convert(3,25);                          // 种子源
2434   2         _Nop();
2435   2        DA_Convert(3,25);
2436   2      
2437   2        DA_Convert(0,25);                          // 放大级
2438   2         _Nop();
2439   2        DA_Convert(0,25);
2440   2       }
2441   1      //////////////////////////////////////////////////////////////////////////////////////////////
2442   1      
2443   1        else
2444   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2445   1       {
2446   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2447   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
2448   2      
2449   2        DA_Convert(3,88);                            // 种子源
2450   2         _Nop();
2451   2        DA_Convert(3,88);
2452   2      
2453   2        DA_Convert(0,88);                            // 放大级
2454   2        _Nop();
2455   2        DA_Convert(0,88);
2456   2       }
2457   1      //////////////////////////////////////////////////////////////////////////////////////////////
2458   1      ///////////////////////////////////上电开始显示//////////////////////////////////////////////tang
2459   1       /*  init_lcd ();
2460   1         delay(5);
2461   1         wr_lcd (comm,0x30);
2462   1         delay(30);                                    //需要足够的等待延时
2463   1         chn_disp (tab1,14,0x80);
2464   1         delay(5);
2465   1         chn_disp (tab2,20,0x90);
2466   1         delay(5);
2467   1         clrram();
2468   1         delay(5);
2469   1         chn_disp (tab3,10,0x80);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 41  

2470   1         chn_disp (tab4,12,0x90);
2471   1      
2472   1         clrram();
2473   1         delay(10);
2474   1         chn_disp (tab5,10,0x80);
2475   1         delay(5);
2476   1      */////////////////////////////////////////////////////////////////////////////////////////////
2477   1      
2478   1      
2479   1      
2480   1        do
2481   1         {
2482   2      
2483   2           delay(1);
2484   2      
2485   2           if(read_flag)
2486   2            {
2487   3              command();                        //指令识别
2488   3              read_flag=0;                      //取数标志清0
2489   3              t=0;
2490   3            }
2491   2      
2492   2           _Nop();
2493   2      
2494   2      
2495   2          if(Sys_mod)
2496   2       {
2497   3      
2498   3      
2499   3      /***************************检查按键**************************************/
2500   3      
2501   3       // Key_Button();  tang
2502   3      
2503   3      
2504   3      ///////////////////////////////////////////////////////////////////////////
2505   3      
2506   3      /***************************检查当前实际功率值****************************/
2507   3       //Laser_power_Check(); tang
2508   3      
2509   3      
2510   3      /*************************************************************************/
2511   3      /***************************检测当前实际电流值****************************/
2512   3      
2513   3       Diode_curent_Check();
2514   3      
2515   3      
2516   3      
2517   3      
2518   3      ///////////////////////////////////////////////////////////////////////////
2519   3      
2520   3      
2521   3      /***************************检测当前冷却温度******************************/
2522   3         TEC_Temp();
2523   3      
2524   3      
2525   3      
2526   3         if(TEC_meds_tempture1>350)
2527   3      
2528   3         {
2529   4      
2530   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2531   4           if(CONT_MOD)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 42  

2532   4           {
2533   5           Set_laser_power(0,3);       //tang
2534   5           Set_laser_power(3,3);
2535   5           }
2536   4           else
2537   4           {
2538   5           Set_laser_current(0,30);
2539   5           Set_laser_current(3,30);
2540   5           }
2541   4           SHDN1=0;
2542   4           SHDN2=0;
2543   4           send_string_com(inbuf1,9);
2544   4           t=0;
2545   4           }
2546   3      
2547   3         if(TEC_meds_tempture2>350)
2548   3      
2549   3         {
2550   4      
2551   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2552   4           if(CONT_MOD)
2553   4           {
2554   5           Set_laser_power(0,3);       //tang
2555   5           Set_laser_power(3,3);
2556   5           }
2557   4           else
2558   4           {
2559   5           Set_laser_current(0,30);
2560   5           Set_laser_current(3,30);
2561   5           }
2562   4           SHDN1=0;
2563   4           
2564   4           SHDN2=0;
2565   4           send_string_com(inbuf1,9);
2566   4           t=0;
2567   4         }
2568   3      //////////////////////////////////////////////////////////////////////////
2569   3      
2570   3      
2571   3      /***************************检测监测二极管反馈电压************************/
2572   3      
2573   3       Pdiod_V_Check();
2574   3      
2575   3      
2576   3      
2577   3      //////////////////////////////////////////////////////////////////////////
2578   3      
2579   3      
2580   3      /***************************检测TEC温控是否完成**************************/
2581   3      
2582   3      
2583   3      
2584   3      
2585   3      
2586   3      /////////////////////////////////////////////////////////////////////////
2587   3      
2588   3      
2589   3      /***************************检测TEC两端电压是否正常*********************/
2590   3      
2591   3        TEC_V_Check();
2592   3      
2593   3        if( TEC_VO1>3.1) Error_Process();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 43  

2594   3        if( TEC_VO2>3.1) Error_Process();
2595   3      
2596   3      ////////////////////////////////////////////////////////////////////////
2597   3      
2598   3      
2599   3      /****************************LCD显示***********************************
2600   3      
2601   3      
2602   3           chn_disp (tab6,4,0x80);
2603   3           delayR(50);
2604   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2605   3           delayR(50);
2606   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2607   3      
2608   3      
2609   3           chn_disp (tab7,4,0x90);
2610   3           delayR(50);
2611   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2612   3           delayR(50);
2613   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2614   3      
2615   3      
2616   3      
2617   3      
2618   3      
2619   3           if(CONT_MOD)
2620   3           {
2621   3              chn_disp (tab14,6,0x87);
2622   3              delayR(50);
2623   3              chn_disp (tab14,6,0x97);
2624   3            }
2625   3           else
2626   3           {
2627   3              chn_disp (tab15,6,0x87);
2628   3              delayR(50);
2629   3              chn_disp (tab15,6,0x97);
2630   3           }
2631   3      
2632   3      //////////////////////////////////////////////////////////////////////*/
2633   3      }
2634   2      
2635   2      else
2636   2      {
2637   3          // chn_disp (tab16,20,0x80);
2638   3         // delayR(10000);
2639   3          // chn_disp (tab17,20,0x90);
2640   3      }
2641   2      
2642   2          }while(1);
2643   1      
2644   1      
2645   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8774    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46      92
   IDATA SIZE       =    114    ----
   BIT SIZE         =      3    ----
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/03/2014 10:24:27 PAGE 44  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

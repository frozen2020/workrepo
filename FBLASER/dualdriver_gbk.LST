C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER_GBK
OBJECT MODULE PLACED IN dualdriver_gbk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver_gbk.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          uint  count=1000;
  23          //uchar code tab1[]={"光纤激光控制器"};
  24          //uchar code tab2[]={"苏州德龙激光有限公司"};
  25          //uchar code tab3[]={"正在初始化"};
  26          //uchar code tab4[]={"请稍候......"};
  27          //uchar code tab5[]={"初始化完成"};
  28          //uchar code tab6[]={"SED:"};
  29          //uchar code tab7[]={"AMP:"};
  30          //uchar code tab8[]={"VOTEC:1.42v"};
  31          //uchar code tab9[]={"设定电流"};
  32          //uchar code tab10[]={"设定温度"};
  33          //uchar code tab11[]={"℃"};
  34          //uchar code tab12[]={"POW:"};
  35          //uchar code tab13[]={"设定功率"};
  36          //uchar code tab14[]={"℃ APC"};
  37          //uchar code tab15[]={"℃ ACC"};
  38          //uchar code tab16[]={"系统采集控制模式中  "};
  39          //uchar code tab17[]={"...................."};
  40          uchar idata  TEC_parameter1[6];
  41          uchar idata  TEC_parameter2[6];
  42          uchar idata  Diode_parameter1[6];
  43          uchar idata  Diode_parameter2[6];
  44          uchar idata  Power_parameter1[6];
  45          uchar idata  Power_parameter2[6];
  46          uchar  set_flag;
  47          
  48          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  49          
  50          uint   idata MCU_AD_code;
  51          uint   idata AD_code;
  52          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  53          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  54          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
  55          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 2   

  56          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  57          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  58          uint   init_current1;                       //种子源初始电流
  59          uint   init_current2;                       //放大级初始电流
  60          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅种子源 3：双路
  61          
  62          uint   idata Laser_Set_power1;             //设定种子源激光功率
  63          uint   idata Laser_Set_power2;             //设定放大级激光功率
  64          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  65          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  66          uint   idata Laser_meds_power1;            //种子源中间设定功率
  67          uint   idata Laser_meds_power2;            //放大级中间设定功率
  68          
  69          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  70          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  71          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  72          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  73          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  74          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  75          
  76          uint   idata Key_V;                         //按键电压
  77          
  78          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  79          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  80          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  81          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  82          
  83          
  84          
  85          uchar  t=0;                                 // 缓冲区数据段
  86          
  87          bit  read_flag=0;                           // 读取标志位
  88          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  89          
  90          
  91          //////////////////////////输入控制位/////////////////////////////////////////////////////
  92          
  93          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  94          
  95          
  96          
  97          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
  98          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
  99          sbit DOUT=P1^6;                      //AD串行输出
 100          
 101          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 102          
 103          //////////////////////////输出控制位/////////////////////////////////////////////////////
 104          sbit LDAC=P2^2;                      //DA装载信号
 105          sbit CSDA=P4^0;                      //DA选通信号
 106          sbit DINDA=P2^1;                     //DA串行数据输入
 107          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 108          sbit SCLK=P2^0;                      //DA时钟输入
 109          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 110          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 111          
 112          sbit FS=P3^7;                        //DA帧信号
 113          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 114          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 115          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
 116          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 117          sbit LIM2=P2^5;                      //激光二极管过流中断信号
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 3   

 118          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 119          sbit DCLK=P1^7;                      //AD时钟信号
 120          sbit ADIN=P1^5;                      //AD串行数据输入
 121          sbit CSAD=P2^4;                      //AD选通信号，L－选通 
 122          
 123          uint AD_Convert(uchar Channel);      //AD转换
 124          void DA_Convert(uchar Channel, uint Dcode);      //DA转换
 125          //void Set_TEC_TEMP(uint tempture);              //设定冷却温度
 126          void Set_laser_current(uchar Channel,uint current);    //设定激光二极管电流
 127          void Set_laser_power(uchar Channel,uint power);        //设定激光功率
 128          void MCU_ADC(BYTE CHN);                      //单片机内部AD转换
 129          //void Key_Button();                           //按键判别
 130          void TEC_V_Check();                          //TEC两端电压
 131          void Diode_curent_Check();                   //激光二极管电流检测
 132          void Laser_power_Check();                    //激光功率检测
 133          void Pdiod_V_Check();                        //激光二极管监测电压
 134          void TEC_Temp();                             //TEC温度
 135          void Error_Process();                        //异常处理
 136          void wr_lcd (uchar dat_comm,uchar content);
 137          //void Lcd_disp();
 138          void Pwm_Set(uint,uint,uint);
 139          void Sdio_check();                     // 加电流时状态检查
 140          
 141          void serial_initial();                 // 串口初始化
 142          void stat_initial();                   // 状态初始化
 143          void INT_0();                          // 外部中断0
 144          void delay(uint);                      // 长延时
 145          void delayR(uint);                     // 短延时
 146          void RS232();                          // 串口中断
 147          
 148          
 149          
 150          void command();                        // 指令判断
 151          void setfault();                       // 设置错误
 152          void setsucced();                      // 设置成功
 153          void alarm();                          // 警告
 154          
 155          
 156          
 157          /***************向串口发送一个字符串*****************/
 158          void send_string_com(uchar *str,uchar strlen)
 159          {
 160   1          uchar k=0;
 161   1          do
 162   1          {
 163   2              SBUF=*(str + k);
 164   2              while(TI==0);
 165   2              TI=0;
 166   2              k++;
 167   2          } while(k < strlen);
 168   1      }
 169          /************************************************************************/
 170          
 171          
 172          
 173          
 174          /***********以下是串口初始化程序********************************************/
 175          void serial_initial()
 176          {
 177   1      
 178   1      
 179   1            PCON |= 0x80;             //使能波特率倍速位SMOD
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 4   

 180   1            SCON = 0x50;              //8位数据,可变波特率
 181   1            BRT = 0x64;               //设定独立波特率发生器重装值
 182   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 183   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 184   1            AUXR |= 0x10;             //启动独立波特率发生器
 185   1      
 186   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 187   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 188   1      
 189   1            IPH=0x14;
 190   1            IP=0x24;
 191   1            ES=1;
 192   1            ET0=1;
 193   1            IT0=1;
 194   1            EX0=1;
 195   1            IT1=1;
 196   1            EX1=1;
 197   1            EA=1;
 198   1            TL0 = 0x30;   //设置定时初值
 199   1            TH0 = 0xF8;   //设置定时初值
 200   1            TF0 = 0;    //清除TF0标志
 201   1            TR0 = 0;    //定时器0开始计时
 202   1      
 203   1            return;
 204   1      }
 205          
 206          /**********************************************************************/
 207          
 208          
 209          
 210          
 211          /***********以下是状态初始化程序*********************************/
 212          void stat_initial()
 213          {
 214   1      
 215   1           ADC_RES=0;
 216   1           ADC_RESL=0;
 217   1      
 218   1           read_flag=0;          //读取标志清零
 219   1           las_di_ok=0;
 220   1           t=0;
 221   1           set_flag=0;
 222   1           Sys_mod=1;
 223   1      
 224   1           AD_code=0;
 225   1      //     Laser_Set_curent=0;
 226   1           Laser_Fed_curent1=0;
 227   1           Laser_Fed_curent2=0;
 228   1           Laser_Fed_power1=0;
 229   1           Laser_Fed_power2=0;
 230   1      
 231   1      /**************DA引脚初始化*************************/
 232   1           CSDA=1;
 233   1           LDAC=1;
 234   1           FS=0;
 235   1           SCLK=0;
 236   1           DINDA=0;
 237   1      /**************************************************/
 238   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
 239   1           _Nop();
 240   1           DA_Convert(2,1273);
 241   1           _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 5   

 242   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
 243   1           _Nop();
 244   1           DA_Convert(1,1273);
 245   1      /**************************************************/
 246   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
 247   1      
 248   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
 249   1       {
 250   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
 251   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
 252   2      
 253   2        DA_Convert(3,25);                          // 种子源
 254   2         _Nop();
 255   2        DA_Convert(3,25);
 256   2      
 257   2        DA_Convert(0,25);                          // 放大级
 258   2         _Nop();
 259   2        DA_Convert(0,25);
 260   2       }
 261   1      //////////////////////////////////////////////////////////////////////////////////////////////
 262   1      
 263   1        else
 264   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
 265   1       {
 266   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
 267   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
 268   2      
 269   2        DA_Convert(3,92);                            // 种子源
 270   2         _Nop();
 271   2        DA_Convert(3,92);
 272   2      
 273   2        DA_Convert(0,89);                            // 放大级
 274   2        _Nop();
 275   2        DA_Convert(0,89);
 276   2       }
 277   1      //////////////////////////////////////////////////////////////////////////////////////////////
 278   1      
 279   1      
 280   1      
 281   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
 282   1           P1M1=0x07;
 283   1           P1M0=0x00;
 284   1      
 285   1           CSAD=1;
 286   1           DCLK=1;
 287   1           DOUT=1;
 288   1      
 289   1      
 290   1      
 291   1      
 292   1      
 293   1      /*************TEC控制器初始化*********************/
 294   1           SHDN1=1;
 295   1      //   TMPGD1=1;
 296   1           LIM1=1;
 297   1      
 298   1           SHDN2=1;
 299   1      //   TMPGD2=1;
 300   1           LIM2=1;
 301   1      /*************************************************/
 302   1      
 303   1      /*    Power_parameter[0]='P';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 6   

 304   1            Power_parameter[1]='O';
 305   1            Power_parameter[2]='W';
 306   1            Power_parameter[3]=':';
 307   1      
 308   1            Diode_parameter[0]='L';
 309   1            Diode_parameter[1]='D';
 310   1            Diode_parameter[2]='C';
 311   1            Diode_parameter[3]=':';
 312   1            Diode_parameter[8]=0x20;
 313   1            Diode_parameter[9]=0x20;
 314   1      
 315   1            TEC_parameter[0]='T';
 316   1            TEC_parameter[1]='E';
 317   1            TEC_parameter[2]='C';
 318   1            TEC_parameter[3]=':';
 319   1      */
 320   1      
 321   1           TR0=0;
 322   1           ET0=0;
 323   1           TR1=0;
 324   1           ET1=0;
 325   1           EX0=0;
 326   1      
 327   1           return;
 328   1      }
 329          
 330          /***************************************************************/
 331          
 332          
 333          
 334          /****************************操作指令执行***********************/
 335          void command()
 336          {
 337   1      
 338   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
 339   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
 340   1              {
 341   2                 stat_initial();
 342   2                 serial_initial();
 343   2                 setsucced();
 344   2              }
 345   1      
 346   1      ///////////////////////////////////设定电流////////////////////////////////////////////
 347   1             else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='='))
 348   1      
 349   1                 {
 350   2                     uint dio_cu;
 351   2                     uchar CH;
 352   2      
 353   2                     if(inbuf[5]==0x0d)                                        //格式为LD1(2)=N
 354   2                    {
 355   3                       dio_cu=inbuf[4]-48;
 356   3      
 357   3      
 358   3                    }
 359   2                     else if(inbuf[6]==0x0d)                                   //格式为LD1(2)=NN
 360   2                    {
 361   3                       dio_cu=(uint)((inbuf[4]-48)*10+(inbuf[5]-48));
 362   3      
 363   3                    }
 364   2                    else if(inbuf[7]==0x0d)                                    //格式为LD1(2)=NNN
 365   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 7   

 366   3                       dio_cu=(uint)((inbuf[4]-48)*100+(inbuf[5]-48)*10+(inbuf[6]-48));
 367   3      
 368   3                    }
 369   2      
 370   2                    else                                                    //格式为LD1(2)=NNNN
 371   2                    {
 372   3                        setfault();
 373   3                        goto setcf;
 374   3                    }
 375   2      
 376   2                    if(inbuf[2]=='1')
 377   2                    {
 378   3                      CH=3;                                     //种子源SEED
 379   3                      Set_laser_current(CH,dio_cu);
 380   3                      setsucced();
 381   3                    }
 382   2                    else if(inbuf[2]=='2')
 383   2                    {
 384   3                      CH=0;                                    //放大级AMP
 385   3                      Set_laser_current(CH,dio_cu);
 386   3                      setsucced();
 387   3                    }
 388   2                    else setfault();
 389   2      
 390   2      setcf:       _Nop();
 391   2      
 392   2                 }
 393   1      
 394   1      
 395   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
 396   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
 397   1      
 398   1                 {
 399   2                     uint init_current;
 400   2      //               uchar CH;
 401   2      
 402   2                     if(inbuf[7]==0x0d)                                        //格式为INIC=N
 403   2                    {
 404   3                       init_current=inbuf[6]-48;
 405   3      
 406   3      
 407   3                    }
 408   2                     else if(inbuf[8]==0x0d)                                   //格式为INIC=NN
 409   2                    {
 410   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 411   3      
 412   3                    }
 413   2                    else if(inbuf[9]==0x0d)                                    //格式为INIC=NNN
 414   2                    {
 415   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 416   3      
 417   3                    }
 418   2      
 419   2                    else                                                    //格式为INIC=NNNN
 420   2                    {
 421   3                        setfault();
 422   3                        goto seticf;
 423   3                    }
 424   2      
 425   2                    if(inbuf[5]=='S')
 426   2                    {
 427   3                      init_current1=init_current;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 8   

 428   3                    }
 429   2                    else if(inbuf[5]=='A')
 430   2                    {
 431   3                      init_current2=init_current;
 432   3                    }
 433   2                    else setfault();
 434   2      
 435   2      seticf:       _Nop();
 436   2      
 437   2                 }
 438   1      
 439   1      
 440   1      
 441   1      ///////////////////////////////////设定初始化模式 0/1/2/3 ////////////////////////////////////////////
 442   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
 443   1      
 444   1                 {   
 445   2                     uint init_flag_temp;
 446   2                  //   uchar CH;
 447   2      
 448   2                     if(inbuf[6]==0x0d)                                        
 449   2                    {
 450   3                       init_flag_temp=inbuf[5]-48;
 451   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
 452   3                        goto setief;
 453   3                      else
 454   3                        init_flag=init_flag_temp;
 455   3                    }
 456   2                    else                                                    
 457   2                    {
 458   3                        setfault();
 459   3                        goto setief;
 460   3                    }
 461   2      
 462   2      setief:       _Nop();
 463   2      
 464   2                 }
 465   1      
 466   1      
 467   1       //////////////////////////////设定功率//////////////////////////////////////////////////
 468   1              else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 469   1                  {
 470   2                     uint las_pow;
 471   2                     uchar CHH;
 472   2                     if(inbuf[4]==0x0d)                                        //格式为P1(2)=N
 473   2                    {
 474   3                       las_pow=(uint)(inbuf[3]-48);
 475   3      
 476   3                    }
 477   2                     else if(inbuf[5]==0x0d)                                   //格式为P1(2)=NN
 478   2                    {
 479   3                       las_pow=(uint)((inbuf[3]-48)*10+(inbuf[4]-48));
 480   3      
 481   3                    }
 482   2                    else if(inbuf[6]==0x0d)                                    //格式为P1(2)=NNN
 483   2                    {
 484   3                       las_pow=(uint)((inbuf[3]-48)*100+(inbuf[4]-48)*10+(inbuf[5]-48));
 485   3      
 486   3                    }
 487   2      
 488   2                    else                                                      //格式为P1(2)=NNNN
 489   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 9   

 490   3                        setfault();
 491   3                        goto setpf;
 492   3                    }
 493   2      
 494   2                    if(inbuf[2]=='1')
 495   2                    {
 496   3                      CH=3;                                     //种子源SEED
 497   3                      Set_laser_power(CHH,las_pow);
 498   3                      setsucced();
 499   3                    }
 500   2                    else if(inbuf[2]=='2')
 501   2                    {
 502   3                      CH=0;                                    //放大级AMP
 503   3                      Set_laser_power(CHH,las_pow);
 504   3                      setsucced();
 505   3                    }
 506   2                    else setfault();
 507   2      
 508   2      setpf:       _Nop();
 509   2      
 510   2      
 511   2                  }
 512   1       ////////////////////////////////////////////////////////////////////////////////////////
 513   1       //////////////////////////////设定温度//////////////////////////////////////////////////
 514   1              else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 515   1                 {
 516   2                    uint  tmp_tec=0;
 517   2                    uint kt=0;
 518   2                    if(inbuf[5]==0x0d)
 519   2                    {
 520   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 521   3      
 522   3      
 523   3      
 524   3      
 525   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
 526   3      
 527   3                    }
 528   2                    else if(inbuf[7]==0x0d)
 529   2                    {
 530   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 531   3      
 532   3                       kt=((tmp_tec-15)*691+(inbuf[6]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[6]-48)*59/5+90;
 533   3      
 534   3                    }
 535   2      
 536   2                    else
 537   2                    {
 538   3                       setfault();
 539   3                       goto settf;
 540   3                    }
 541   2      
 542   2                     if(inbuf[1]=='1')
 543   2                    {
 544   3                      DA_Convert(2,kt);                         //种子源SEED
 545   3                      _Nop();
 546   3                      DA_Convert(2,kt);
 547   3                      setsucced();
 548   3                    }
 549   2                    else if(inbuf[1]=='2')
 550   2                    {
 551   3                      DA_Convert(1,kt);                         //放大级AMP
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 10  

 552   3                      _Nop();
 553   3                      DA_Convert(1,kt);
 554   3                      setsucced();
 555   3                    }
 556   2                    else setfault();
 557   2      
 558   2      settf:       _Nop();
 559   2      
 560   2      
 561   2                 }
 562   1      
 563   1       ////////////////////////////////////////////////////////////////////////////////////////
 564   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
 565   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
 566   1               {
 567   2                     uint pwm_pulserate;
 568   2                   
 569   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
 570   2                    {
 571   3                       pwm_pulserate=inbuf[5]-48;
 572   3      
 573   3      
 574   3                    }
 575   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
 576   2                    {
 577   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 578   3      
 579   3                    }
 580   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 581   2                    {
 582   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 583   3      
 584   3                    }
 585   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 586   2                    {
 587   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 588   3      
 589   3                    }
 590   2                    else                                                    //格式为PURA=NNNN
 591   2                    {
 592   3                        setfault();
 593   3                        goto setprf;
 594   3                    }
 595   2                      Pwm_Set(pwm_pulserate,0,0);
 596   2                      setsucced();
 597   2      setprf:       _Nop();
 598   2      
 599   2                 }
 600   1                ////////////////////////////////////////////////////////////////////////////////////////
 601   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
 602   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
 603   1               {
 604   2                     uint pwm_pulsewidth;
 605   2                   
 606   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
 607   2                    {
 608   3                       pwm_pulsewidth=inbuf[5]-48;
 609   3      
 610   3      
 611   3                    }
 612   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 11  

 613   2                    {
 614   3                       pwm_pulsewidth=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 615   3      
 616   3                    }
 617   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 618   2                    {
 619   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 620   3      
 621   3                    }
 622   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 623   2                    {
 624   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 625   3      
 626   3                    }
 627   2                    else                                                    //格式为PUWI=NNNN
 628   2                    {
 629   3                        setfault();
 630   3                        goto setpwf;
 631   3                    }
 632   2                        Pwm_Set(0,pwm_pulsewidth,0);
 633   2                      setsucced();
 634   2      setpwf:       _Nop();
 635   2      
 636   2                 }
 637   1      
 638   1                 ////////////////////////////////////////////////////////////////////////////////////////
 639   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
 640   1              else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='='))
 641   1               {
 642   2                     uint pwm_pulsedelay;
 643   2                   
 644   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
 645   2                    {
 646   3                       pwm_pulsedelay=inbuf[5]-48;
 647   3      
 648   3      
 649   3                    }
 650   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
 651   2                    {
 652   3                       pwm_pulsedelay=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 653   3      
 654   3                    }
 655   2                    else                                                    //格式为DELY=NNNN
 656   2                    {
 657   3                        setfault();
 658   3                        goto setpdf;
 659   3                    }
 660   2                      Pwm_Set(0,0,pwm_pulsedelay);
 661   2                      setsucced();
 662   2      setpdf:       _Nop();
 663   2      
 664   2                 }
 665   1      
 666   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
 667   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
 668   1      
 669   1                 {
 670   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
 671   2                    {
 672   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
 673   3                       setsucced();
 674   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 12  

 675   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
 676   2                    {
 677   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
 678   3                       setsucced();
 679   3                    }
 680   2                    setfault();
 681   2      
 682   2                 }
 683   1      
 684   1       //////////////////////////////////强制关电流///////////////////////////////////////
 685   1      
 686   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
 687   1      
 688   1                 {
 689   2                    if(inbuf[7]==0x0d)
 690   2                    {
 691   3                       if(inbuf[5]=='S')
 692   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
 693   3                       else  if(inbuf[5]=='A')
 694   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
 695   3                       else
 696   3                        {
 697   4                         setfault();
 698   4                         goto setdf;
 699   4                        }
 700   3                       if (!LIM1)
 701   3                       {
 702   4                         Set_laser_current(3,50);
 703   4                         setsucced();
 704   4                        }
 705   3                       else if(!LIM2)
 706   3                       {
 707   4                         Set_laser_current(0,50);
 708   4                         setsucced();
 709   4                        }
 710   3                       else
 711   3                        {
 712   4                         setfault();
 713   4                         goto setdf;
 714   4                        }
 715   3                    }
 716   2                    else
 717   2                       setfault();
 718   2      setdf:       _Nop();
 719   2                 }
 720   1      //////////////////////////////////总查询（电流、温度、功率）/////////////////////////////////
 721   1            else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&((inbuf[2]=='A')&&(inbuf[3]=='T'))&&(inbuf[4]=='E')&&(inbu
             -f[5]=='?'))
 722   1       {
 723   2                    uint ky;
 724   2      //              TEC_Temp();
 725   2                    inbuf[0]= 0x0d;
 726   2                    send_string_com(inbuf,1);
 727   2                      inbuf[0] ='L';
 728   2                      inbuf[1] ='D';
 729   2                      inbuf[2] ='1';
 730   2                      inbuf[3] ='=';
 731   2                  if(Laser_Fed_curent1<10)
 732   2                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 733   3                      inbuf[5]=0x0d;
 734   3                      inbuf[6]=0x0a;
 735   3                      send_string_com(inbuf,7);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 13  

 736   3                    }else if (Laser_Fed_curent1<100)
 737   2                    { 
 738   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 739   3                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 740   3                      inbuf[6]=0x0d;
 741   3                      inbuf[7]=0x0a;
 742   3                      send_string_com(inbuf,8);
 743   3                    }else if (Laser_Fed_curent1<1000)
 744   2                    {
 745   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 746   3                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 747   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 748   3                      inbuf[7]=0x0d;
 749   3                      inbuf[8]=0x0a;
 750   3                      send_string_com(inbuf,9);
 751   3                    }
 752   2                    else
 753   2                      setfault();
 754   2      
 755   2                      inbuf[0] ='L';
 756   2                      inbuf[1] ='D';
 757   2                      inbuf[2] ='2';
 758   2                      inbuf[3] ='=';
 759   2                  if(Laser_Fed_curent2<10)
 760   2                    {
 761   3                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 762   3                      inbuf[5]=0x0d;
 763   3                      inbuf[6]=0x0a;
 764   3                      send_string_com(inbuf,7);
 765   3                    }else if (Laser_Fed_curent2<100)
 766   2                    {
 767   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
 768   3                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
 769   3                      inbuf[6]=0x0d;
 770   3                      inbuf[7]=0x0a;
 771   3                      send_string_com(inbuf,8);
 772   3                    }else if (Laser_Fed_curent2<1000)
 773   2                    {
 774   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
 775   3                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 776   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
 777   3                      inbuf[7]=0x0d;
 778   3                      inbuf[8]=0x0a;
 779   3                      send_string_com(inbuf,9);
 780   3                    }
 781   2                    else
 782   2                      setfault();
 783   2                    inbuf[0]= 0x0d;
 784   2                    send_string_com(inbuf,1);
 785   2                      inbuf[0] ='P';
 786   2                      inbuf[1] ='1';
 787   2                      inbuf[2] ='=';
 788   2                if(Laser_Fed_power1<10)
 789   2                    {
 790   3                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
 791   3                      inbuf[4]=0x0d;
 792   3                      inbuf[5]=0x0a;
 793   3                      send_string_com(inbuf,6);
 794   3                    }else if (Laser_Fed_power1<100)
 795   2                    {
 796   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
 797   3                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 14  

 798   3                      inbuf[5]=0x0d;
 799   3                      inbuf[6]=0x0a;
 800   3                      send_string_com(inbuf,7);
 801   3                    }else if (Laser_Fed_power1<1000)
 802   2                    {
 803   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
 804   3                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
 805   3                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
 806   3                      inbuf[6]=0x0d;
 807   3                      inbuf[7]=0x0a;
 808   3                      send_string_com(inbuf,8);
 809   3                    }
 810   2                    else
 811   2                      setfault();
 812   2                      
 813   2                      inbuf[0] ='P';
 814   2                      inbuf[1] ='2';
 815   2                      inbuf[2] ='=';
 816   2                    if(Laser_Fed_power2<10)
 817   2                    {
 818   3                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
 819   3                      inbuf[4]=0x0d;
 820   3                      inbuf[5]=0x0a;
 821   3                      send_string_com(inbuf,6);
 822   3                    }else if (Laser_Fed_power2<100)
 823   2                    {
 824   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
 825   3                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
 826   3                      inbuf[5]=0x0d;
 827   3                      inbuf[6]=0x0a;
 828   3                      send_string_com(inbuf,7);
 829   3                    }else if (Laser_Fed_power2<1000)
 830   2                    {
 831   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
 832   3                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
 833   3                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
 834   3                      inbuf[6]=0x0d;
 835   3                      inbuf[7]=0x0a;
 836   3                      send_string_com(inbuf,8);
 837   3                    }
 838   2                    else
 839   2                      setfault();
 840   2      
 841   2                      inbuf[0]= 0x0d;
 842   2                      send_string_com(inbuf,1);
 843   2                      ky=(uint)(TEC_Fed_Tempture1);
 844   2                      inbuf[0] ='T';
 845   2                      inbuf[1] ='1';
 846   2                      inbuf[2] ='=';
 847   2                    if (ky<1000)
 848   2                    {
 849   3                      inbuf[3]  =ky/100+48;
 850   3                      inbuf[4]  =(ky/10)%10+48;
 851   3                      inbuf[5]  ='.';
 852   3                      inbuf[6]  =ky%10+48;
 853   3                      inbuf[7] =0x0d;
 854   3                      inbuf[8] =0x0a;
 855   3                      send_string_com(inbuf,9);
 856   3                    }
 857   2                    else
 858   2                     alarm();
 859   2                  
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 15  

 860   2                     
 861   2                      ky=(uint)(TEC_Fed_Tempture2);
 862   2                      inbuf[0] ='T';
 863   2                      inbuf[1] ='2';
 864   2                      inbuf[2] ='=';
 865   2                    if (ky<1000)
 866   2                    {
 867   3                      inbuf[3]  =ky/100+48;
 868   3                      inbuf[4]  =(ky/10)%10+48;
 869   3                      inbuf[5]  ='.';
 870   3                      inbuf[6]  =ky%10+48;
 871   3                      inbuf[7] =0x0d;
 872   3                      inbuf[8] =0x0a;
 873   3                      send_string_com(inbuf,9);
 874   3                    }
 875   2                    else
 876   2                     alarm();
 877   2                     inbuf[0]= 0x0d;
 878   2                    send_string_com(inbuf,1);
 879   2                   if (TMPGD1)
 880   2                    {
 881   3                      inbuf[0]='T';
 882   3                      inbuf[1]='1';
 883   3                      inbuf[2]='O';
 884   3                      inbuf[3]='K';
 885   3                      inbuf[4]=0x0d;
 886   3                      inbuf[5]=0x0a;
 887   3                      send_string_com(inbuf,6);
 888   3                    }
 889   2      
 890   2                    else
 891   2                    {
 892   3                      inbuf[0]='T';
 893   3                      inbuf[1]='1';
 894   3                      inbuf[2]='N';
 895   3                      inbuf[3]='O';
 896   3                      inbuf[4]=0x0d;
 897   3                      inbuf[5]=0x0a;
 898   3                      send_string_com(inbuf,6);
 899   3                    }
 900   2      
 901   2                    if (TMPGD2)
 902   2                    {
 903   3                      inbuf[0]='T';
 904   3                      inbuf[1]='2';
 905   3                      inbuf[2]='O';
 906   3                      inbuf[3]='K';
 907   3                      inbuf[4]=0x0d;
 908   3                      inbuf[5]=0x0a;
 909   3                      send_string_com(inbuf,6);
 910   3                    }
 911   2      
 912   2                    else
 913   2                    {
 914   3                      inbuf[0]='T';
 915   3                      inbuf[1]='2';
 916   3                      inbuf[2]='N';
 917   3                      inbuf[3]='O';
 918   3                      inbuf[4]=0x0d;
 919   3                      inbuf[5]=0x0a;
 920   3                      send_string_com(inbuf,6);
 921   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 16  

 922   2      }
 923   1      
 924   1      
 925   1      
 926   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
 927   1            else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='?'))
 928   1                 {
 929   2                  if(inbuf[2]=='1')
 930   2                  {   inbuf[0] ='L';
 931   3                      inbuf[1] ='D';
 932   3                      inbuf[2] ='1';
 933   3                      inbuf[3] ='=';
 934   3                  if(Laser_Fed_curent1<10)
 935   3                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 936   4                      inbuf[5]=0x0d;
 937   4                      inbuf[6]=0x0a;
 938   4                      send_string_com(inbuf,7);
 939   4                    }else if (Laser_Fed_curent1<100)
 940   3                    { 
 941   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 942   4                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 943   4                      inbuf[6]=0x0d;
 944   4                      inbuf[7]=0x0a;
 945   4                      send_string_com(inbuf,8);
 946   4                    }else if (Laser_Fed_curent1<1000)
 947   3                    {
 948   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 949   4                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 950   4                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 951   4                      inbuf[7]=0x0d;
 952   4                      inbuf[8]=0x0a;
 953   4                      send_string_com(inbuf,9);
 954   4                    }
 955   3                    else
 956   3                      setfault();
 957   3      
 958   3                     }
 959   2       //////////////////////////////////////////////////////////
 960   2                  else if(inbuf[2]=='2')
 961   2                    {  inbuf[0] ='L';
 962   3                      inbuf[1] ='D';
 963   3                      inbuf[2] ='2';
 964   3                      inbuf[3] ='=';
 965   3                  if(Laser_Fed_curent2<10)
 966   3                    {
 967   4                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 968   4                      inbuf[5]=0x0d;
 969   4                      inbuf[6]=0x0a;
 970   4                      send_string_com(inbuf,7);
 971   4                    }else if (Laser_Fed_curent2<100)
 972   3                    {
 973   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
 974   4                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
 975   4                      inbuf[6]=0x0d;
 976   4                      inbuf[7]=0x0a;
 977   4                      send_string_com(inbuf,8);
 978   4                    }else if (Laser_Fed_curent2<1000)
 979   3                    {
 980   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
 981   4                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 982   4                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
 983   4                      inbuf[7]=0x0d;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 17  

 984   4                      inbuf[8]=0x0a;
 985   4                      send_string_com(inbuf,9);
 986   4                    }
 987   3                    else
 988   3                      setfault();
 989   3                 }
 990   2               }
 991   1      
 992   1      
 993   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
 994   1            else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
 995   1      
 996   1                 {
 997   2                  if(inbuf[1]=='1')
 998   2                    {
 999   3                     inbuf[0] ='P';
1000   3                      inbuf[1] ='1';
1001   3                      inbuf[2] ='=';
1002   3                    if(Laser_Fed_power1<10)
1003   3                    {
1004   4                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
1005   4                      inbuf[4]=0x0d;
1006   4                      inbuf[5]=0x0a;
1007   4                      send_string_com(inbuf,6);
1008   4                    }else if (Laser_Fed_power1<100)
1009   3                    {
1010   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
1011   4                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
1012   4                      inbuf[5]=0x0d;
1013   4                      inbuf[6]=0x0a;
1014   4                      send_string_com(inbuf,7);
1015   4                    }else if (Laser_Fed_power1<1000)
1016   3                    {
1017   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
1018   4                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
1019   4                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
1020   4                      inbuf[6]=0x0d;
1021   4                      inbuf[7]=0x0a;
1022   4                      send_string_com(inbuf,8);
1023   4                    }
1024   3                    else
1025   3                      setfault();
1026   3                      
1027   3                    }
1028   2                    else if(inbuf[1]=='2')
1029   2                     {
1030   3                      inbuf[0] ='P';
1031   3                      inbuf[1] ='2';
1032   3                      inbuf[2] ='=';
1033   3                    if(Laser_Fed_power2<10)
1034   3                    {
1035   4                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
1036   4                      inbuf[4]=0x0d;
1037   4                      inbuf[5]=0x0a;
1038   4                      send_string_com(inbuf,6);
1039   4                    }else if (Laser_Fed_power2<100)
1040   3                    {
1041   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
1042   4                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
1043   4                      inbuf[5]=0x0d;
1044   4                      inbuf[6]=0x0a;
1045   4                      send_string_com(inbuf,7);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 18  

1046   4                    }else if (Laser_Fed_power2<1000)
1047   3                    {
1048   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
1049   4                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
1050   4                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
1051   4                      inbuf[6]=0x0d;
1052   4                      inbuf[7]=0x0a;
1053   4                      send_string_com(inbuf,8);
1054   4                    }
1055   3                    else
1056   3                      setfault();
1057   3                  }
1058   2                 }
1059   1      
1060   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
1061   1            else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1062   1                 {
1063   2      
1064   2                    uint ky;
1065   2      //              TEC_Temp();
1066   2                    if (inbuf[1]=='1')
1067   2                    {  ky=(uint)(TEC_Fed_Tempture1);
1068   3                      inbuf[0] ='T';
1069   3                      inbuf[1] ='1';
1070   3                      inbuf[2] ='=';
1071   3                    if (ky<1000)
1072   3                    {
1073   4                      inbuf[3]  =ky/100+48;
1074   4                      inbuf[4]  =(ky/10)%10+48;
1075   4                      inbuf[5]  ='.';
1076   4                      inbuf[6]  =ky%10+48;
1077   4                      inbuf[7] =0x0d;
1078   4                      inbuf[8] =0x0a;
1079   4                      send_string_com(inbuf,9);
1080   4                    }
1081   3                    else
1082   3                     alarm();  
1083   3                    }
1084   2                  else if (inbuf[1]=='2')
1085   2                    { 
1086   3                      ky=(uint)(TEC_Fed_Tempture2);
1087   3                      inbuf[0] ='T';
1088   3                      inbuf[1] ='2';
1089   3                      inbuf[2] ='=';
1090   3                    if (ky<1000)
1091   3                    {
1092   4                      inbuf[3]  =ky/100+48;
1093   4                      inbuf[4]  =(ky/10)%10+48;
1094   4                      inbuf[5]  ='.';
1095   4                      inbuf[6]  =ky%10+48;
1096   4                      inbuf[7] =0x0d;
1097   4                      inbuf[8] =0x0a;
1098   4                      send_string_com(inbuf,9);
1099   4                    }
1100   3                    else
1101   3                     alarm();
1102   3                 }
1103   2               }
1104   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
1105   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1106   1      
1107   1                 {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 19  

1108   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1109   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1110   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1111   2      
1112   2                    inbuf[4]='S';
1113   2                    inbuf[5]='=';
1114   2                    inbuf[6]=inbuf[6]+48;
1115   2                    inbuf[7]='.';
1116   2                    inbuf[8]=inbuf[8]+48;
1117   2                    inbuf[9]=inbuf[9]+48;
1118   2                    inbuf[10]=0x0d;
1119   2                    inbuf[11]=0x0a;
1120   2      
1121   2                    send_string_com(inbuf,12);
1122   2      
1123   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1124   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1125   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1126   2      
1127   2                    inbuf[4]='A';
1128   2                    inbuf[5]='=';
1129   2                    inbuf[6]=inbuf[6]+48;
1130   2                    inbuf[7]='.';
1131   2                    inbuf[8]=inbuf[8]+48;
1132   2                    inbuf[9]=inbuf[9]+48;
1133   2                    inbuf[10]=0x0d;
1134   2                    inbuf[11]=0x0a;
1135   2      
1136   2                    send_string_com(inbuf,12);
1137   2      
1138   2      
1139   2                 }
1140   1      
1141   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1142   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1143   1      
1144   1                 {
1145   2      
1146   2      
1147   2      
1148   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1149   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1150   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1151   2      
1152   2                    inbuf[4]='S';
1153   2                    inbuf[5]='=';
1154   2                    inbuf[6]=inbuf[6]+48;
1155   2                    inbuf[7]='.';
1156   2                    inbuf[8]=inbuf[8]+48;
1157   2                    inbuf[9]=inbuf[9]+48;
1158   2                    inbuf[10]=0x0d;
1159   2                    inbuf[11]=0x0a;
1160   2      
1161   2                    send_string_com(inbuf,12);
1162   2      
1163   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1164   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1165   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1166   2      
1167   2                    inbuf[4]='A';
1168   2                    inbuf[5]='=';
1169   2                    inbuf[6]=inbuf[6]+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 20  

1170   2                    inbuf[7]='.';
1171   2                    inbuf[8]=inbuf[8]+48;
1172   2                    inbuf[9]=inbuf[9]+48;
1173   2                    inbuf[10]=0x0d;
1174   2                    inbuf[11]=0x0a;
1175   2      
1176   2                    send_string_com(inbuf,12);
1177   2      
1178   2                 }
1179   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1180   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1181   1      
1182   1                 {
1183   2                    if (TMPGD1)
1184   2                    {
1185   3                      inbuf[4]='S';
1186   3                      inbuf[5]=' ';
1187   3                      inbuf[6]='O';
1188   3                      inbuf[7]='K';
1189   3                      inbuf[8]=0x0d;
1190   3                      inbuf[9]=0x0a;
1191   3                      send_string_com(inbuf,10);
1192   3                    }
1193   2      
1194   2                    else
1195   2                    {
1196   3                      inbuf[4]='S';
1197   3                      inbuf[5]=' ';
1198   3                      inbuf[6]='N';
1199   3                      inbuf[7]='O';
1200   3                      inbuf[8]=0x0d;
1201   3                      inbuf[9]=0x0a;
1202   3                      send_string_com(inbuf,10);
1203   3                    }
1204   2      
1205   2                    if (TMPGD2)
1206   2                    {
1207   3                      inbuf[4]='A';
1208   3                      inbuf[5]=' ';
1209   3                      inbuf[6]='O';
1210   3                      inbuf[7]='K';
1211   3                      inbuf[8]=0x0d;
1212   3                      inbuf[9]=0x0a;
1213   3                      send_string_com(inbuf,10);
1214   3                    }
1215   2      
1216   2                    else
1217   2                    {
1218   3                      inbuf[4]='A';
1219   3                      inbuf[5]=' ';
1220   3                      inbuf[6]='N';
1221   3                      inbuf[7]='O';
1222   3                      inbuf[8]=0x0d;
1223   3                      inbuf[9]=0x0a;
1224   3                      send_string_com(inbuf,10);
1225   3                    }
1226   2      
1227   2                 }
1228   1      
1229   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1230   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1231   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 21  

1232   1                 {
1233   2                    if (SHDN1)
1234   2                    {
1235   3                      inbuf[0]='T';
1236   3                      inbuf[1]='E';
1237   3                      inbuf[2]='C';
1238   3                      inbuf[3]='1';
1239   3                      inbuf[4]=' ';
1240   3                      inbuf[5]='O';
1241   3                      inbuf[6]='N';
1242   3                      inbuf[7]=0x0d;
1243   3                      inbuf[8]=0x0a;
1244   3                      send_string_com(inbuf,9);
1245   3                    }
1246   2      
1247   2                    else
1248   2                    {
1249   3                      inbuf[0]='T';
1250   3                      inbuf[1]='E';
1251   3                      inbuf[2]='C';
1252   3                      inbuf[3]='1';
1253   3                      inbuf[4]=' ';
1254   3                      inbuf[5]='O';
1255   3                      inbuf[6]='F';
1256   3                      inbuf[7]='F';
1257   3                      inbuf[8]=0x0d;
1258   3                      inbuf[9]=0x0a;
1259   3                      send_string_com(inbuf,10);
1260   3                    }
1261   2      
1262   2                    if (SHDN2)
1263   2                    {
1264   3                      inbuf[0]='T';
1265   3                      inbuf[1]='E';
1266   3                      inbuf[2]='C';
1267   3                      inbuf[3]='2';
1268   3                      inbuf[4]=' ';
1269   3                      inbuf[5]='O';
1270   3                      inbuf[6]='N';
1271   3                      inbuf[7]=0x0d;
1272   3                      inbuf[8]=0x0a;
1273   3                      send_string_com(inbuf,9);
1274   3                    }
1275   2      
1276   2                    else
1277   2                    {
1278   3                      inbuf[0]='T';
1279   3                      inbuf[1]='E';
1280   3                      inbuf[2]='C';
1281   3                      inbuf[3]='2';
1282   3                      inbuf[4]=' ';
1283   3                      inbuf[5]='O';
1284   3                      inbuf[6]='F';
1285   3                      inbuf[7]='F';
1286   3                      inbuf[8]=0x0d;
1287   3                      inbuf[9]=0x0a;
1288   3                      send_string_com(inbuf,10);
1289   3                    }
1290   2                 }
1291   1      
1292   1      ///////////////////////////////////////////////////////////////////////////////////
1293   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 22  

1294   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1295   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1296   1      
1297   1                 {
1298   2                    if (CONT_MOD)
1299   2                    {
1300   3                      inbuf[0]='M';
1301   3                      inbuf[1]='O';
1302   3                      inbuf[2]='D';
1303   3                      inbuf[3]='=';
1304   3                      inbuf[4]='A';
1305   3                      inbuf[5]='P';
1306   3                      inbuf[6]='C';
1307   3                      inbuf[7]=0x0d;
1308   3                      inbuf[8]=0x0a;
1309   3                      send_string_com(inbuf,9);
1310   3                    }
1311   2      
1312   2                    else
1313   2                    {
1314   3                      inbuf[0]='M';
1315   3                      inbuf[1]='O';
1316   3                      inbuf[2]='D';
1317   3                      inbuf[3]='=';
1318   3                      inbuf[4]='A';
1319   3                      inbuf[5]='C';
1320   3                      inbuf[6]='C';
1321   3                      inbuf[7]=0x0d;
1322   3                      inbuf[8]=0x0a;
1323   3                      send_string_com(inbuf,9);
1324   3                    }
1325   2                 }
1326   1      
1327   1      
1328   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1329   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1330   1            {
1331   2                 if(inbuf[6]==0x0d)
1332   2                    {
1333   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1334   3                       setsucced();
1335   3                    }
1336   2                 else
1337   2                    setfault();
1338   2            }
1339   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1340   1      
1341   1            else
1342   1             setfault();                              //设置错误
1343   1      
1344   1      
1345   1      
1346   1           return;
1347   1      
1348   1      }
1349          /*******************************************************************************/
1350          
1351          
1352          
1353          
1354          
1355          /*****************************设置显示****************************************
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 23  

1356          void Lcd_disp()
1357          {
1358           wr_lcd (comm,0x30);                    //设定工作方式
1359           delay(1);
1360           wr_lcd (comm,0x01);                    //清屏
1361           delay(1);
1362           wr_lcd (comm,0x0d);                    //开显示
1363           delay(1);
1364           wr_lcd (comm,0x10);
1365           delay(30);
1366          
1367           if(CONT_MOD)                          //CONT_MOD: 1 APC, 0 ACC
1368          
1369          //*****************APC模式显示设定功率*********************************
1370           {
1371             chn_disp (tab13,8,0x80);
1372             delayR(50);
1373             chn_disp (Power_parameter1,6,0x84);
1374           }
1375          
1376          //********************************************************************
1377           else
1378          //****************ACC模式显示电流设定**********************************
1379           {
1380            chn_disp (tab9,8,0x80);
1381            delayR(50);
1382            chn_disp (Diode_parameter1,6,0x84);
1383          
1384           }
1385          //*********************************************************************
1386          
1387           delayR(50);
1388          
1389          //*****************显示设定温度****************************************
1390          
1391           delayR(50);
1392           chn_disp (TEC_parameter1,4,0x94);
1393           delayR(50);
1394           chn_disp (tab11,2,0x96);
1395           delayR(50);
1396          // wr_lcd (comm,0x90);
1397          //********************************************************************
1398          
1399          }
1400          /**************************************************************************
1401          
1402          
1403          /*****************************判断按键电压*********************************
1404          void Key_Button()
1405          {
1406            uchar kk=10;
1407            uchar tec_a=0;
1408            uchar tec_b=0;
1409            Key_V=0;
1410          
1411          
1412          
1413          
1414            return;
1415          }
1416          
1417          /**************************************************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 24  

1418          
1419          /**********************二极管电流监测**************************************/
1420          void Diode_curent_Check()
1421          {
1422   1          uchar k=16;
1423   1      //    float a,b;
1424   1          AD_inbuf[0]=0;
1425   1          AD_inbuf[1]=0;
1426   1          do
1427   1          {
1428   2            AD_code=AD_Convert(0);                  //种子源电流
1429   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
1430   2      
1431   2            AD_code=AD_Convert(3);                  //放大级电流
1432   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
1433   2      
1434   2            k--;
1435   2          }while(k);
1436   1      
1437   1      
1438   1          AD_inbuf[0]=AD_inbuf[0]/16;
1439   1          AD_inbuf[1]=AD_inbuf[1]/16;
1440   1      
1441   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
1442   1          Laser_meds_curent1=Laser_Fed_curent1;
1443   1          if (Laser_Fed_curent1<10)
1444   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
1445   2              Diode_parameter1[1]=0x6d;
1446   2              Diode_parameter1[2]=0x41;
1447   2              Diode_parameter1[3]=0x20;
1448   2              Diode_parameter1[4]=0x20;
1449   2      
1450   2            } else if(Laser_Fed_curent1<100)
1451   1      
1452   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
1453   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
1454   2              Diode_parameter1[2]=0x6d;
1455   2              Diode_parameter1[3]=0x41;
1456   2              Diode_parameter1[4]=0x20;
1457   2            } else if(Laser_Fed_curent1<1000)
1458   1      
1459   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
1460   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
1461   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
1462   2              Diode_parameter1[3]=0x6d;
1463   2              Diode_parameter1[4]=0x41;
1464   2            }
1465   1      
1466   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
1467   1          Laser_meds_curent2=Laser_Fed_curent2;
1468   1          if (Laser_Fed_curent2<10)
1469   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
1470   2              Diode_parameter2[1]=0x6d;
1471   2              Diode_parameter2[2]=0x41;
1472   2              Diode_parameter2[3]=0x20;
1473   2              Diode_parameter2[4]=0x20;
1474   2      
1475   2            } else if(Laser_Fed_curent2<100)
1476   1      
1477   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
1478   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
1479   2              Diode_parameter2[2]=0x6d;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 25  

1480   2              Diode_parameter2[3]=0x41;
1481   2              Diode_parameter2[4]=0x20;
1482   2            } else if(Laser_Fed_curent2<1000)
1483   1      
1484   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
1485   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
1486   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
1487   2              Diode_parameter2[3]=0x6d;
1488   2              Diode_parameter2[4]=0x41;
1489   2            }
1490   1      
1491   1          return;
1492   1      }
1493          /**************************************************************************/
1494          /*****************************激光功率检测*********************************/
1495          void Laser_power_Check()
1496          {
1497   1      
1498   1          uchar k=10;
1499   1          float a,b;
1500   1          AD_inbuf[8]=0;
1501   1          AD_inbuf[9]=0;
1502   1          do
1503   1          {
1504   2            AD_code=AD_Convert(1);                  //种子源
1505   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
1506   2      
1507   2            AD_code=AD_Convert(4);                  //放大级
1508   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
1509   2            k--;
1510   2          }while(k);
1511   1      
1512   1      
1513   1      
1514   1          AD_inbuf[8]=AD_inbuf[8]/10;
1515   1          AD_inbuf[9]=AD_inbuf[9]/10;
1516   1      
1517   1          AD_code=AD_inbuf[8];
1518   1          a=(float)(AD_code);
1519   1          a=a*2.5;
1520   1          a=a/4096+0.02015;
1521   1          b=a*a*117.314+275.543*a-0.806;
1522   1      
1523   1          Laser_Fed_power1=(uint)(b);
1524   1          Laser_meds_power1=Laser_Fed_power1;
1525   1      
1526   1          if (Laser_Fed_power1<10)
1527   1            { Power_parameter1[0]=Laser_Fed_power1+48;
1528   2              Power_parameter1[1]=0x6d;
1529   2              Power_parameter1[2]=0x77;
1530   2              Power_parameter1[3]=0x20;
1531   2              Power_parameter1[4]=0x20;
1532   2              Power_parameter1[5]=0x20;
1533   2      
1534   2            } else if(Laser_Fed_power1<100)
1535   1      
1536   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
1537   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
1538   2              Power_parameter1[2]=0x6d;
1539   2              Power_parameter1[3]=0x77;
1540   2              Power_parameter1[4]=0x20;
1541   2              Power_parameter1[5]=0x20;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 26  

1542   2            } else if(Laser_Fed_power1<1000)
1543   1      
1544   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
1545   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
1546   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
1547   2              Power_parameter1[3]=0x6d;
1548   2              Power_parameter1[4]=0x77;
1549   2              Power_parameter1[5]=0x20;
1550   2            }
1551   1      
1552   1          AD_code=AD_inbuf[9];
1553   1          a=(float)(AD_code);
1554   1          a=a*2.5;
1555   1          a=a/4096+0.02015;
1556   1          b=a*a*117.314+275.543*a-0.806;
1557   1      
1558   1          Laser_Fed_power2=(uint)(b);
1559   1          Laser_meds_power2=Laser_Fed_power2;
1560   1      
1561   1          if (Laser_Fed_power2<10)
1562   1            { Power_parameter2[0]=Laser_Fed_power2+48;
1563   2              Power_parameter2[1]=0x6d;
1564   2              Power_parameter2[2]=0x77;
1565   2              Power_parameter2[3]=0x20;
1566   2              Power_parameter2[4]=0x20;
1567   2              Power_parameter2[5]=0x20;
1568   2      
1569   2            } else if(Laser_Fed_power2<100)
1570   1      
1571   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
1572   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
1573   2              Power_parameter2[2]=0x6d;
1574   2              Power_parameter2[3]=0x77;
1575   2              Power_parameter2[4]=0x20;
1576   2              Power_parameter2[5]=0x20;
1577   2            } else if(Laser_Fed_power2<1000)
1578   1      
1579   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
1580   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
1581   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
1582   2              Power_parameter2[3]=0x6d;
1583   2              Power_parameter2[4]=0x77;
1584   2              Power_parameter2[5]=0x20;
1585   2            }
1586   1      
1587   1          return;
1588   1      
1589   1      
1590   1      
1591   1      }
1592          /**************************************************************************/
1593          
1594          
1595          /*****************************当前冷却温度*********************************/
1596          void TEC_Temp()
1597          {
1598   1          uint  tx1=0;
1599   1          uint  tx2=0;
1600   1          uchar kt=16;
1601   1          AD_inbuf[6]=0;
1602   1          AD_inbuf[7]=0;
1603   1          do
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 27  

1604   1          {
1605   2            AD_code=AD_Convert(2);        //种子源TEC温度
1606   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
1607   2      
1608   2            AD_code=AD_Convert(5);        //放大级TEC温度
1609   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
1610   2            kt--;
1611   2          }while(kt);
1612   1      
1613   1           AD_inbuf[6]=AD_inbuf[6]/16;
1614   1           AD_inbuf[7]=AD_inbuf[7]/16;
1615   1           TEC_meds_tempture1=AD_inbuf[6];
1616   1           TEC_meds_tempture2=AD_inbuf[7];
1617   1      
1618   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
1619   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
1620   1           tx1= (uint)(TEC_Fed_Tempture1);
1621   1           TEC_meds_tempture1=tx1;
1622   1           tx2= (uint)(TEC_Fed_Tempture2);
1623   1           TEC_meds_tempture2=tx2;
1624   1      
1625   1           TEC_parameter1[0]=tx1 /100+48;
1626   1           TEC_parameter1[1]=(tx1 /10)%10+48;
1627   1           TEC_parameter1[2]=0x2e;
1628   1           TEC_parameter1[3]=tx1 %10+48;
1629   1      
1630   1      
1631   1           TEC_parameter2[0]=tx2 /100+48;
1632   1           TEC_parameter2[1]=(tx2 /10)%10+48;
1633   1           TEC_parameter2[2]=0x2e;
1634   1           TEC_parameter2[3]=tx2 %10+48;
1635   1      
1636   1      
1637   1        return;
1638   1      }
1639          
1640          /**************************************************************************/
1641          
1642          /*****************************当前TEC两端电压******************************/
1643          void TEC_V_Check()                                                 //???????????????????????
1644          {
1645   1          uchar kk=20;
1646   1          AD_inbuf[4]=0;
1647   1          AD_inbuf[5]=0;
1648   1          do
1649   1          {
1650   2            MCU_ADC(1);
1651   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
1652   2            MCU_ADC(2);
1653   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
1654   2            kk--;
1655   2          }while(kk);
1656   1      
1657   1      
1658   1           TEC_VO1=AD_inbuf[4]/20 ;
1659   1           TEC_VO1=TEC_VO1*5;
1660   1           TEC_VO2=AD_inbuf[4]/20 ;
1661   1           TEC_VO2=TEC_VO2*5;
1662   1      
1663   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
1664   1      //     TEC_parameter[1]=0x2e;
1665   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 28  

1666   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
1667   1      //     TEC_parameter[4]=0xa0;
1668   1      //     TEC_parameter[5]=0x56;
1669   1          return;
1670   1      }
1671          
1672          /**************************************************************************/
1673          
1674          /*****************************监测二极管电压******************************/
1675          void Pdiod_V_Check()
1676          {
1677   1          uchar kk=10;
1678   1          AD_inbuf[2]=0;
1679   1          AD_inbuf[3]=0;
1680   1          do
1681   1          {
1682   2            AD_code=AD_Convert(1);             //种子源激光二极管
1683   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
1684   2      
1685   2            AD_code=AD_Convert(4);             //放大级激光二极管
1686   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
1687   2            kk--;
1688   2          }while(kk);
1689   1      
1690   1           PDiode_V1= AD_inbuf[2]/10;
1691   1           PDiode_V2= AD_inbuf[3]/10;
1692   1           PDiode_V1=(PDiode_V1*5)/2;
1693   1           PDiode_V2=(PDiode_V2*5)/2;
1694   1          return;
1695   1      }
1696          /**************************************************************************/
1697          
1698          
1699          
1700          /*******************************设定温度值*************************************
1701          
1702          void Set_TEC_TEMP(uint tempture)
1703          {
1704               uint kt;
1705          
1706                kt=(uint)((tempture-15)*4096/35);
1707                DA_Convert(1,kt);
1708          
1709          
1710          
1711          
1712             return;
1713          }
1714          
1715          
1716          /******************************************************************************/
1717          
1718          /*****************************设定功率值**********************************/
1719          void Set_laser_power(uchar Channel,uint power)
1720          {
1721   1        float  u,v;
1722   1        uint   temp_p;
1723   1      
1724   1        if (power<3) power=3;
1725   1        if (power>600) power=600;
1726   1        u=(float)(power);
1727   1        v=(u*u/1000)*3.46;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 29  

1728   1        v=6.5068*u+29.61-v;
1729   1        temp_p=(uint)(v);
1730   1      
1731   1      
1732   1        if(Channel==3)                                         //设定种子源功率
1733   1        {
1734   2      
1735   2          if(SHDN1)
1736   2           {
1737   3      
1738   3                DA_Convert(3,temp_p);
1739   3                _Nop();
1740   3                DA_Convert(3,temp_p);
1741   3           }
1742   2      
1743   2           Laser_Set_power1=power;
1744   2         }
1745   1      
1746   1      
1747   1          else if(Channel==0)
1748   1        {
1749   2      
1750   2          if(SHDN2)                                             //设定放大级功率
1751   2           {
1752   3      
1753   3                DA_Convert(0,temp_p);
1754   3                _Nop();
1755   3                DA_Convert(0,temp_p);
1756   3           }
1757   2      
1758   2           Laser_Set_power2=power;
1759   2         }
1760   1      
1761   1         else  _Nop();
1762   1      
1763   1         Laser_power_Check();
1764   1      
1765   1      
1766   1          return;
1767   1      
1768   1      }
1769          
1770          
1771          /*************************************************************************/
1772          
1773          /*****************************设定电流值**********************************/
1774          
1775          void Set_laser_current(uchar Channel,uint current)
1776          {
1777   1      
1778   1          uint tmp_c1;
1779   1      
1780   1          if (current<30) current=30;
1781   1          if (current>900) current=900;
1782   1      
1783   1      
1784   1      
1785   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
1786   1      
1787   1      
1788   1      
1789   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 30  

1790   1      
1791   1          if(Channel==3)
1792   1          {
1793   2             if(SHDN1)
1794   2             {
1795   3      
1796   3                  DA_Convert(3,tmp_c1);
1797   3                  _Nop();
1798   3                  DA_Convert(3,tmp_c1);
1799   3      
1800   3                  Laser_Set_curent1=current;
1801   3             }
1802   2      
1803   2             _Nop();
1804   2          }
1805   1      
1806   1          else if(Channel==0)
1807   1          {
1808   2             if(SHDN2)
1809   2             {
1810   3      
1811   3                  DA_Convert(0,tmp_c1);
1812   3                  _Nop();
1813   3                  DA_Convert(0,tmp_c1);
1814   3      
1815   3                  Laser_Set_curent2=current;
1816   3             }
1817   2      
1818   2             _Nop();
1819   2          }
1820   1      
1821   1      
1822   1      
1823   1      
1824   1      /*
1825   1        if (tmp_c1>tmp_c0)
1826   1          {
1827   1            do
1828   1            {
1829   1      
1830   1              while(!TMPGD)
1831   1              {
1832   1                TEC_Temp();
1833   1                if(tx>280)
1834   1              {
1835   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
1836   1                send_string_com(inbuf1,9);
1837   1                t=0;
1838   1                SHDN=0;
1839   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
1840   1                tmp_c1=246;
1841   1                Laser_Set_curent=30;
1842   1                 do
1843   1               {
1844   1                tmp_c0=tmp_c0-2;
1845   1                DA_Convert(0,tmp_c0);
1846   1                m++;
1847   1      
1848   1                 if(m==240)
1849   1                 {
1850   1                  Diode_curent_Check();
1851   1                  TEC_Temp();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 31  

1852   1                  chn_disp (tab6,6,0x80);
1853   1                  delayR(500);
1854   1                  chn_disp (Diode_parameter,6,0x83);
1855   1                  delayR(500);
1856   1                  chn_disp (tab7,4,0x90);
1857   1                  delayR(500);
1858   1                  chn_disp (TEC_parameter,4,0x92);
1859   1                  delayR(100);
1860   1                  chn_disp (tab11,2,0x94);
1861   1                  m=0;
1862   1                 }
1863   1                 delayR(10000);
1864   1                 }while(tmp_c0-tmp_c1);
1865   1                 chn_disp (inbuf1,7,0x96);
1866   1                 goto quit;
1867   1               }
1868   1              }
1869   1      
1870   1      
1871   1              
1872   1      
1873   1      
1874   1           if(m==160)
1875   1          {
1876   1           TEC_Temp();
1877   1           Diode_curent_Check();
1878   1           chn_disp (tab6,6,0x80);
1879   1           delayR(500);
1880   1           chn_disp (Diode_parameter,6,0x83);
1881   1           delayR(500);
1882   1           chn_disp (tab7,4,0x90);
1883   1           delayR(500);
1884   1           chn_disp (TEC_parameter,4,0x92);
1885   1           delayR(100);
1886   1           chn_disp (tab11,2,0x94);
1887   1           m=0;
1888   1          }
1889   1      
1890   1      
1891   1      
1892   1      
1893   1      
1894   1      
1895   1      
1896   1             delayR(10000);
1897   1            }while((tmp_c1-tmp_c0)&& SHDN);
1898   1      
1899   1             delayR(180);
1900   1      
1901   1          }
1902   1        else if(tmp_c1<tmp_c0)
1903   1      
1904   1          {
1905   1             do
1906   1            {
1907   1              
1908   1           if(m==160)
1909   1           {
1910   1           Diode_curent_Check();
1911   1           TEC_Temp();
1912   1           chn_disp (tab6,6,0x80);
1913   1           delayR(500);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 32  

1914   1           chn_disp (Diode_parameter,6,0x83);
1915   1           delayR(500);
1916   1           chn_disp (tab7,4,0x90);
1917   1           delayR(500);
1918   1           chn_disp (TEC_parameter,4,0x92);
1919   1           delayR(100);
1920   1           chn_disp (tab11,2,0x94);
1921   1           m=0;
1922   1           }
1923   1           delayR(10000);
1924   1            }while(tmp_c0-tmp_c1);
1925   1      
1926   1           delay(100);
1927   1      
1928   1          }        */
1929   1          Diode_curent_Check();
1930   1      
1931   1      
1932   1          return;
1933   1      
1934   1      }
1935          
1936          /***************************************************************************/
1937          
1938          /*****************************外部AD转换程序*******************************/
1939          uint AD_Convert(uchar Channel)
1940          {
1941   1         uchar i,Dath,Datl,temp,Contbit;
1942   1         uint Dat_ad;
1943   1         Dath=0;
1944   1         Datl=0;
1945   1         temp=0;
1946   1         Dat_ad=0;
1947   1         switch (Channel)                        //  内部REF
1948   1          {
1949   2              case 0:Contbit=0x00;break;
1950   2              case 1:Contbit=0x08;break;
1951   2              case 2:Contbit=0x10;break;
1952   2              case 3:Contbit=0x18;break;
1953   2              case 4:Contbit=0x20;break;
1954   2              case 5:Contbit=0x28;break;
1955   2              case 6:Contbit=0x30;break;
1956   2              case 7:Contbit=0x38;break;
1957   2              default: break;
1958   2          }
1959   1      
1960   1          CSAD=0;
1961   1          _Nop();
1962   1          DCLK=1;
1963   1      
1964   1         for(i=0;i<8;i++)
1965   1         {
1966   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
1967   2      
1968   2            DCLK=0;
1969   2            _Nop();
1970   2            DCLK=1;
1971   2            _Nop();
1972   2      
1973   2         }
1974   1      
1975   1          CSAD=1;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 33  

1976   1          _Nop();
1977   1      
1978   1          CSAD=0;
1979   1          _Nop();
1980   1      
1981   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
1982   1          {
1983   2            ADIN=(bit)(Contbit&(0x80>>i));
1984   2      
1985   2            DCLK=0;
1986   2            _Nop();
1987   2            DCLK=1;
1988   2            _Nop();
1989   2            Dath=DOUT;
1990   2            Dath=Dath<<(7-i);
1991   2            temp=temp|Dath;
1992   2          }
1993   1      
1994   1           Dath=temp;
1995   1           temp=0;
1996   1          for(i=0;i<8;i++)
1997   1          {
1998   2            DCLK=0;
1999   2            _Nop();
2000   2            DCLK=1;
2001   2            Datl=DOUT;
2002   2            Datl=Datl<<(7-i);
2003   2            temp=temp|Datl;
2004   2            _Nop();
2005   2      
2006   2          }
2007   1      
2008   1           Datl=temp;
2009   1           Dat_ad=(Dath*256+Datl)&0x0fff;
2010   1      
2011   1           CSAD=1;
2012   1      
2013   1      
2014   1      
2015   1            _Nop();
2016   1      
2017   1            return(Dat_ad);
2018   1      }
2019          
2020          
2021          
2022          /**************************************************************************/
2023          /*****************************外部PWM设置程序*******************************/
2024          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
2025          { 
2026   1        uint pulserate,pulsewidth,pulsedelay;
2027   1      
2028   1        if (pwm_pulserate>0)
2029   1        {
2030   2          pulserate=1000000/pwm_pulserate/12.5;             //80M晶振
2031   2          RW=1;
2032   2        }
2033   1        
2034   1        if (pwm_pulsewidth>0)
2035   1        {
2036   2          pulsewidth=pwm_pulsewidth   ;      //80M晶振
2037   2        }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 34  

2038   1        
2039   1        if (pwm_pulsedelay>0)
2040   1        {
2041   2          pulsedelay= pwm_pulsedelay ;                 //80M晶振
2042   2      
2043   2      
2044   2      
2045   2        }
2046   1      
2047   1      
2048   1      
2049   1      }
2050          /**************************************************************************/
2051          /*****************************外部DA转换程序*******************************/
2052          void DA_Convert(uchar Channel, uint Dcode)
2053          {
2054   1      
2055   1        uint  Comdat=0;
2056   1         uchar i;
2057   1         switch (Channel)
2058   1          {
2059   2              case 0:Comdat=Dcode+0x1000;break;
2060   2              case 1:Comdat=Dcode+0x5000;break;
2061   2              case 2:Comdat=Dcode+0x9000;break;
2062   2              case 3:Comdat=Dcode+0xd000;break;
2063   2              default: break;
2064   2          }
2065   1      
2066   1          LDAC=1;                               //数据刷新
2067   1          _Nop();
2068   1          CSDA=0;                               //片选有效
2069   1          FS=1;
2070   1          _Nop();
2071   1          FS=0;
2072   1         for(i=0;i<16;i++)
2073   1        {
2074   2             DINDA=(bit)(Comdat&0x8000);
2075   2             SCLK=1;
2076   2             Comdat=Comdat<<1;
2077   2             _Nop();
2078   2             SCLK=0;
2079   2      
2080   2         }
2081   1      
2082   1         LDAC=0;
2083   1         _Nop();
2084   1         CSDA=1;                             //片选无效
2085   1         Dcode=0;
2086   1        return;
2087   1      
2088   1      }
2089          /**************************************************************************/
2090          
2091          
2092          /*****************************单片机内部AD********************************/
2093           void MCU_ADC(BYTE CHN)
2094           {
2095   1          BYTE    AD_finished;
2096   1          switch (CHN)
2097   1          {
2098   2              case 0: P1ASF=0x01;break;
2099   2              case 1: P1ASF=0x02;break;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 35  

2100   2              case 2:P1ASF=0x04;break;
2101   2              case 3:P1ASF=0x08;break;
2102   2              case 7:P1ASF=0x80;break;
2103   2      
2104   2              default: break;
2105   2          }
2106   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
2107   1          ADC_RES=0;
2108   1          ADC_RESL=0;
2109   1      
2110   1          CHN &= 0x07;                        //0000,0111 清0高5位
2111   1      
2112   1          ADC_CONTR =ADC_SPEEDH ;
2113   1          _nop_();
2114   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
2115   1          _nop_();
2116   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
2117   1          delayR(10);
2118   1          ADC_CONTR |= 0x08;
2119   1          delayR(10);
2120   1          AD_finished = 0;
2121   1          while (AD_finished ==0 )            //等待A/D转换结束
2122   1          {
2123   2            AD_finished = (ADC_CONTR & 0x10);
2124   2          }
2125   1          ADC_CONTR &= 0xE7;
2126   1      
2127   1          P1ASF=0x00;
2128   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
2129   1      
2130   1          return;
2131   1       }
2132          
2133          /*************************************************************************/
2134          
2135          
2136          
2137          void Error_Process()
2138          {
2139   1      
2140   1       _Nop();
2141   1       return;
2142   1      
2143   1      }
2144          
2145          
2146          
2147          /*********以下是长延时程序***********************************************/
2148          
2149          void delay(uint delay_k)
2150          {
2151   1          uint k0=0;
2152   1          do
2153   1          {
2154   2          do{k0--;}while(k0);
2155   2          delay_k--;
2156   2          }while(delay_k);
2157   1      
2158   1      }
2159          
2160          /*********以下是短延时程序***********************************************/
2161          void delayR(uint delay_k)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 36  

2162          {
2163   1          do{delay_k--;}while(delay_k);
2164   1      
2165   1      
2166   1      }
2167          
2168          /*********************************************************************/
2169          
2170          /**************************以下是外部中断0程序************************/
2171           void INT_0() interrupt 0 using 0
2172           {
2173   1          if (!LIM1)
2174   1          Error_Process();
2175   1          else  _Nop();
2176   1      
2177   1          if (!LIM2)
2178   1          Error_Process();
2179   1          else  _Nop();
2180   1          return;
2181   1       }
2182          /*********************************************************************/
2183          
2184          /***************************以下是外部中断1程序***********************/
2185          void INT_1() interrupt 2 using 1
2186          {
2187   1        _Nop();
2188   1        //chn_disp (tab16,20,0x80);
2189   1        //delayR(10000);
2190   1        //chn_disp (tab17,20,0x90);
2191   1        //delay(1000);
2192   1      }
2193          /***********************************************************************/
2194          
2195          
2196          
2197          
2198          
2199          /*****************以下是串口中断程序*******************************/
2200          
2201          void RS232() interrupt 4 using 3
2202          {
2203   1      
2204   1         if(RI)
2205   1         {
2206   2              RI=0;
2207   2      
2208   2              if (SBUF==0x0A)
2209   2              {
2210   3                   read_flag=1;
2211   3      
2212   3                }
2213   2      
2214   2              else
2215   2              {
2216   3      
2217   3      
2218   3                   inbuf[t]=SBUF;
2219   3                   t++;
2220   3      
2221   3      
2222   3      
2223   3              }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 37  

2224   2      
2225   2         }
2226   1      
2227   1           return;
2228   1      }
2229          
2230          /**********************************************************************/
2231          
2232          /*****************定时器中断程序*******************************/
2233          
2234          void tm0_isr() interrupt 1 using 1
2235          {               
2236   1           TL0 = 0x30;   //设置定时初值
2237   1           TH0 = 0xF8;   //设置定时初值
2238   1           if (count-- == 0)               //1ms * 1000 -> 1s
2239   1           {
2240   2           count = 1000;               //reset counter
2241   2           }
2242   1      }
2243          
2244          /*************************设置错误***************************/
2245          void setfault()
2246          {
2247   1      
2248   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
2249   1      
2250   1        send_string_com(inbuf1,10);
2251   1      
2252   1        t=0;
2253   1      }
2254          /*************************************************************/
2255          
2256          
2257          /*************************设置成功***************************/
2258          void setsucced()
2259          {
2260   1      
2261   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
2262   1      
2263   1        send_string_com(inbuf1,11);
2264   1        t=0;
2265   1        return;
2266   1      }
2267          /*************************************************************/
2268          
2269          
2270          
2271          
2272          
2273          
2274          /********************************警告*************************/
2275          void alarm()
2276          {
2277   1         uchar t=6;
2278   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
2279   1      
2280   1         send_string_com(inbuf1,7);
2281   1        do
2282   1        {
2283   2         delay(50);
2284   2         t--;
2285   2        }while(t);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 38  

2286   1         send_string_com(inbuf1,5);
2287   1         t=6;
2288   1         do
2289   1        {
2290   2         delay(50);
2291   2         t--;
2292   2        }while(t);
2293   1         send_string_com(inbuf1,5);
2294   1      
2295   1      }
2296          /*************************************************************/
2297          
2298          
2299          
2300          /************************主程序*******************************/
2301          void main()
2302          {
2303   1         uchar  i=10;
2304   1         uchar  tmp0=0;
2305   1      // setsucced();
2306   1      // delay(5000);
2307   1      // setsucced();
2308   1      // delay(5000);
2309   1      // setsucced();
2310   1         stat_initial();                               //状态初始划
2311   1         serial_initial();                             //串口初始化
2312   1      // delay(20000);
2313   1      // setsucced();
2314   1      // delay(5000);
2315   1      // setsucced();
2316   1      // delay(5000);
2317   1      // setsucced();
2318   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2319   1      
2320   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2321   1       {
2322   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2323   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2324   2      
2325   2        DA_Convert(3,25);                          // 种子源
2326   2         _Nop();
2327   2        DA_Convert(3,25);
2328   2      
2329   2        DA_Convert(0,25);                          // 放大级
2330   2         _Nop();
2331   2        DA_Convert(0,25);
2332   2       }
2333   1      //////////////////////////////////////////////////////////////////////////////////////////////
2334   1      
2335   1        else
2336   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2337   1       {
2338   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2339   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
2340   2      
2341   2        DA_Convert(3,88);                            // 种子源
2342   2         _Nop();
2343   2        DA_Convert(3,88);
2344   2      
2345   2        DA_Convert(0,88);                            // 放大级
2346   2        _Nop();
2347   2        DA_Convert(0,88);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 39  

2348   2       }
2349   1      //////////////////////////////////////////////////////////////////////////////////////////////
2350   1      ///////////////////////////////////上电开始显示//////////////////////////////////////////////tang
2351   1       /*  init_lcd ();
2352   1         delay(5);
2353   1         wr_lcd (comm,0x30);
2354   1         delay(30);                                    //需要足够的等待延时
2355   1         chn_disp (tab1,14,0x80);
2356   1         delay(5);
2357   1         chn_disp (tab2,20,0x90);
2358   1         delay(5);
2359   1         clrram();
2360   1         delay(5);
2361   1         chn_disp (tab3,10,0x80);
2362   1         chn_disp (tab4,12,0x90);
2363   1      
2364   1         clrram();
2365   1         delay(10);
2366   1         chn_disp (tab5,10,0x80);
2367   1         delay(5);
2368   1      */////////////////////////////////////////////////////////////////////////////////////////////
2369   1      
2370   1      
2371   1      
2372   1        do
2373   1         {
2374   2      
2375   2           delay(1);
2376   2      
2377   2           if(read_flag)
2378   2            {
2379   3              command();                        //指令识别
2380   3              read_flag=0;                      //取数标志清0
2381   3              t=0;
2382   3            }
2383   2      
2384   2           _Nop();
2385   2      
2386   2      
2387   2          if(Sys_mod)
2388   2       {
2389   3      
2390   3      
2391   3      /***************************检查按键**************************************/
2392   3      
2393   3       // Key_Button();  tang
2394   3      
2395   3      
2396   3      ///////////////////////////////////////////////////////////////////////////
2397   3      
2398   3      /***************************检查当前实际功率值****************************/
2399   3       //Laser_power_Check(); tang
2400   3      
2401   3      
2402   3      /*************************************************************************/
2403   3      /***************************检测当前实际电流值****************************/
2404   3      
2405   3       Diode_curent_Check();
2406   3      
2407   3      
2408   3      
2409   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 40  

2410   3      ///////////////////////////////////////////////////////////////////////////
2411   3      
2412   3      
2413   3      /***************************检测当前冷却温度******************************/
2414   3         TEC_Temp();
2415   3      
2416   3      
2417   3      
2418   3         if(TEC_meds_tempture1>350)
2419   3      
2420   3         {
2421   4      
2422   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2423   4           if(CONT_MOD)
2424   4           {
2425   5           Set_laser_power(0,3);       //tang
2426   5           Set_laser_power(3,3);
2427   5           }
2428   4           else
2429   4           {
2430   5           Set_laser_current(0,30);
2431   5           Set_laser_current(3,30);
2432   5           }
2433   4           SHDN1=0;
2434   4           SHDN2=0;
2435   4           send_string_com(inbuf1,9);
2436   4           t=0;
2437   4      
2438   4         }
2439   3      
2440   3         if(TEC_meds_tempture2>350)
2441   3      
2442   3         {
2443   4      
2444   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2445   4           if(CONT_MOD)
2446   4           {
2447   5           Set_laser_power(0,3);       //tang
2448   5           Set_laser_power(3,3);
2449   5           }
2450   4           else
2451   4           {
2452   5           Set_laser_current(0,30);
2453   5           Set_laser_current(3,30);
2454   5           }
2455   4           SHDN1=0;
2456   4           
2457   4           SHDN2=0;
2458   4           send_string_com(inbuf1,9);
2459   4           t=0;
2460   4         }
2461   3      //////////////////////////////////////////////////////////////////////////
2462   3      
2463   3      
2464   3      /***************************检测监测二极管反馈电压************************/
2465   3      
2466   3       Pdiod_V_Check();
2467   3      
2468   3      
2469   3      
2470   3      //////////////////////////////////////////////////////////////////////////
2471   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 41  

2472   3      
2473   3      /***************************检测TEC温控是否完成**************************/
2474   3      
2475   3      
2476   3      
2477   3      
2478   3      
2479   3      /////////////////////////////////////////////////////////////////////////
2480   3      
2481   3      
2482   3      /***************************检测TEC两端电压是否正常*********************/
2483   3      
2484   3        TEC_V_Check();
2485   3      
2486   3        if( TEC_VO1>3.1) Error_Process();
2487   3        if( TEC_VO2>3.1) Error_Process();
2488   3      
2489   3      ////////////////////////////////////////////////////////////////////////
2490   3      
2491   3      
2492   3      /****************************LCD显示***********************************
2493   3      
2494   3      
2495   3           chn_disp (tab6,4,0x80);
2496   3           delayR(50);
2497   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2498   3           delayR(50);
2499   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2500   3      
2501   3      
2502   3           chn_disp (tab7,4,0x90);
2503   3           delayR(50);
2504   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2505   3           delayR(50);
2506   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2507   3      
2508   3      
2509   3      
2510   3      
2511   3      
2512   3           if(CONT_MOD)
2513   3           {
2514   3              chn_disp (tab14,6,0x87);
2515   3              delayR(50);
2516   3              chn_disp (tab14,6,0x97);
2517   3            }
2518   3           else
2519   3           {
2520   3              chn_disp (tab15,6,0x87);
2521   3              delayR(50);
2522   3              chn_disp (tab15,6,0x97);
2523   3           }
2524   3      
2525   3      //////////////////////////////////////////////////////////////////////*/
2526   3      }
2527   2      
2528   2      else
2529   2      {
2530   3          // chn_disp (tab16,20,0x80);
2531   3         // delayR(10000);
2532   3          // chn_disp (tab17,20,0x90);
2533   3      }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/27/2013 14:13:07 PAGE 42  

2534   2      
2535   2          }while(1);
2536   1      
2537   1      
2538   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8543    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      98
   IDATA SIZE       =    114    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

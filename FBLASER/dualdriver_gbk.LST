C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER_GBK
OBJECT MODULE PLACED IN dualdriver_gbk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver_gbk.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          uint  count=1000;
  23          //uchar code tab1[]={"光纤激光控制器"};
  24          //uchar code tab2[]={"苏州德龙激光有限公司"};
  25          //uchar code tab3[]={"正在初始化"};
  26          //uchar code tab4[]={"请稍候......"};
  27          //uchar code tab5[]={"初始化完成"};
  28          //uchar code tab6[]={"SED:"};
  29          //uchar code tab7[]={"AMP:"};
  30          //uchar code tab8[]={"VOTEC:1.42v"};
  31          //uchar code tab9[]={"设定电流"};
  32          //uchar code tab10[]={"设定温度"};
  33          //uchar code tab11[]={"℃"};
  34          //uchar code tab12[]={"POW:"};
  35          //uchar code tab13[]={"设定功率"};
  36          //uchar code tab14[]={"℃ APC"};
  37          //uchar code tab15[]={"℃ ACC"};
  38          //uchar code tab16[]={"系统采集控制模式中  "};
  39          //uchar code tab17[]={"...................."};
  40          uchar idata  TEC_parameter1[6];
  41          uchar idata  TEC_parameter2[6];
  42          uchar idata  Diode_parameter1[6];
  43          uchar idata  Diode_parameter2[6];
  44          uchar idata  Power_parameter1[6];
  45          uchar idata  Power_parameter2[6];
  46          uchar  set_flag;
  47          
  48          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  49          
  50          uint   idata MCU_AD_code;
  51          uint   idata AD_code;
  52          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  53          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  54          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
  55          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 2   

  56          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  57          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  58          uint   init_current1;                       //种子源初始电流
  59          uint   init_current2;                       //放大级初始电流
  60          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅种子源 3：双路
  61          
  62          uint   idata Laser_Set_power1;             //设定种子源激光功率
  63          uint   idata Laser_Set_power2;             //设定放大级激光功率
  64          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  65          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  66          uint   idata Laser_meds_power1;            //种子源中间设定功率
  67          uint   idata Laser_meds_power2;            //放大级中间设定功率
  68          
  69          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  70          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  71          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  72          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  73          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  74          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  75          
  76          uint   idata Key_V;                         //按键电压
  77          
  78          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  79          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  80          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  81          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  82          
  83          
  84          
  85          uchar  t=0;                                 // 缓冲区数据段
  86          
  87          bit  read_flag=0;                           // 读取标志位
  88          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  89          
  90          
  91          //////////////////////////输入控制位/////////////////////////////////////////////////////
  92          
  93          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  94          
  95          
  96          
  97          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
  98          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
  99          sbit DOUT=P1^6;                      //AD串行输出
 100          
 101          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 102          
 103          //////////////////////////输出控制位/////////////////////////////////////////////////////
 104          sbit LDAC=P2^2;                      //DA装载信号
 105          sbit CSDA=P4^0;                      //DA选通信号
 106          sbit DINDA=P2^1;                     //DA串行数据输入
 107          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 108          sbit SCLK=P2^0;                      //DA时钟输入
 109          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 110          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 111          
 112          sbit FS=P3^7;                        //DA帧信号
 113          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 114          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 115          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
 116          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 117          sbit LIM2=P2^5;                      //激光二极管过流中断信号
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 3   

 118          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 119          sbit DCLK=P1^7;                      //AD时钟信号
 120          sbit ADIN=P1^5;                      //AD串行数据输入
 121          sbit CSAD=P2^4;                      //AD选通信号，L－选通
 122          sbit LCD_BUSY=P0^7;
 123          
 124          
 125          uint AD_Convert(uchar Channel);      //AD转换
 126          void DA_Convert(uchar Channel, uint Dcode);      //DA转换
 127          //void Set_TEC_TEMP(uint tempture);              //设定冷却温度
 128          void Set_laser_current(uchar Channel,uint current);    //设定激光二极管电流
 129          void Set_laser_power(uchar Channel,uint power);        //设定激光功率
 130          void MCU_ADC(BYTE CHN);                      //单片机内部AD转换
 131          //void Key_Button();                           //按键判别
 132          void TEC_V_Check();                          //TEC两端电压
 133          void Diode_curent_Check();                   //激光二极管电流检测
 134          void Laser_power_Check();                    //激光功率检测
 135          void Pdiod_V_Check();                        //激光二极管监测电压
 136          void TEC_Temp();                             //TEC温度
 137          void Error_Process();                        //异常处理
 138          void wr_lcd (uchar dat_comm,uchar content);
 139          //void Lcd_disp();
 140          void Pwm_Set(uint,uint,uint);
 141          void Sdio_check();                     // 加电流时状态检查
 142          
 143          void serial_initial();                 // 串口初始化
 144          void stat_initial();                   // 状态初始化
 145          void INT_0();                          // 外部中断0
 146          void delay(uint);                      // 长延时
 147          void delayR(uint);                     // 短延时
 148          void RS232();                          // 串口中断
 149          
 150          
 151          
 152          void command();                        // 指令判断
 153          void setfault();                       // 设置错误
 154          void setsucced();                      // 设置成功
 155          void alarm();                          // 警告
 156          
 157          
 158          
 159          /***************向串口发送一个字符串*****************/
 160          void send_string_com(uchar *str,uchar strlen)
 161          {
 162   1          uchar k=0;
 163   1          do
 164   1          {
 165   2              SBUF=*(str + k);
 166   2              while(TI==0);
 167   2              TI=0;
 168   2              k++;
 169   2          } while(k < strlen);
 170   1      }
 171          /************************************************************************/
 172          
 173          
 174          
 175          
 176          /***********以下是串口初始化程序********************************************/
 177          void serial_initial()
 178          {
 179   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 4   

 180   1      
 181   1            PCON |= 0x80;             //使能波特率倍速位SMOD
 182   1            SCON = 0x50;              //8位数据,可变波特率
 183   1            BRT = 0x64;               //设定独立波特率发生器重装值
 184   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 185   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 186   1            AUXR |= 0x10;             //启动独立波特率发生器
 187   1      
 188   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 189   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 190   1      
 191   1            IPH=0x14;
 192   1            IP=0x24;
 193   1            ES=1;
 194   1            ET0=1;
 195   1            IT0=1;
 196   1            EX0=1;
 197   1            IT1=1;
 198   1            EX1=1;
 199   1            EA=1;
 200   1            TL0 = 0x30;   //设置定时初值
 201   1            TH0 = 0xF8;   //设置定时初值
 202   1            TF0 = 0;    //清除TF0标志
 203   1            TR0 = 0;    //定时器0开始计时
 204   1      
 205   1            return;
 206   1      }
 207          
 208          /**********************************************************************/
 209          
 210          
 211          
 212          
 213          /***********以下是状态初始化程序*********************************/
 214          void stat_initial()
 215          {
 216   1      
 217   1           ADC_RES=0;
 218   1           ADC_RESL=0;
 219   1      
 220   1           read_flag=0;          //读取标志清零
 221   1           las_di_ok=0;
 222   1           t=0;
 223   1           set_flag=0;
 224   1           Sys_mod=1;
 225   1      
 226   1           AD_code=0;
 227   1      //     Laser_Set_curent=0;
 228   1           Laser_Fed_curent1=0;
 229   1           Laser_Fed_curent2=0;
 230   1           Laser_Fed_power1=0;
 231   1           Laser_Fed_power2=0;
 232   1      
 233   1      /**************DA引脚初始化*************************/
 234   1           CSDA=1;
 235   1           LDAC=1;
 236   1           FS=0;
 237   1           SCLK=0;
 238   1           DINDA=0;
 239   1      /**************************************************/
 240   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
 241   1           _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 5   

 242   1           DA_Convert(2,1273);
 243   1           _Nop();
 244   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
 245   1           _Nop();
 246   1           DA_Convert(1,1273);
 247   1      /**************************************************/
 248   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
 249   1      
 250   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
 251   1       {
 252   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
 253   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
 254   2      
 255   2        DA_Convert(3,25);                          // 种子源
 256   2         _Nop();
 257   2        DA_Convert(3,25);
 258   2      
 259   2        DA_Convert(0,25);                          // 放大级
 260   2         _Nop();
 261   2        DA_Convert(0,25);
 262   2       }
 263   1      //////////////////////////////////////////////////////////////////////////////////////////////
 264   1      
 265   1        else
 266   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
 267   1       {
 268   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
 269   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
 270   2      
 271   2        DA_Convert(3,92);                            // 种子源
 272   2         _Nop();
 273   2        DA_Convert(3,92);
 274   2      
 275   2        DA_Convert(0,89);                            // 放大级
 276   2        _Nop();
 277   2        DA_Convert(0,89);
 278   2       }
 279   1      //////////////////////////////////////////////////////////////////////////////////////////////
 280   1      
 281   1      
 282   1      
 283   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
 284   1           P1M1=0x07;
 285   1           P1M0=0x00;
 286   1      
 287   1           CSAD=1;
 288   1           DCLK=1;
 289   1           DOUT=1;
 290   1      
 291   1      
 292   1      
 293   1      
 294   1      
 295   1      /*************TEC控制器初始化*********************/
 296   1           SHDN1=1;
 297   1      //   TMPGD1=1;
 298   1           LIM1=1;
 299   1      
 300   1           SHDN2=1;
 301   1      //   TMPGD2=1;
 302   1           LIM2=1;
 303   1      /*************************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 6   

 304   1      
 305   1      /*    Power_parameter[0]='P';
 306   1            Power_parameter[1]='O';
 307   1            Power_parameter[2]='W';
 308   1            Power_parameter[3]=':';
 309   1      
 310   1            Diode_parameter[0]='L';
 311   1            Diode_parameter[1]='D';
 312   1            Diode_parameter[2]='C';
 313   1            Diode_parameter[3]=':';
 314   1            Diode_parameter[8]=0x20;
 315   1            Diode_parameter[9]=0x20;
 316   1      
 317   1            TEC_parameter[0]='T';
 318   1            TEC_parameter[1]='E';
 319   1            TEC_parameter[2]='C';
 320   1            TEC_parameter[3]=':';
 321   1      */
 322   1      
 323   1           TR0=0;
 324   1           ET0=0;
 325   1           TR1=0;
 326   1           ET1=0;
 327   1           EX0=0;
 328   1      
 329   1           return;
 330   1      }
 331          
 332          /***************************************************************/
 333          
 334          
 335          /**************************LCD初始化***************************/
 336          void init_lcd (void)
 337          {
 338   1      
 339   1        wr_lcd (comm,0x30);                    //设定工作方式
 340   1        delayR(50000);
 341   1        wr_lcd (comm,0x01);                    //清屏
 342   1        delayR(50000);
 343   1        wr_lcd (comm,0x06);                    //光标的移动方向
 344   1        delayR(50000);
 345   1        wr_lcd (comm,0x0c);                    //开显示
 346   1      }
 347          
 348          /*************************************************************/
 349          /**************************显示汉字或字符*********************/
 350          
 351          void chn_disp (uchar *chn,uchar num,uchar ADRS)
 352          {
 353   1          uchar i=0;
 354   1      //  wr_lcd (comm,0x30);
 355   1      //  delay(5);
 356   1          wr_lcd (comm,ADRS);
 357   1          for (i=0;i<num;i++)
 358   1          wr_lcd (dat,chn[i]);
 359   1          delay(2);
 360   1          return;
 361   1      }
 362          /*************************************************************/
 363          
 364          
 365          /***************************清DDRAM***************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 7   

 366          void clrram (void)
 367          {
 368   1        wr_lcd (comm,0x30);
 369   1        delayR(50000);
 370   1        wr_lcd (comm,0x01);
 371   1      }
 372          /************************************************************/
 373          
 374          
 375          
 376          /**************************判断忙标志位**********************/
 377          void chk_busy (void)
 378          {
 379   1        P0=0xff;
 380   1        _Nop();
 381   1        RS=0;
 382   1        RW=1;
 383   1         _Nop();
 384   1         _Nop();
 385   1         _Nop();
 386   1         _Nop();
 387   1        ENAB=1;
 388   1         _Nop();
 389   1         _Nop();
 390   1         _Nop();
 391   1         _Nop();
 392   1        while(LCD_BUSY==1);
 393   1        _Nop();
 394   1        ENAB=0;
 395   1      }
 396          
 397          /************************************************************/
 398          
 399          /**************************LCD写操作*************************/
 400          void wr_lcd (uchar dat_comm,uchar content)
 401          {
 402   1        chk_busy ();
 403   1        if(dat_comm)
 404   1         {
 405   2          RS=1;                 //data
 406   2          RW=0;                 //write
 407   2         }
 408   1        else
 409   1         {
 410   2          RS=0;                //command
 411   2          RW=0;                //write
 412   2         }
 413   1        P0=content;            
 414   1        _Nop();
 415   1        _Nop();
 416   1        _Nop();
 417   1        _Nop();
 418   1        ENAB=1;
 419   1        _Nop();
 420   1        _Nop();
 421   1        _Nop();
 422   1        _Nop();
 423   1        ENAB=0;
 424   1      }
 425          /************************************************************/
 426          
 427          /****************************操作指令执行***********************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 8   

 428          void command()
 429          {
 430   1      
 431   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
 432   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
 433   1              {
 434   2                 stat_initial();
 435   2                 serial_initial();
 436   2                 setsucced();
 437   2              }
 438   1      
 439   1      ///////////////////////////////////设定电流////////////////////////////////////////////
 440   1             else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='='))
 441   1      
 442   1                 {
 443   2                     uint dio_cu;
 444   2                     uchar CH;
 445   2      
 446   2                     if(inbuf[5]==0x0d)                                        //格式为LD1(2)=N
 447   2                    {
 448   3                       dio_cu=inbuf[4]-48;
 449   3      
 450   3      
 451   3                    }
 452   2                     else if(inbuf[6]==0x0d)                                   //格式为LD1(2)=NN
 453   2                    {
 454   3                       dio_cu=(uint)((inbuf[4]-48)*10+(inbuf[5]-48));
 455   3      
 456   3                    }
 457   2                    else if(inbuf[7]==0x0d)                                    //格式为LD1(2)=NNN
 458   2                    {
 459   3                       dio_cu=(uint)((inbuf[4]-48)*100+(inbuf[5]-48)*10+(inbuf[6]-48));
 460   3      
 461   3                    }
 462   2      
 463   2                    else                                                    //格式为LD1(2)=NNNN
 464   2                    {
 465   3                        setfault();
 466   3                        goto setcf;
 467   3                    }
 468   2      
 469   2                    if(inbuf[2]=='1')
 470   2                    {
 471   3                      CH=3;                                     //种子源SEED
 472   3                      Set_laser_current(CH,dio_cu);
 473   3                      setsucced();
 474   3                    }
 475   2                    else if(inbuf[2]=='2')
 476   2                    {
 477   3                      CH=0;                                    //放大级AMP
 478   3                      Set_laser_current(CH,dio_cu);
 479   3                      setsucced();
 480   3                    }
 481   2                    else setfault();
 482   2      
 483   2      setcf:       _Nop();
 484   2      
 485   2                 }
 486   1      
 487   1      
 488   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
 489   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 9   

 490   1      
 491   1                 {
 492   2                     uint init_current;
 493   2                     uchar CH;
 494   2      
 495   2                     if(inbuf[7]==0x0d)                                        //格式为INIC=N
 496   2                    {
 497   3                       init_current=inbuf[6]-48;
 498   3      
 499   3      
 500   3                    }
 501   2                     else if(inbuf[8]==0x0d)                                   //格式为INIC=NN
 502   2                    {
 503   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 504   3      
 505   3                    }
 506   2                    else if(inbuf[9]==0x0d)                                    //格式为INIC=NNN
 507   2                    {
 508   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 509   3      
 510   3                    }
 511   2      
 512   2                    else                                                    //格式为INIC=NNNN
 513   2                    {
 514   3                        setfault();
 515   3                        goto seticf;
 516   3                    }
 517   2      
 518   2                    if(inbuf[5]=='S')
 519   2                    {
 520   3                      init_current1=init_current;
 521   3                    }
 522   2                    else if(inbuf[5]=='A')
 523   2                    {
 524   3                      init_current2=init_current;
 525   3                    }
 526   2                    else setfault();
 527   2      
 528   2      seticf:       _Nop();
 529   2      
 530   2                 }
 531   1      
 532   1      
 533   1      
 534   1      ///////////////////////////////////设定初始化模式 0/1/2/3 ////////////////////////////////////////////
 535   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
 536   1      
 537   1                 {   
 538   2                     uint init_flag_temp;
 539   2                     uchar CH;
 540   2      
 541   2                     if(inbuf[6]==0x0d)                                        
 542   2                    {
 543   3                       init_flag_temp=inbuf[5]-48;
 544   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
 545   3                        goto setief;
 546   3                      else
 547   3                        init_flag=init_flag_temp;
 548   3                    }
 549   2                    else                                                    
 550   2                    {
 551   3                        setfault();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 10  

 552   3                        goto setief;
 553   3                    }
 554   2      
 555   2      setief:       _Nop();
 556   2      
 557   2                 }
 558   1      
 559   1      
 560   1       //////////////////////////////设定功率//////////////////////////////////////////////////
 561   1              else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 562   1                  {
 563   2                     uint las_pow;
 564   2                     uchar CHH;
 565   2                     if(inbuf[4]==0x0d)                                        //格式为P1(2)=N
 566   2                    {
 567   3                       las_pow=(uint)(inbuf[3]-48);
 568   3      
 569   3                    }
 570   2                     else if(inbuf[5]==0x0d)                                   //格式为P1(2)=NN
 571   2                    {
 572   3                       las_pow=(uint)((inbuf[3]-48)*10+(inbuf[4]-48));
 573   3      
 574   3                    }
 575   2                    else if(inbuf[6]==0x0d)                                    //格式为P1(2)=NNN
 576   2                    {
 577   3                       las_pow=(uint)((inbuf[3]-48)*100+(inbuf[4]-48)*10+(inbuf[5]-48));
 578   3      
 579   3                    }
 580   2      
 581   2                    else                                                      //格式为P1(2)=NNNN
 582   2                    {
 583   3                        setfault();
 584   3                        goto setpf;
 585   3                    }
 586   2      
 587   2                    if(inbuf[2]=='1')
 588   2                    {
 589   3                      CH=3;                                     //种子源SEED
 590   3                      Set_laser_power(CHH,las_pow);
 591   3                      setsucced();
 592   3                    }
 593   2                    else if(inbuf[2]=='2')
 594   2                    {
 595   3                      CH=0;                                    //放大级AMP
 596   3                      Set_laser_power(CHH,las_pow);
 597   3                      setsucced();
 598   3                    }
 599   2                    else setfault();
 600   2      
 601   2      setpf:       _Nop();
 602   2      
 603   2      
 604   2                  }
 605   1       ////////////////////////////////////////////////////////////////////////////////////////
 606   1       //////////////////////////////设定温度//////////////////////////////////////////////////
 607   1              else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 608   1                 {
 609   2                    uint  tmp_tec=0;
 610   2                    uint kt=0;
 611   2                    if(inbuf[5]==0x0d)
 612   2                    {
 613   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 11  

 614   3      
 615   3      
 616   3      
 617   3      
 618   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
 619   3      
 620   3                    }
 621   2                    else if(inbuf[7]==0x0d)
 622   2                    {
 623   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 624   3      
 625   3                       kt=((tmp_tec-15)*691+(inbuf[6]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[6]-48)*59/5+90;
 626   3      
 627   3                    }
 628   2      
 629   2                    else
 630   2                    {
 631   3                       setfault();
 632   3                       goto settf;
 633   3                    }
 634   2      
 635   2                     if(inbuf[1]=='1')
 636   2                    {
 637   3                      DA_Convert(2,kt);                         //种子源SEED
 638   3                      _Nop();
 639   3                      DA_Convert(2,kt);
 640   3                      setsucced();
 641   3                    }
 642   2                    else if(inbuf[1]=='2')
 643   2                    {
 644   3                      DA_Convert(1,kt);                         //放大级AMP
 645   3                      _Nop();
 646   3                      DA_Convert(1,kt);
 647   3                      setsucced();
 648   3                    }
 649   2                    else setfault();
 650   2      
 651   2      settf:       _Nop();
 652   2      
 653   2      
 654   2                 }
 655   1      
 656   1       ////////////////////////////////////////////////////////////////////////////////////////
 657   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
 658   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
 659   1               {
 660   2                     uint pwm_pulserate;
 661   2                   
 662   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
 663   2                    {
 664   3                       pwm_pulserate=inbuf[5]-48;
 665   3      
 666   3      
 667   3                    }
 668   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
 669   2                    {
 670   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 671   3      
 672   3                    }
 673   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 674   2                    {
 675   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 12  

 676   3      
 677   3                    }
 678   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 679   2                    {
 680   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 681   3      
 682   3                    }
 683   2                    else                                                    //格式为PURA=NNNN
 684   2                    {
 685   3                        setfault();
 686   3                        goto setprf;
 687   3                    }
 688   2                      Pwm_Set(1,1,1);
 689   2                      setsucced();
 690   2      setprf:       _Nop();
 691   2      
 692   2                 }
 693   1                ////////////////////////////////////////////////////////////////////////////////////////
 694   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
 695   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
 696   1               {
 697   2                     uint pwm_pulserate;
 698   2                   
 699   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
 700   2                    {
 701   3                       pwm_pulserate=inbuf[5]-48;
 702   3      
 703   3      
 704   3                    }
 705   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
 706   2                    {
 707   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 708   3      
 709   3                    }
 710   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 711   2                    {
 712   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 713   3      
 714   3                    }
 715   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 716   2                    {
 717   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 718   3      
 719   3                    }
 720   2                    else                                                    //格式为PUWI=NNNN
 721   2                    {
 722   3                        setfault();
 723   3                        goto setpwf;
 724   3                    }
 725   2                        Pwm_Set(1,1,1);
 726   2                      setsucced();
 727   2      setpwf:       _Nop();
 728   2      
 729   2                 }
 730   1      
 731   1                 ////////////////////////////////////////////////////////////////////////////////////////
 732   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
 733   1              else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='='))
 734   1               {
 735   2                     uint pwm_pulserate;
 736   2                   
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 13  

 737   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
 738   2                    {
 739   3                       pwm_pulserate=inbuf[5]-48;
 740   3      
 741   3      
 742   3                    }
 743   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
 744   2                    {
 745   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
 746   3      
 747   3                    }
 748   2                    else                                                    //格式为DELY=NNNN
 749   2                    {
 750   3                        setfault();
 751   3                        goto setpdf;
 752   3                    }
 753   2                      Pwm_Set(1,1,1);
 754   2                      setsucced();
 755   2      setpdf:       _Nop();
 756   2      
 757   2                 }
 758   1      
 759   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
 760   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
 761   1      
 762   1                 {
 763   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
 764   2                    {
 765   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
 766   3                       setsucced();
 767   3                    }
 768   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
 769   2                    {
 770   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
 771   3                       setsucced();
 772   3                    }
 773   2                    setfault();
 774   2      
 775   2                 }
 776   1      
 777   1       //////////////////////////////////强制关电流///////////////////////////////////////
 778   1      
 779   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
 780   1      
 781   1                 {
 782   2                    if(inbuf[7]==0x0d)
 783   2                    {
 784   3                       if(inbuf[5]=='S')
 785   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
 786   3                       else  if(inbuf[5]=='A')
 787   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
 788   3                       else
 789   3                        {
 790   4                         setfault();
 791   4                         goto setdf;
 792   4                        }
 793   3                       if (!LIM1)
 794   3                       {
 795   4                         Set_laser_current(3,50);
 796   4                         setsucced();
 797   4                        }
 798   3                       else if(!LIM2)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 14  

 799   3                       {
 800   4                         Set_laser_current(0,50);
 801   4                         setsucced();
 802   4                        }
 803   3                       else
 804   3                        {
 805   4                         setfault();
 806   4                         goto setdf;
 807   4                        }
 808   3                    }
 809   2                    else
 810   2                       setfault();
 811   2      setdf:       _Nop();
 812   2                 }
 813   1      //////////////////////////////////总查询（电流、温度、功率）/////////////////////////////////
 814   1            else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&((inbuf[2]=='A')&&(inbuf[3]=='T'))&&(inbuf[4]=='?'))
 815   1       {
 816   2                    uint ky;
 817   2      //              TEC_Temp();
 818   2                    inbuf[0]= 0x0d;
 819   2                    send_string_com(inbuf,1);
 820   2                      inbuf[0] ='L';
 821   2                      inbuf[1] ='D';
 822   2                      inbuf[2] ='1';
 823   2                      inbuf[3] ='=';
 824   2                  if(Laser_Fed_curent1<10)
 825   2                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 826   3                      inbuf[5]=0x0d;
 827   3                      inbuf[6]=0x0a;
 828   3                      send_string_com(inbuf,7);
 829   3                    }else if (Laser_Fed_curent1<100)
 830   2                    { 
 831   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 832   3                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 833   3                      inbuf[6]=0x0d;
 834   3                      inbuf[7]=0x0a;
 835   3                      send_string_com(inbuf,8);
 836   3                    }else if (Laser_Fed_curent1<1000)
 837   2                    {
 838   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 839   3                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 840   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 841   3                      inbuf[7]=0x0d;
 842   3                      inbuf[8]=0x0a;
 843   3                      send_string_com(inbuf,9);
 844   3                    }
 845   2                    else
 846   2                      setfault();
 847   2      
 848   2                      inbuf[0] ='L';
 849   2                      inbuf[1] ='D';
 850   2                      inbuf[2] ='2';
 851   2                      inbuf[3] ='=';
 852   2                  if(Laser_Fed_curent2<10)
 853   2                    {
 854   3                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 855   3                      inbuf[5]=0x0d;
 856   3                      inbuf[6]=0x0a;
 857   3                      send_string_com(inbuf,7);
 858   3                    }else if (Laser_Fed_curent2<100)
 859   2                    {
 860   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 15  

 861   3                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
 862   3                      inbuf[6]=0x0d;
 863   3                      inbuf[7]=0x0a;
 864   3                      send_string_com(inbuf,8);
 865   3                    }else if (Laser_Fed_curent2<1000)
 866   2                    {
 867   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
 868   3                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 869   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
 870   3                      inbuf[7]=0x0d;
 871   3                      inbuf[8]=0x0a;
 872   3                      send_string_com(inbuf,9);
 873   3                    }
 874   2                    else
 875   2                      setfault();
 876   2                    inbuf[0]= 0x0d;
 877   2                    send_string_com(inbuf,1);
 878   2                      inbuf[0] ='P';
 879   2                      inbuf[1] ='1';
 880   2                      inbuf[2] ='=';
 881   2                if(Laser_Fed_power1<10)
 882   2                    {
 883   3                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
 884   3                      inbuf[4]=0x0d;
 885   3                      inbuf[5]=0x0a;
 886   3                      send_string_com(inbuf,6);
 887   3                    }else if (Laser_Fed_power1<100)
 888   2                    {
 889   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
 890   3                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
 891   3                      inbuf[5]=0x0d;
 892   3                      inbuf[6]=0x0a;
 893   3                      send_string_com(inbuf,7);
 894   3                    }else if (Laser_Fed_power1<1000)
 895   2                    {
 896   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
 897   3                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
 898   3                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
 899   3                      inbuf[6]=0x0d;
 900   3                      inbuf[7]=0x0a;
 901   3                      send_string_com(inbuf,8);
 902   3                    }
 903   2                    else
 904   2                      setfault();
 905   2                      
 906   2                      inbuf[0] ='P';
 907   2                      inbuf[1] ='2';
 908   2                      inbuf[2] ='=';
 909   2                    if(Laser_Fed_power2<10)
 910   2                    {
 911   3                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
 912   3                      inbuf[4]=0x0d;
 913   3                      inbuf[5]=0x0a;
 914   3                      send_string_com(inbuf,6);
 915   3                    }else if (Laser_Fed_power2<100)
 916   2                    {
 917   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
 918   3                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
 919   3                      inbuf[5]=0x0d;
 920   3                      inbuf[6]=0x0a;
 921   3                      send_string_com(inbuf,7);
 922   3                    }else if (Laser_Fed_power2<1000)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 16  

 923   2                    {
 924   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
 925   3                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
 926   3                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
 927   3                      inbuf[6]=0x0d;
 928   3                      inbuf[7]=0x0a;
 929   3                      send_string_com(inbuf,8);
 930   3                    }
 931   2                    else
 932   2                      setfault();
 933   2      
 934   2                      inbuf[0]= 0x0d;
 935   2                      send_string_com(inbuf,1);
 936   2                      ky=(uint)(TEC_Fed_Tempture1);
 937   2                      inbuf[0] ='T';
 938   2                      inbuf[1] ='1';
 939   2                      inbuf[2] ='=';
 940   2                    if (ky<1000)
 941   2                    {
 942   3                      inbuf[3]  =ky/100+48;
 943   3                      inbuf[4]  =(ky/10)%10+48;
 944   3                      inbuf[5]  ='.';
 945   3                      inbuf[6]  =ky%10+48;
 946   3                      inbuf[7] =0x0d;
 947   3                      inbuf[8] =0x0a;
 948   3                      send_string_com(inbuf,9);
 949   3                    }
 950   2                    else
 951   2                     alarm();
 952   2                  
 953   2                     
 954   2                      ky=(uint)(TEC_Fed_Tempture2);
 955   2                      inbuf[0] ='T';
 956   2                      inbuf[1] ='2';
 957   2                      inbuf[2] ='=';
 958   2                    if (ky<1000)
 959   2                    {
 960   3                      inbuf[3]  =ky/100+48;
 961   3                      inbuf[4]  =(ky/10)%10+48;
 962   3                      inbuf[5]  ='.';
 963   3                      inbuf[6]  =ky%10+48;
 964   3                      inbuf[7] =0x0d;
 965   3                      inbuf[8] =0x0a;
 966   3                      send_string_com(inbuf,9);
 967   3                    }
 968   2                    else
 969   2                     alarm();
 970   2                     inbuf[0]= 0x0d;
 971   2                    send_string_com(inbuf,1);
 972   2                   if (TMPGD1)
 973   2                    {
 974   3                      inbuf[0]='T';
 975   3                      inbuf[1]='1';
 976   3                      inbuf[2]='O';
 977   3                      inbuf[3]='K';
 978   3                      inbuf[4]=0x0d;
 979   3                      inbuf[5]=0x0a;
 980   3                      send_string_com(inbuf,6);
 981   3                    }
 982   2      
 983   2                    else
 984   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 17  

 985   3                      inbuf[0]='T';
 986   3                      inbuf[1]='1';
 987   3                      inbuf[2]='N';
 988   3                      inbuf[3]='O';
 989   3                      inbuf[4]=0x0d;
 990   3                      inbuf[5]=0x0a;
 991   3                      send_string_com(inbuf,6);
 992   3                    }
 993   2      
 994   2                    if (TMPGD2)
 995   2                    {
 996   3                      inbuf[0]='T';
 997   3                      inbuf[1]='2';
 998   3                      inbuf[2]='O';
 999   3                      inbuf[3]='K';
1000   3                      inbuf[4]=0x0d;
1001   3                      inbuf[5]=0x0a;
1002   3                      send_string_com(inbuf,6);
1003   3                    }
1004   2      
1005   2                    else
1006   2                    {
1007   3                      inbuf[0]='T';
1008   3                      inbuf[1]='2';
1009   3                      inbuf[2]='N';
1010   3                      inbuf[3]='O';
1011   3                      inbuf[4]=0x0d;
1012   3                      inbuf[5]=0x0a;
1013   3                      send_string_com(inbuf,6);
1014   3                    }
1015   2      }
1016   1      
1017   1      
1018   1      
1019   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
1020   1            else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='?'))
1021   1                 {
1022   2                  if(inbuf[2]=='1')
1023   2                  {   inbuf[0] ='L';
1024   3                      inbuf[1] ='D';
1025   3                      inbuf[2] ='1';
1026   3                      inbuf[3] ='=';
1027   3                  if(Laser_Fed_curent1<10)
1028   3                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
1029   4                      inbuf[5]=0x0d;
1030   4                      inbuf[6]=0x0a;
1031   4                      send_string_com(inbuf,7);
1032   4                    }else if (Laser_Fed_curent1<100)
1033   3                    { 
1034   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
1035   4                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
1036   4                      inbuf[6]=0x0d;
1037   4                      inbuf[7]=0x0a;
1038   4                      send_string_com(inbuf,8);
1039   4                    }else if (Laser_Fed_curent1<1000)
1040   3                    {
1041   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
1042   4                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
1043   4                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
1044   4                      inbuf[7]=0x0d;
1045   4                      inbuf[8]=0x0a;
1046   4                      send_string_com(inbuf,9);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 18  

1047   4                    }
1048   3                    else
1049   3                      setfault();
1050   3      
1051   3                     }
1052   2       //////////////////////////////////////////////////////////
1053   2                  else if(inbuf[2]=='2')
1054   2                    {  inbuf[0] ='L';
1055   3                      inbuf[1] ='D';
1056   3                      inbuf[2] ='2';
1057   3                      inbuf[3] ='=';
1058   3                  if(Laser_Fed_curent2<10)
1059   3                    {
1060   4                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
1061   4                      inbuf[5]=0x0d;
1062   4                      inbuf[6]=0x0a;
1063   4                      send_string_com(inbuf,7);
1064   4                    }else if (Laser_Fed_curent2<100)
1065   3                    {
1066   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
1067   4                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
1068   4                      inbuf[6]=0x0d;
1069   4                      inbuf[7]=0x0a;
1070   4                      send_string_com(inbuf,8);
1071   4                    }else if (Laser_Fed_curent2<1000)
1072   3                    {
1073   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
1074   4                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
1075   4                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
1076   4                      inbuf[7]=0x0d;
1077   4                      inbuf[8]=0x0a;
1078   4                      send_string_com(inbuf,9);
1079   4                    }
1080   3                    else
1081   3                      setfault();
1082   3                 }
1083   2               }
1084   1      
1085   1      
1086   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
1087   1            else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1088   1      
1089   1                 {
1090   2                  if(inbuf[1]=='1')
1091   2                    {
1092   3                     inbuf[0] ='P';
1093   3                      inbuf[1] ='1';
1094   3                      inbuf[2] ='=';
1095   3                    if(Laser_Fed_power1<10)
1096   3                    {
1097   4                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
1098   4                      inbuf[4]=0x0d;
1099   4                      inbuf[5]=0x0a;
1100   4                      send_string_com(inbuf,6);
1101   4                    }else if (Laser_Fed_power1<100)
1102   3                    {
1103   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
1104   4                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
1105   4                      inbuf[5]=0x0d;
1106   4                      inbuf[6]=0x0a;
1107   4                      send_string_com(inbuf,7);
1108   4                    }else if (Laser_Fed_power1<1000)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 19  

1109   3                    {
1110   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
1111   4                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
1112   4                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
1113   4                      inbuf[6]=0x0d;
1114   4                      inbuf[7]=0x0a;
1115   4                      send_string_com(inbuf,8);
1116   4                    }
1117   3                    else
1118   3                      setfault();
1119   3                      
1120   3                    }
1121   2                    else if(inbuf[1]=='2')
1122   2                     {
1123   3                      inbuf[0] ='P';
1124   3                      inbuf[1] ='2';
1125   3                      inbuf[2] ='=';
1126   3                    if(Laser_Fed_power2<10)
1127   3                    {
1128   4                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
1129   4                      inbuf[4]=0x0d;
1130   4                      inbuf[5]=0x0a;
1131   4                      send_string_com(inbuf,6);
1132   4                    }else if (Laser_Fed_power2<100)
1133   3                    {
1134   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
1135   4                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
1136   4                      inbuf[5]=0x0d;
1137   4                      inbuf[6]=0x0a;
1138   4                      send_string_com(inbuf,7);
1139   4                    }else if (Laser_Fed_power2<1000)
1140   3                    {
1141   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
1142   4                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
1143   4                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
1144   4                      inbuf[6]=0x0d;
1145   4                      inbuf[7]=0x0a;
1146   4                      send_string_com(inbuf,8);
1147   4                    }
1148   3                    else
1149   3                      setfault();
1150   3                  }
1151   2                 }
1152   1      
1153   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
1154   1            else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1155   1                 {
1156   2      
1157   2                    uint ky;
1158   2      //              TEC_Temp();
1159   2                    if (inbuf[1]=='1')
1160   2                    {  ky=(uint)(TEC_Fed_Tempture1);
1161   3                      inbuf[0] ='T';
1162   3                      inbuf[1] ='1';
1163   3                      inbuf[2] ='=';
1164   3                    if (ky<1000)
1165   3                    {
1166   4                      inbuf[3]  =ky/100+48;
1167   4                      inbuf[4]  =(ky/10)%10+48;
1168   4                      inbuf[5]  ='.';
1169   4                      inbuf[6]  =ky%10+48;
1170   4                      inbuf[7] =0x0d;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 20  

1171   4                      inbuf[8] =0x0a;
1172   4                      send_string_com(inbuf,9);
1173   4                    }
1174   3                    else
1175   3                     alarm();  
1176   3                    }
1177   2                  else if (inbuf[1]=='2')
1178   2                    { 
1179   3                      ky=(uint)(TEC_Fed_Tempture2);
1180   3                      inbuf[0] ='T';
1181   3                      inbuf[1] ='2';
1182   3                      inbuf[2] ='=';
1183   3                    if (ky<1000)
1184   3                    {
1185   4                      inbuf[3]  =ky/100+48;
1186   4                      inbuf[4]  =(ky/10)%10+48;
1187   4                      inbuf[5]  ='.';
1188   4                      inbuf[6]  =ky%10+48;
1189   4                      inbuf[7] =0x0d;
1190   4                      inbuf[8] =0x0a;
1191   4                      send_string_com(inbuf,9);
1192   4                    }
1193   3                    else
1194   3                     alarm();
1195   3                 }
1196   2               }
1197   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
1198   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1199   1      
1200   1                 {
1201   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1202   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1203   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1204   2      
1205   2                    inbuf[4]='S';
1206   2                    inbuf[5]='=';
1207   2                    inbuf[6]=inbuf[6]+48;
1208   2                    inbuf[7]='.';
1209   2                    inbuf[8]=inbuf[8]+48;
1210   2                    inbuf[9]=inbuf[9]+48;
1211   2                    inbuf[10]=0x0d;
1212   2                    inbuf[11]=0x0a;
1213   2      
1214   2                    send_string_com(inbuf,12);
1215   2      
1216   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1217   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1218   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1219   2      
1220   2                    inbuf[4]='A';
1221   2                    inbuf[5]='=';
1222   2                    inbuf[6]=inbuf[6]+48;
1223   2                    inbuf[7]='.';
1224   2                    inbuf[8]=inbuf[8]+48;
1225   2                    inbuf[9]=inbuf[9]+48;
1226   2                    inbuf[10]=0x0d;
1227   2                    inbuf[11]=0x0a;
1228   2      
1229   2                    send_string_com(inbuf,12);
1230   2      
1231   2      
1232   2                 }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 21  

1233   1      
1234   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1235   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1236   1      
1237   1                 {
1238   2      
1239   2      
1240   2      
1241   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1242   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1243   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1244   2      
1245   2                    inbuf[4]='S';
1246   2                    inbuf[5]='=';
1247   2                    inbuf[6]=inbuf[6]+48;
1248   2                    inbuf[7]='.';
1249   2                    inbuf[8]=inbuf[8]+48;
1250   2                    inbuf[9]=inbuf[9]+48;
1251   2                    inbuf[10]=0x0d;
1252   2                    inbuf[11]=0x0a;
1253   2      
1254   2                    send_string_com(inbuf,12);
1255   2      
1256   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1257   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1258   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1259   2      
1260   2                    inbuf[4]='A';
1261   2                    inbuf[5]='=';
1262   2                    inbuf[6]=inbuf[6]+48;
1263   2                    inbuf[7]='.';
1264   2                    inbuf[8]=inbuf[8]+48;
1265   2                    inbuf[9]=inbuf[9]+48;
1266   2                    inbuf[10]=0x0d;
1267   2                    inbuf[11]=0x0a;
1268   2      
1269   2                    send_string_com(inbuf,12);
1270   2      
1271   2                 }
1272   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1273   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1274   1      
1275   1                 {
1276   2                    if (TMPGD1)
1277   2                    {
1278   3                      inbuf[4]='S';
1279   3                      inbuf[5]=' ';
1280   3                      inbuf[6]='O';
1281   3                      inbuf[7]='K';
1282   3                      inbuf[8]=0x0d;
1283   3                      inbuf[9]=0x0a;
1284   3                      send_string_com(inbuf,10);
1285   3                    }
1286   2      
1287   2                    else
1288   2                    {
1289   3                      inbuf[4]='S';
1290   3                      inbuf[5]=' ';
1291   3                      inbuf[6]='N';
1292   3                      inbuf[7]='O';
1293   3                      inbuf[8]=0x0d;
1294   3                      inbuf[9]=0x0a;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 22  

1295   3                      send_string_com(inbuf,10);
1296   3                    }
1297   2      
1298   2                    if (TMPGD2)
1299   2                    {
1300   3                      inbuf[4]='A';
1301   3                      inbuf[5]=' ';
1302   3                      inbuf[6]='O';
1303   3                      inbuf[7]='K';
1304   3                      inbuf[8]=0x0d;
1305   3                      inbuf[9]=0x0a;
1306   3                      send_string_com(inbuf,10);
1307   3                    }
1308   2      
1309   2                    else
1310   2                    {
1311   3                      inbuf[4]='A';
1312   3                      inbuf[5]=' ';
1313   3                      inbuf[6]='N';
1314   3                      inbuf[7]='O';
1315   3                      inbuf[8]=0x0d;
1316   3                      inbuf[9]=0x0a;
1317   3                      send_string_com(inbuf,10);
1318   3                    }
1319   2      
1320   2                 }
1321   1      
1322   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1323   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1324   1      
1325   1                 {
1326   2                    if (SHDN1)
1327   2                    {
1328   3                      inbuf[0]='T';
1329   3                      inbuf[1]='E';
1330   3                      inbuf[2]='C';
1331   3                      inbuf[3]='1';
1332   3                      inbuf[4]=' ';
1333   3                      inbuf[5]='O';
1334   3                      inbuf[6]='N';
1335   3                      inbuf[7]=0x0d;
1336   3                      inbuf[8]=0x0a;
1337   3                      send_string_com(inbuf,9);
1338   3                    }
1339   2      
1340   2                    else
1341   2                    {
1342   3                      inbuf[0]='T';
1343   3                      inbuf[1]='E';
1344   3                      inbuf[2]='C';
1345   3                      inbuf[3]='1';
1346   3                      inbuf[4]=' ';
1347   3                      inbuf[5]='O';
1348   3                      inbuf[6]='F';
1349   3                      inbuf[7]='F';
1350   3                      inbuf[8]=0x0d;
1351   3                      inbuf[9]=0x0a;
1352   3                      send_string_com(inbuf,10);
1353   3                    }
1354   2      
1355   2                    if (SHDN2)
1356   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 23  

1357   3                      inbuf[0]='T';
1358   3                      inbuf[1]='E';
1359   3                      inbuf[2]='C';
1360   3                      inbuf[3]='2';
1361   3                      inbuf[4]=' ';
1362   3                      inbuf[5]='O';
1363   3                      inbuf[6]='N';
1364   3                      inbuf[7]=0x0d;
1365   3                      inbuf[8]=0x0a;
1366   3                      send_string_com(inbuf,9);
1367   3                    }
1368   2      
1369   2                    else
1370   2                    {
1371   3                      inbuf[0]='T';
1372   3                      inbuf[1]='E';
1373   3                      inbuf[2]='C';
1374   3                      inbuf[3]='2';
1375   3                      inbuf[4]=' ';
1376   3                      inbuf[5]='O';
1377   3                      inbuf[6]='F';
1378   3                      inbuf[7]='F';
1379   3                      inbuf[8]=0x0d;
1380   3                      inbuf[9]=0x0a;
1381   3                      send_string_com(inbuf,10);
1382   3                    }
1383   2                 }
1384   1      
1385   1      ///////////////////////////////////////////////////////////////////////////////////
1386   1      
1387   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1388   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1389   1      
1390   1                 {
1391   2                    if (CONT_MOD)
1392   2                    {
1393   3                      inbuf[0]='M';
1394   3                      inbuf[1]='O';
1395   3                      inbuf[2]='D';
1396   3                      inbuf[3]='=';
1397   3                      inbuf[4]='A';
1398   3                      inbuf[5]='P';
1399   3                      inbuf[6]='C';
1400   3                      inbuf[7]=0x0d;
1401   3                      inbuf[8]=0x0a;
1402   3                      send_string_com(inbuf,9);
1403   3                    }
1404   2      
1405   2                    else
1406   2                    {
1407   3                      inbuf[0]='M';
1408   3                      inbuf[1]='O';
1409   3                      inbuf[2]='D';
1410   3                      inbuf[3]='=';
1411   3                      inbuf[4]='A';
1412   3                      inbuf[5]='C';
1413   3                      inbuf[6]='C';
1414   3                      inbuf[7]=0x0d;
1415   3                      inbuf[8]=0x0a;
1416   3                      send_string_com(inbuf,9);
1417   3                    }
1418   2                 }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 24  

1419   1      
1420   1      
1421   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1422   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1423   1            {
1424   2                 if(inbuf[6]==0x0d)
1425   2                    {
1426   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1427   3                       setsucced();
1428   3                    }
1429   2                 else
1430   2                    setfault();
1431   2            }
1432   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1433   1      
1434   1            else
1435   1             setfault();                              //设置错误
1436   1      
1437   1      
1438   1      
1439   1           return;
1440   1      
1441   1      }
*** WARNING C280 IN LINE 493 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
*** WARNING C280 IN LINE 539 OF DUALDRIVER_GBK.C: 'CH': unreferenced local variable
1442          /*******************************************************************************/
1443          
1444          
1445          
1446          
1447          
1448          /*****************************设置显示****************************************
1449          void Lcd_disp()
1450          {
1451           wr_lcd (comm,0x30);                    //设定工作方式
1452           delay(1);
1453           wr_lcd (comm,0x01);                    //清屏
1454           delay(1);
1455           wr_lcd (comm,0x0d);                    //开显示
1456           delay(1);
1457           wr_lcd (comm,0x10);
1458           delay(30);
1459          
1460           if(CONT_MOD)                          //CONT_MOD: 1 APC, 0 ACC
1461          
1462          //*****************APC模式显示设定功率*********************************
1463           {
1464             chn_disp (tab13,8,0x80);
1465             delayR(50);
1466             chn_disp (Power_parameter1,6,0x84);
1467           }
1468          
1469          //********************************************************************
1470           else
1471          //****************ACC模式显示电流设定**********************************
1472           {
1473            chn_disp (tab9,8,0x80);
1474            delayR(50);
1475            chn_disp (Diode_parameter1,6,0x84);
1476          
1477           }
1478          //*********************************************************************
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 25  

1479          
1480           delayR(50);
1481          
1482          //*****************显示设定温度****************************************
1483          
1484           delayR(50);
1485           chn_disp (TEC_parameter1,4,0x94);
1486           delayR(50);
1487           chn_disp (tab11,2,0x96);
1488           delayR(50);
1489          // wr_lcd (comm,0x90);
1490          //********************************************************************
1491          
1492          }
1493          /**************************************************************************
1494          
1495          
1496          /*****************************判断按键电压*********************************
1497          void Key_Button()
1498          {
1499            uchar kk=10;
1500            uchar tec_a=0;
1501            uchar tec_b=0;
1502            Key_V=0;
1503          
1504          
1505          
1506          
1507            return;
1508          }
1509          
1510          /**************************************************************************/
1511          
1512          /**********************二极管电流监测**************************************/
1513          void Diode_curent_Check()
1514          {
1515   1          uchar k=16;
1516   1      //    float a,b;
1517   1          AD_inbuf[0]=0;
1518   1          AD_inbuf[1]=0;
1519   1          do
1520   1          {
1521   2            AD_code=AD_Convert(0);                  //种子源电流
1522   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
1523   2      
1524   2            AD_code=AD_Convert(3);                  //放大级电流
1525   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
1526   2      
1527   2            k--;
1528   2          }while(k);
1529   1      
1530   1      
1531   1          AD_inbuf[0]=AD_inbuf[0]/16;
1532   1          AD_inbuf[1]=AD_inbuf[1]/16;
1533   1      
1534   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
1535   1          Laser_meds_curent1=Laser_Fed_curent1;
1536   1          if (Laser_Fed_curent1<10)
1537   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
1538   2              Diode_parameter1[1]=0x6d;
1539   2              Diode_parameter1[2]=0x41;
1540   2              Diode_parameter1[3]=0x20;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 26  

1541   2              Diode_parameter1[4]=0x20;
1542   2      
1543   2            } else if(Laser_Fed_curent1<100)
1544   1      
1545   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
1546   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
1547   2              Diode_parameter1[2]=0x6d;
1548   2              Diode_parameter1[3]=0x41;
1549   2              Diode_parameter1[4]=0x20;
1550   2            } else if(Laser_Fed_curent1<1000)
1551   1      
1552   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
1553   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
1554   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
1555   2              Diode_parameter1[3]=0x6d;
1556   2              Diode_parameter1[4]=0x41;
1557   2            }
1558   1      
1559   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
1560   1          Laser_meds_curent2=Laser_Fed_curent2;
1561   1          if (Laser_Fed_curent2<10)
1562   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
1563   2              Diode_parameter2[1]=0x6d;
1564   2              Diode_parameter2[2]=0x41;
1565   2              Diode_parameter2[3]=0x20;
1566   2              Diode_parameter2[4]=0x20;
1567   2      
1568   2            } else if(Laser_Fed_curent2<100)
1569   1      
1570   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
1571   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
1572   2              Diode_parameter2[2]=0x6d;
1573   2              Diode_parameter2[3]=0x41;
1574   2              Diode_parameter2[4]=0x20;
1575   2            } else if(Laser_Fed_curent2<1000)
1576   1      
1577   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
1578   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
1579   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
1580   2              Diode_parameter2[3]=0x6d;
1581   2              Diode_parameter2[4]=0x41;
1582   2            }
1583   1      
1584   1          return;
1585   1      }
1586          /**************************************************************************/
1587          /*****************************激光功率检测*********************************/
1588          void Laser_power_Check()
1589          {
1590   1      
1591   1          uchar k=10;
1592   1          float a,b;
1593   1          AD_inbuf[8]=0;
1594   1          AD_inbuf[9]=0;
1595   1          do
1596   1          {
1597   2            AD_code=AD_Convert(1);                  //种子源
1598   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
1599   2      
1600   2            AD_code=AD_Convert(4);                  //放大级
1601   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
1602   2            k--;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 27  

1603   2          }while(k);
1604   1      
1605   1      
1606   1      
1607   1          AD_inbuf[8]=AD_inbuf[8]/10;
1608   1          AD_inbuf[9]=AD_inbuf[9]/10;
1609   1      
1610   1          AD_code=AD_inbuf[8];
1611   1          a=(float)(AD_code);
1612   1          a=a*2.5;
1613   1          a=a/4096+0.02015;
1614   1          b=a*a*117.314+275.543*a-0.806;
1615   1      
1616   1          Laser_Fed_power1=(uint)(b);
1617   1          Laser_meds_power1=Laser_Fed_power1;
1618   1      
1619   1          if (Laser_Fed_power1<10)
1620   1            { Power_parameter1[0]=Laser_Fed_power1+48;
1621   2              Power_parameter1[1]=0x6d;
1622   2              Power_parameter1[2]=0x77;
1623   2              Power_parameter1[3]=0x20;
1624   2              Power_parameter1[4]=0x20;
1625   2              Power_parameter1[5]=0x20;
1626   2      
1627   2            } else if(Laser_Fed_power1<100)
1628   1      
1629   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
1630   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
1631   2              Power_parameter1[2]=0x6d;
1632   2              Power_parameter1[3]=0x77;
1633   2              Power_parameter1[4]=0x20;
1634   2              Power_parameter1[5]=0x20;
1635   2            } else if(Laser_Fed_power1<1000)
1636   1      
1637   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
1638   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
1639   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
1640   2              Power_parameter1[3]=0x6d;
1641   2              Power_parameter1[4]=0x77;
1642   2              Power_parameter1[5]=0x20;
1643   2            }
1644   1      
1645   1          AD_code=AD_inbuf[9];
1646   1          a=(float)(AD_code);
1647   1          a=a*2.5;
1648   1          a=a/4096+0.02015;
1649   1          b=a*a*117.314+275.543*a-0.806;
1650   1      
1651   1          Laser_Fed_power2=(uint)(b);
1652   1          Laser_meds_power2=Laser_Fed_power2;
1653   1      
1654   1          if (Laser_Fed_power2<10)
1655   1            { Power_parameter2[0]=Laser_Fed_power2+48;
1656   2              Power_parameter2[1]=0x6d;
1657   2              Power_parameter2[2]=0x77;
1658   2              Power_parameter2[3]=0x20;
1659   2              Power_parameter2[4]=0x20;
1660   2              Power_parameter2[5]=0x20;
1661   2      
1662   2            } else if(Laser_Fed_power2<100)
1663   1      
1664   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 28  

1665   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
1666   2              Power_parameter2[2]=0x6d;
1667   2              Power_parameter2[3]=0x77;
1668   2              Power_parameter2[4]=0x20;
1669   2              Power_parameter2[5]=0x20;
1670   2            } else if(Laser_Fed_power2<1000)
1671   1      
1672   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
1673   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
1674   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
1675   2              Power_parameter2[3]=0x6d;
1676   2              Power_parameter2[4]=0x77;
1677   2              Power_parameter2[5]=0x20;
1678   2            }
1679   1      
1680   1          return;
1681   1      
1682   1      
1683   1      
1684   1      }
1685          /**************************************************************************/
1686          
1687          
1688          /*****************************当前冷却温度*********************************/
1689          void TEC_Temp()
1690          {
1691   1          uint  tx1=0;
1692   1          uint  tx2=0;
1693   1          uchar kt=16;
1694   1          AD_inbuf[6]=0;
1695   1          AD_inbuf[7]=0;
1696   1          do
1697   1          {
1698   2            AD_code=AD_Convert(2);        //种子源TEC温度
1699   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
1700   2      
1701   2            AD_code=AD_Convert(5);        //放大级TEC温度
1702   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
1703   2            kt--;
1704   2          }while(kt);
1705   1      
1706   1           AD_inbuf[6]=AD_inbuf[6]/16;
1707   1           AD_inbuf[7]=AD_inbuf[7]/16;
1708   1           TEC_meds_tempture1=AD_inbuf[6];
1709   1           TEC_meds_tempture2=AD_inbuf[7];
1710   1      
1711   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
1712   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
1713   1           tx1= (uint)(TEC_Fed_Tempture1);
1714   1           TEC_meds_tempture1=tx1;
1715   1           tx2= (uint)(TEC_Fed_Tempture2);
1716   1           TEC_meds_tempture2=tx2;
1717   1      
1718   1           TEC_parameter1[0]=tx1 /100+48;
1719   1           TEC_parameter1[1]=(tx1 /10)%10+48;
1720   1           TEC_parameter1[2]=0x2e;
1721   1           TEC_parameter1[3]=tx1 %10+48;
1722   1      
1723   1      
1724   1           TEC_parameter2[0]=tx2 /100+48;
1725   1           TEC_parameter2[1]=(tx2 /10)%10+48;
1726   1           TEC_parameter2[2]=0x2e;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 29  

1727   1           TEC_parameter2[3]=tx2 %10+48;
1728   1      
1729   1      
1730   1        return;
1731   1      }
1732          
1733          /**************************************************************************/
1734          
1735          /*****************************当前TEC两端电压******************************/
1736          void TEC_V_Check()                                                 //???????????????????????
1737          {
1738   1          uchar kk=20;
1739   1          AD_inbuf[4]=0;
1740   1          AD_inbuf[5]=0;
1741   1          do
1742   1          {
1743   2            MCU_ADC(1);
1744   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
1745   2            MCU_ADC(2);
1746   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
1747   2            kk--;
1748   2          }while(kk);
1749   1      
1750   1      
1751   1           TEC_VO1=AD_inbuf[4]/20 ;
1752   1           TEC_VO1=TEC_VO1*5;
1753   1           TEC_VO2=AD_inbuf[4]/20 ;
1754   1           TEC_VO2=TEC_VO2*5;
1755   1      
1756   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
1757   1      //     TEC_parameter[1]=0x2e;
1758   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
1759   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
1760   1      //     TEC_parameter[4]=0xa0;
1761   1      //     TEC_parameter[5]=0x56;
1762   1          return;
1763   1      }
1764          
1765          /**************************************************************************/
1766          
1767          /*****************************监测二极管电压******************************/
1768          void Pdiod_V_Check()
1769          {
1770   1          uchar kk=10;
1771   1          AD_inbuf[2]=0;
1772   1          AD_inbuf[3]=0;
1773   1          do
1774   1          {
1775   2            AD_code=AD_Convert(1);             //种子源激光二极管
1776   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
1777   2      
1778   2            AD_code=AD_Convert(4);             //放大级激光二极管
1779   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
1780   2            kk--;
1781   2          }while(kk);
1782   1      
1783   1           PDiode_V1= AD_inbuf[2]/10;
1784   1           PDiode_V2= AD_inbuf[3]/10;
1785   1           PDiode_V1=(PDiode_V1*5)/2;
1786   1           PDiode_V2=(PDiode_V2*5)/2;
1787   1          return;
1788   1      }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 30  

1789          /**************************************************************************/
1790          
1791          
1792          
1793          /*******************************设定温度值*************************************
1794          
1795          void Set_TEC_TEMP(uint tempture)
1796          {
1797               uint kt;
1798          
1799                kt=(uint)((tempture-15)*4096/35);
1800                DA_Convert(1,kt);
1801          
1802          
1803          
1804          
1805             return;
1806          }
1807          
1808          
1809          /******************************************************************************/
1810          
1811          /*****************************设定功率值**********************************/
1812          void Set_laser_power(uchar Channel,uint power)
1813          {
1814   1        float  u,v;
1815   1        uint   temp_p;
1816   1      
1817   1        if (power<3) power=3;
1818   1        if (power>600) power=600;
1819   1        u=(float)(power);
1820   1        v=(u*u/1000)*3.46;
1821   1        v=6.5068*u+29.61-v;
1822   1        temp_p=(uint)(v);
1823   1      
1824   1      
1825   1        if(Channel==3)                                         //设定种子源功率
1826   1        {
1827   2      
1828   2          if(SHDN1)
1829   2           {
1830   3      
1831   3                DA_Convert(3,temp_p);
1832   3                _Nop();
1833   3                DA_Convert(3,temp_p);
1834   3           }
1835   2      
1836   2           Laser_Set_power1=power;
1837   2         }
1838   1      
1839   1      
1840   1          else if(Channel==0)
1841   1        {
1842   2      
1843   2          if(SHDN2)                                             //设定放大级功率
1844   2           {
1845   3      
1846   3                DA_Convert(0,temp_p);
1847   3                _Nop();
1848   3                DA_Convert(0,temp_p);
1849   3           }
1850   2      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 31  

1851   2           Laser_Set_power2=power;
1852   2         }
1853   1      
1854   1         else  _Nop();
1855   1      
1856   1         Laser_power_Check();
1857   1      
1858   1      
1859   1          return;
1860   1      
1861   1      }
1862          
1863          
1864          /*************************************************************************/
1865          
1866          /*****************************设定电流值**********************************/
1867          
1868          void Set_laser_current(uchar Channel,uint current)
1869          {
1870   1      
1871   1          uint tmp_c1;
1872   1      
1873   1          if (current<30) current=30;
1874   1          if (current>900) current=900;
1875   1      
1876   1      
1877   1      
1878   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
1879   1      
1880   1      
1881   1      
1882   1      
1883   1      
1884   1          if(Channel==3)
1885   1          {
1886   2             if(SHDN1)
1887   2             {
1888   3      
1889   3                  DA_Convert(3,tmp_c1);
1890   3                  _Nop();
1891   3                  DA_Convert(3,tmp_c1);
1892   3      
1893   3                  Laser_Set_curent1=current;
1894   3             }
1895   2      
1896   2             _Nop();
1897   2          }
1898   1      
1899   1          else if(Channel==0)
1900   1          {
1901   2             if(SHDN2)
1902   2             {
1903   3      
1904   3                  DA_Convert(0,tmp_c1);
1905   3                  _Nop();
1906   3                  DA_Convert(0,tmp_c1);
1907   3      
1908   3                  Laser_Set_curent2=current;
1909   3             }
1910   2      
1911   2             _Nop();
1912   2          }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 32  

1913   1      
1914   1      
1915   1      
1916   1      
1917   1      /*
1918   1        if (tmp_c1>tmp_c0)
1919   1          {
1920   1            do
1921   1            {
1922   1      
1923   1              while(!TMPGD)
1924   1              {
1925   1                TEC_Temp();
1926   1                if(tx>280)
1927   1              {
1928   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
1929   1                send_string_com(inbuf1,9);
1930   1                t=0;
1931   1                SHDN=0;
1932   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
1933   1                tmp_c1=246;
1934   1                Laser_Set_curent=30;
1935   1                 do
1936   1               {
1937   1                tmp_c0=tmp_c0-2;
1938   1                DA_Convert(0,tmp_c0);
1939   1                m++;
1940   1      
1941   1                 if(m==240)
1942   1                 {
1943   1                  Diode_curent_Check();
1944   1                  TEC_Temp();
1945   1                  chn_disp (tab6,6,0x80);
1946   1                  delayR(500);
1947   1                  chn_disp (Diode_parameter,6,0x83);
1948   1                  delayR(500);
1949   1                  chn_disp (tab7,4,0x90);
1950   1                  delayR(500);
1951   1                  chn_disp (TEC_parameter,4,0x92);
1952   1                  delayR(100);
1953   1                  chn_disp (tab11,2,0x94);
1954   1                  m=0;
1955   1                 }
1956   1                 delayR(10000);
1957   1                 }while(tmp_c0-tmp_c1);
1958   1                 chn_disp (inbuf1,7,0x96);
1959   1                 goto quit;
1960   1               }
1961   1              }
1962   1      
1963   1      
1964   1              
1965   1      
1966   1      
1967   1           if(m==160)
1968   1          {
1969   1           TEC_Temp();
1970   1           Diode_curent_Check();
1971   1           chn_disp (tab6,6,0x80);
1972   1           delayR(500);
1973   1           chn_disp (Diode_parameter,6,0x83);
1974   1           delayR(500);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 33  

1975   1           chn_disp (tab7,4,0x90);
1976   1           delayR(500);
1977   1           chn_disp (TEC_parameter,4,0x92);
1978   1           delayR(100);
1979   1           chn_disp (tab11,2,0x94);
1980   1           m=0;
1981   1          }
1982   1      
1983   1      
1984   1      
1985   1      
1986   1      
1987   1      
1988   1      
1989   1             delayR(10000);
1990   1            }while((tmp_c1-tmp_c0)&& SHDN);
1991   1      
1992   1             delayR(180);
1993   1      
1994   1          }
1995   1        else if(tmp_c1<tmp_c0)
1996   1      
1997   1          {
1998   1             do
1999   1            {
2000   1              
2001   1           if(m==160)
2002   1           {
2003   1           Diode_curent_Check();
2004   1           TEC_Temp();
2005   1           chn_disp (tab6,6,0x80);
2006   1           delayR(500);
2007   1           chn_disp (Diode_parameter,6,0x83);
2008   1           delayR(500);
2009   1           chn_disp (tab7,4,0x90);
2010   1           delayR(500);
2011   1           chn_disp (TEC_parameter,4,0x92);
2012   1           delayR(100);
2013   1           chn_disp (tab11,2,0x94);
2014   1           m=0;
2015   1           }
2016   1           delayR(10000);
2017   1            }while(tmp_c0-tmp_c1);
2018   1      
2019   1           delay(100);
2020   1      
2021   1          }        */
2022   1          Diode_curent_Check();
2023   1      
2024   1      
2025   1          return;
2026   1      
2027   1      }
2028          
2029          /***************************************************************************/
2030          
2031          /*****************************外部AD转换程序*******************************/
2032          uint AD_Convert(uchar Channel)
2033          {
2034   1         uchar i,Dath,Datl,temp,Contbit;
2035   1         uint Dat_ad;
2036   1         Dath=0;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 34  

2037   1         Datl=0;
2038   1         temp=0;
2039   1         Dat_ad=0;
2040   1         switch (Channel)                        //  内部REF
2041   1          {
2042   2              case 0:Contbit=0x00;break;
2043   2              case 1:Contbit=0x08;break;
2044   2              case 2:Contbit=0x10;break;
2045   2              case 3:Contbit=0x18;break;
2046   2              case 4:Contbit=0x20;break;
2047   2              case 5:Contbit=0x28;break;
2048   2              case 6:Contbit=0x30;break;
2049   2              case 7:Contbit=0x38;break;
2050   2              default: break;
2051   2          }
2052   1      
2053   1          CSAD=0;
2054   1          _Nop();
2055   1          DCLK=1;
2056   1      
2057   1         for(i=0;i<8;i++)
2058   1         {
2059   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
2060   2      
2061   2            DCLK=0;
2062   2            _Nop();
2063   2            DCLK=1;
2064   2            _Nop();
2065   2      
2066   2         }
2067   1      
2068   1          CSAD=1;
2069   1          _Nop();
2070   1      
2071   1          CSAD=0;
2072   1          _Nop();
2073   1      
2074   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
2075   1          {
2076   2            ADIN=(bit)(Contbit&(0x80>>i));
2077   2      
2078   2            DCLK=0;
2079   2            _Nop();
2080   2            DCLK=1;
2081   2            _Nop();
2082   2            Dath=DOUT;
2083   2            Dath=Dath<<(7-i);
2084   2            temp=temp|Dath;
2085   2          }
2086   1      
2087   1           Dath=temp;
2088   1           temp=0;
2089   1          for(i=0;i<8;i++)
2090   1          {
2091   2            DCLK=0;
2092   2            _Nop();
2093   2            DCLK=1;
2094   2            Datl=DOUT;
2095   2            Datl=Datl<<(7-i);
2096   2            temp=temp|Datl;
2097   2            _Nop();
2098   2      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 35  

2099   2          }
2100   1      
2101   1           Datl=temp;
2102   1           Dat_ad=(Dath*256+Datl)&0x0fff;
2103   1      
2104   1           CSAD=1;
2105   1      
2106   1      
2107   1      
2108   1            _Nop();
2109   1      
2110   1            return(Dat_ad);
2111   1      }
2112          
2113          
2114          
2115          /**************************************************************************/
2116          /*****************************外部PWM设置程序*******************************/
2117          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
2118          { 
2119   1        //脉宽1单位为10NS
2120   1        //延迟1单位为10NS
2121   1        //频率1单位为1KHZ
2122   1      
2123   1        //
2124   1      }
*** WARNING C280 IN LINE 2117 OF DUALDRIVER_GBK.C: 'pwm_pulserate': unreferenced local variable
*** WARNING C280 IN LINE 2117 OF DUALDRIVER_GBK.C: 'pwm_pulsewidth': unreferenced local variable
*** WARNING C280 IN LINE 2117 OF DUALDRIVER_GBK.C: 'pwm_pulsedelay': unreferenced local variable
2125          /**************************************************************************/
2126          /*****************************外部DA转换程序*******************************/
2127          void DA_Convert(uchar Channel, uint Dcode)
2128          {
2129   1      
2130   1        uint  Comdat=0;
2131   1         uchar i;
2132   1         switch (Channel)
2133   1          {
2134   2              case 0:Comdat=Dcode+0x1000;break;
2135   2              case 1:Comdat=Dcode+0x5000;break;
2136   2              case 2:Comdat=Dcode+0x9000;break;
2137   2              case 3:Comdat=Dcode+0xd000;break;
2138   2              default: break;
2139   2          }
2140   1      
2141   1          LDAC=1;                               //数据刷新
2142   1          _Nop();
2143   1          CSDA=0;                               //片选有效
2144   1          FS=1;
2145   1          _Nop();
2146   1          FS=0;
2147   1         for(i=0;i<16;i++)
2148   1        {
2149   2             DINDA=(bit)(Comdat&0x8000);
2150   2             SCLK=1;
2151   2             Comdat=Comdat<<1;
2152   2             _Nop();
2153   2             SCLK=0;
2154   2      
2155   2         }
2156   1      
2157   1         LDAC=0;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 36  

2158   1         _Nop();
2159   1         CSDA=1;                             //片选无效
2160   1         Dcode=0;
2161   1        return;
2162   1      
2163   1      }
2164          /**************************************************************************/
2165          
2166          
2167          /*****************************单片机内部AD********************************/
2168           void MCU_ADC(BYTE CHN)
2169           {
2170   1          BYTE    AD_finished;
2171   1          switch (CHN)
2172   1          {
2173   2              case 0: P1ASF=0x01;break;
2174   2              case 1: P1ASF=0x02;break;
2175   2              case 2:P1ASF=0x04;break;
2176   2              case 3:P1ASF=0x08;break;
2177   2              case 7:P1ASF=0x80;break;
2178   2      
2179   2              default: break;
2180   2          }
2181   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
2182   1          ADC_RES=0;
2183   1          ADC_RESL=0;
2184   1      
2185   1          CHN &= 0x07;                        //0000,0111 清0高5位
2186   1      
2187   1          ADC_CONTR =ADC_SPEEDH ;
2188   1          _nop_();
2189   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
2190   1          _nop_();
2191   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
2192   1          delayR(10);
2193   1          ADC_CONTR |= 0x08;
2194   1          delayR(10);
2195   1          AD_finished = 0;
2196   1          while (AD_finished ==0 )            //等待A/D转换结束
2197   1          {
2198   2            AD_finished = (ADC_CONTR & 0x10);
2199   2          }
2200   1          ADC_CONTR &= 0xE7;
2201   1      
2202   1          P1ASF=0x00;
2203   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
2204   1      
2205   1          return;
2206   1       }
2207          
2208          /*************************************************************************/
2209          
2210          
2211          
2212          void Error_Process()
2213          {
2214   1      
2215   1       _Nop();
2216   1       return;
2217   1      
2218   1      }
2219          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 37  

2220          
2221          
2222          /*********以下是长延时程序***********************************************/
2223          
2224          void delay(uint delay_k)
2225          {
2226   1          uint k0=0;
2227   1          do
2228   1          {
2229   2          do{k0--;}while(k0);
2230   2          delay_k--;
2231   2          }while(delay_k);
2232   1      
2233   1      }
2234          
2235          /*********以下是短延时程序***********************************************/
2236          void delayR(uint delay_k)
2237          {
2238   1          do{delay_k--;}while(delay_k);
2239   1      
2240   1      
2241   1      }
2242          
2243          /*********************************************************************/
2244          
2245          /**************************以下是外部中断0程序************************/
2246           void INT_0() interrupt 0 using 0
2247           {
2248   1          if (!LIM1)
2249   1          Error_Process();
2250   1          else  _Nop();
2251   1      
2252   1          if (!LIM2)
2253   1          Error_Process();
2254   1          else  _Nop();
2255   1          return;
2256   1       }
2257          /*********************************************************************/
2258          
2259          /***************************以下是外部中断1程序***********************/
2260          void INT_1() interrupt 2 using 1
2261          {
2262   1        _Nop();
2263   1        //chn_disp (tab16,20,0x80);
2264   1        //delayR(10000);
2265   1        //chn_disp (tab17,20,0x90);
2266   1        //delay(1000);
2267   1      }
2268          /***********************************************************************/
2269          
2270          
2271          
2272          
2273          
2274          /*****************以下是串口中断程序*******************************/
2275          
2276          void RS232() interrupt 4 using 3
2277          {
2278   1      
2279   1         if(RI)
2280   1         {
2281   2              RI=0;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 38  

2282   2      
2283   2              if (SBUF==0x0A)
2284   2              {
2285   3                   read_flag=1;
2286   3      
2287   3                }
2288   2      
2289   2              else
2290   2              {
2291   3      
2292   3      
2293   3                   inbuf[t]=SBUF;
2294   3                   t++;
2295   3      
2296   3      
2297   3      
2298   3              }
2299   2      
2300   2         }
2301   1      
2302   1           return;
2303   1      }
2304          
2305          /**********************************************************************/
2306          
2307          /*****************定时器中断程序*******************************/
2308          
2309          void tm0_isr() interrupt 1 using 1
2310          {               
2311   1           TL0 = 0x30;   //设置定时初值
2312   1           TH0 = 0xF8;   //设置定时初值
2313   1           if (count-- == 0)               //1ms * 1000 -> 1s
2314   1           {
2315   2           count = 1000;               //reset counter
2316   2           }
2317   1      }
2318          
2319          /*************************设置错误***************************/
2320          void setfault()
2321          {
2322   1      
2323   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
2324   1      
2325   1        send_string_com(inbuf1,10);
2326   1      
2327   1        t=0;
2328   1      }
2329          /*************************************************************/
2330          
2331          
2332          /*************************设置成功***************************/
2333          void setsucced()
2334          {
2335   1      
2336   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
2337   1      
2338   1        send_string_com(inbuf1,11);
2339   1        t=0;
2340   1        return;
2341   1      }
2342          /*************************************************************/
2343          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 39  

2344          
2345          
2346          
2347          
2348          
2349          /********************************警告*************************/
2350          void alarm()
2351          {
2352   1         uchar t=6;
2353   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
2354   1      
2355   1         send_string_com(inbuf1,7);
2356   1        do
2357   1        {
2358   2         delay(50);
2359   2         t--;
2360   2        }while(t);
2361   1         send_string_com(inbuf1,5);
2362   1         t=6;
2363   1         do
2364   1        {
2365   2         delay(50);
2366   2         t--;
2367   2        }while(t);
2368   1         send_string_com(inbuf1,5);
2369   1      
2370   1      }
2371          /*************************************************************/
2372          
2373          
2374          
2375          /************************主程序*******************************/
2376          void main()
2377          {
2378   1         uchar  i=10;
2379   1         uchar  tmp0=0;
2380   1      // setsucced();
2381   1      // delay(5000);
2382   1      // setsucced();
2383   1      // delay(5000);
2384   1      // setsucced();
2385   1         stat_initial();                               //状态初始划
2386   1         serial_initial();                             //串口初始化
2387   1      // delay(20000);
2388   1      // setsucced();
2389   1      // delay(5000);
2390   1      // setsucced();
2391   1      // delay(5000);
2392   1      // setsucced();
2393   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2394   1      
2395   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2396   1       {
2397   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2398   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2399   2      
2400   2        DA_Convert(3,25);                          // 种子源
2401   2         _Nop();
2402   2        DA_Convert(3,25);
2403   2      
2404   2        DA_Convert(0,25);                          // 放大级
2405   2         _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 40  

2406   2        DA_Convert(0,25);
2407   2       }
2408   1      //////////////////////////////////////////////////////////////////////////////////////////////
2409   1      
2410   1        else
2411   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2412   1       {
2413   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2414   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
2415   2      
2416   2        DA_Convert(3,88);                            // 种子源
2417   2         _Nop();
2418   2        DA_Convert(3,88);
2419   2      
2420   2        DA_Convert(0,88);                            // 放大级
2421   2        _Nop();
2422   2        DA_Convert(0,88);
2423   2       }
2424   1      //////////////////////////////////////////////////////////////////////////////////////////////
2425   1      ///////////////////////////////////上电开始显示//////////////////////////////////////////////tang
2426   1       /*  init_lcd ();
2427   1         delay(5);
2428   1         wr_lcd (comm,0x30);
2429   1         delay(30);                                    //需要足够的等待延时
2430   1         chn_disp (tab1,14,0x80);
2431   1         delay(5);
2432   1         chn_disp (tab2,20,0x90);
2433   1         delay(5);
2434   1         clrram();
2435   1         delay(5);
2436   1         chn_disp (tab3,10,0x80);
2437   1         chn_disp (tab4,12,0x90);
2438   1      
2439   1         clrram();
2440   1         delay(10);
2441   1         chn_disp (tab5,10,0x80);
2442   1         delay(5);
2443   1      */////////////////////////////////////////////////////////////////////////////////////////////
2444   1      
2445   1      
2446   1      
2447   1        do
2448   1         {
2449   2      
2450   2           delay(1);
2451   2      
2452   2           if(read_flag)
2453   2            {
2454   3              command();                        //指令识别
2455   3              read_flag=0;                      //取数标志清0
2456   3              t=0;
2457   3            }
2458   2      
2459   2           _Nop();
2460   2      
2461   2      
2462   2          if(Sys_mod)
2463   2       {
2464   3      
2465   3      
2466   3      /***************************检查按键**************************************/
2467   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 41  

2468   3       // Key_Button();  tang
2469   3      
2470   3      
2471   3      ///////////////////////////////////////////////////////////////////////////
2472   3      
2473   3      /***************************检查当前实际功率值****************************/
2474   3       //Laser_power_Check(); tang
2475   3      
2476   3      
2477   3      /*************************************************************************/
2478   3      /***************************检测当前实际电流值****************************/
2479   3      
2480   3       Diode_curent_Check();
2481   3      
2482   3      
2483   3      
2484   3      
2485   3      ///////////////////////////////////////////////////////////////////////////
2486   3      
2487   3      
2488   3      /***************************检测当前冷却温度******************************/
2489   3         TEC_Temp();
2490   3      
2491   3      
2492   3      
2493   3         if(TEC_meds_tempture1>280)
2494   3      
2495   3         {
2496   4      
2497   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2498   4           if(CONT_MOD)
2499   4           {
2500   5           Set_laser_power(0,3);       //tang
2501   5           Set_laser_power(3,3);
2502   5           }
2503   4           else
2504   4           {
2505   5           Set_laser_current(0,30);
2506   5           Set_laser_current(3,30);
2507   5           }
2508   4           SHDN1=0;
2509   4           SHDN2=0;
2510   4           send_string_com(inbuf1,9);
2511   4           t=0;
2512   4           chn_disp (inbuf1,7,0x86);
2513   4         }
2514   3      
2515   3         if(TEC_meds_tempture2>280)
2516   3      
2517   3         {
2518   4      
2519   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2520   4           if(CONT_MOD)
2521   4           {
2522   5           Set_laser_power(0,3);       //tang
2523   5           Set_laser_power(3,3);
2524   5           }
2525   4           else
2526   4           {
2527   5           Set_laser_current(0,30);
2528   5           Set_laser_current(3,30);
2529   5           }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 42  

2530   4           SHDN1=0;
2531   4           
2532   4           SHDN2=0;
2533   4           send_string_com(inbuf1,9);
2534   4           t=0;
2535   4           chn_disp (inbuf1,7,0x96);
2536   4         }
2537   3      //////////////////////////////////////////////////////////////////////////
2538   3      
2539   3      
2540   3      /***************************检测监测二极管反馈电压************************/
2541   3      
2542   3       Pdiod_V_Check();
2543   3      
2544   3      
2545   3      
2546   3      //////////////////////////////////////////////////////////////////////////
2547   3      
2548   3      
2549   3      /***************************检测TEC温控是否完成**************************/
2550   3      
2551   3      
2552   3      
2553   3      
2554   3      
2555   3      /////////////////////////////////////////////////////////////////////////
2556   3      
2557   3      
2558   3      /***************************检测TEC两端电压是否正常*********************/
2559   3      
2560   3        TEC_V_Check();
2561   3      
2562   3        if( TEC_VO1>3.1) Error_Process();
2563   3        if( TEC_VO2>3.1) Error_Process();
2564   3      
2565   3      ////////////////////////////////////////////////////////////////////////
2566   3      
2567   3      
2568   3      /****************************LCD显示***********************************
2569   3      
2570   3      
2571   3           chn_disp (tab6,4,0x80);
2572   3           delayR(50);
2573   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2574   3           delayR(50);
2575   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2576   3      
2577   3      
2578   3           chn_disp (tab7,4,0x90);
2579   3           delayR(50);
2580   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2581   3           delayR(50);
2582   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2583   3      
2584   3      
2585   3      
2586   3      
2587   3      
2588   3           if(CONT_MOD)
2589   3           {
2590   3              chn_disp (tab14,6,0x87);
2591   3              delayR(50);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       12/09/2013 14:34:11 PAGE 43  

2592   3              chn_disp (tab14,6,0x97);
2593   3            }
2594   3           else
2595   3           {
2596   3              chn_disp (tab15,6,0x87);
2597   3              delayR(50);
2598   3              chn_disp (tab15,6,0x97);
2599   3           }
2600   3      
2601   3      //////////////////////////////////////////////////////////////////////*/
2602   3      }
2603   2      
2604   2      else
2605   2      {
2606   3          // chn_disp (tab16,20,0x80);
2607   3         // delayR(10000);
2608   3          // chn_disp (tab17,20,0x90);
2609   3      }
2610   2      
2611   2          }while(1);
2612   1      
2613   1      
2614   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8640    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40     100
   IDATA SIZE       =    114    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)

C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER_GBK
OBJECT MODULE PLACED IN dualdriver_gbk.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver_gbk.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          uint  count=1000;
  23          //uchar code tab1[]={"光纤激光控制器"};
  24          //uchar code tab2[]={"苏州德龙激光有限公司"};
  25          //uchar code tab3[]={"正在初始化"};
  26          //uchar code tab4[]={"请稍候......"};
  27          //uchar code tab5[]={"初始化完成"};
  28          //uchar code tab6[]={"SED:"};
  29          //uchar code tab7[]={"AMP:"};
  30          //uchar code tab8[]={"VOTEC:1.42v"};
  31          //uchar code tab9[]={"设定电流"};
  32          //uchar code tab10[]={"设定温度"};
  33          //uchar code tab11[]={"℃"};
  34          //uchar code tab12[]={"POW:"};
  35          //uchar code tab13[]={"设定功率"};
  36          //uchar code tab14[]={"℃ APC"};
  37          //uchar code tab15[]={"℃ ACC"};
  38          //uchar code tab16[]={"系统采集控制模式中  "};
  39          //uchar code tab17[]={"...................."};
  40          uchar idata  TEC_parameter1[6];
  41          uchar idata  TEC_parameter2[6];
  42          uchar idata  Diode_parameter1[6];
  43          uchar idata  Diode_parameter2[6];
  44          uchar idata  Power_parameter1[6];
  45          uchar idata  Power_parameter2[6];
  46          uchar  set_flag;
  47          uchar RFON;
  48          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  49          
  50          uint   idata MCU_AD_code;
  51          uint   idata AD_code;
  52          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  53          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  54          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
  55          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 2   

  56          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  57          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  58          uint   init_current1;                       //种子源初始电流
  59          uint   init_current2;                       //放大级初始电流
  60          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅种子源 3：双路
  61          
  62          uint   idata Laser_Set_power1;             //设定种子源激光功率
  63          uint   idata Laser_Set_power2;             //设定放大级激光功率
  64          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  65          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  66          uint   idata Laser_meds_power1;            //种子源中间设定功率
  67          uint   idata Laser_meds_power2;            //放大级中间设定功率
  68          
  69          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  70          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  71          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  72          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  73          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  74          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  75          
  76          uint   idata Key_V;                         //按键电压
  77          
  78          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  79          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  80          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  81          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  82          uint   pwm_pulserate;
  83          uint   pwm_pulsewidth;
  84          uint   pwm_pulsedelay;
  85          
  86          
  87          uchar  t=0;                                 // 缓冲区数据段
  88          
  89          bit  read_flag=0;                           // 读取标志位
  90          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  91          
  92          
  93          //////////////////////////输入控制位/////////////////////////////////////////////////////
  94          
  95          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  96          
  97          
  98          
  99          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
 100          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
 101          sbit DOUT=P1^6;                      //AD串行输出
 102          
 103          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 104          
 105          //////////////////////////输出控制位/////////////////////////////////////////////////////
 106          sbit LDAC=P2^2;                      //DA装载信号
 107          sbit CSDA=P4^0;                      //DA选通信号
 108          sbit DINDA=P2^1;                     //DA串行数据输入
 109          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 110          sbit SCLK=P2^0;                      //DA时钟输入
 111          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 112          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 113          
 114          sbit FS=P3^7;                        //DA帧信号
 115          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 116          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 117          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 3   

 118          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 119          sbit LIM2=P2^5;                      //激光二极管过流中断信号
 120          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 121          sbit DCLK=P1^7;                      //AD时钟信号
 122          sbit ADIN=P1^5;                      //AD串行数据输入
 123          sbit CSAD=P2^4;                      //AD选通信号，L－选通 
 124          
 125          uint AD_Convert(uchar Channel);      //AD转换
 126          void DA_Convert(uchar Channel, uint Dcode);      //DA转换
 127          //void Set_TEC_TEMP(uint tempture);              //设定冷却温度
 128          void Set_laser_current(uchar Channel,uint current);    //设定激光二极管电流
 129          void Set_laser_power(uchar Channel,uint power);        //设定激光功率
 130          void MCU_ADC(BYTE CHN);                      //单片机内部AD转换
 131          //void Key_Button();                           //按键判别
 132          void TEC_V_Check();                          //TEC两端电压
 133          void Diode_curent_Check();                   //激光二极管电流检测
 134          void Laser_power_Check();                    //激光功率检测
 135          void Pdiod_V_Check();                        //激光二极管监测电压
 136          void TEC_Temp();                             //TEC温度
 137          void Error_Process();                        //异常处理
 138          void wr_lcd (uchar dat_comm,uchar content);
 139          //void Lcd_disp();
 140          void Pwm_Set(uint,uint,uint);
 141          void Sdio_check();                     // 加电流时状态检查
 142          
 143          void serial_initial();                 // 串口初始化
 144          void stat_initial();                   // 状态初始化
 145          void INT_0();                          // 外部中断0
 146          void delay(uint);                      // 长延时
 147          void delayR(uint);                     // 短延时
 148          void RS232();                          // 串口中断
 149          
 150          
 151          
 152          void command();                        // 指令判断
 153          void setfault();                       // 设置错误
 154          void setsucced();                      // 设置成功
 155          void alarm();                          // 警告
 156          
 157          
 158          
 159          /***************向串口发送一个字符串*****************/
 160          void send_string_com(uchar *str,uchar strlen)
 161          {
 162   1          uchar k=0;
 163   1          do
 164   1          {
 165   2              SBUF=*(str + k);
 166   2              while(TI==0);
 167   2              TI=0;
 168   2              k++;
 169   2          } while(k < strlen);
 170   1      }
 171          /************************************************************************/
 172          
 173          
 174          
 175          
 176          /***********以下是串口初始化程序********************************************/
 177          void serial_initial()
 178          {
 179   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 4   

 180   1      
 181   1            PCON |= 0x80;             //使能波特率倍速位SMOD
 182   1            SCON = 0x50;              //8位数据,可变波特率
 183   1            BRT = 0x64;               //设定独立波特率发生器重装值
 184   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 185   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 186   1            AUXR |= 0x10;             //启动独立波特率发生器
 187   1      
 188   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 189   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 190   1      
 191   1            IPH=0x14;
 192   1            IP=0x24;
 193   1            ES=1;
 194   1            ET0=1;
 195   1            IT0=1;
 196   1            EX0=1;
 197   1            IT1=1;
 198   1            EX1=1;
 199   1            EA=1;
 200   1            TL0 = 0x30;   //设置定时初值
 201   1            TH0 = 0xF8;   //设置定时初值
 202   1            TF0 = 0;    //清除TF0标志
 203   1            TR0 = 0;    //定时器0开始计时
 204   1      
 205   1            return;
 206   1      }
 207          
 208          /**********************************************************************/
 209          
 210          
 211          
 212          
 213          /***********以下是状态初始化程序*********************************/
 214          void stat_initial()
 215          {
 216   1      
 217   1           ADC_RES=0;
 218   1           ADC_RESL=0;
 219   1      
 220   1           read_flag=0;          //读取标志清零
 221   1           las_di_ok=0;
 222   1           t=0;
 223   1           set_flag=0;
 224   1           Sys_mod=1;
 225   1      
 226   1           AD_code=0;
 227   1      //     Laser_Set_curent=0;
 228   1           Laser_Fed_curent1=0;
 229   1           Laser_Fed_curent2=0;
 230   1           Laser_Fed_power1=0;
 231   1           Laser_Fed_power2=0;
 232   1      
 233   1      /**************DA引脚初始化*************************/
 234   1           CSDA=1;
 235   1           LDAC=1;
 236   1           FS=0;
 237   1           SCLK=0;
 238   1           DINDA=0;
 239   1      /**************************************************/
 240   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
 241   1           _Nop();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 5   

 242   1           DA_Convert(2,1273);
 243   1           _Nop();
 244   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
 245   1           _Nop();
 246   1           DA_Convert(1,1273);
 247   1      /**************************************************/
 248   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
 249   1      
 250   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
 251   1       {
 252   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
 253   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
 254   2      
 255   2        DA_Convert(3,25);                          // 种子源
 256   2         _Nop();
 257   2        DA_Convert(3,25);
 258   2      
 259   2        DA_Convert(0,25);                          // 放大级
 260   2         _Nop();
 261   2        DA_Convert(0,25);
 262   2       }
 263   1      //////////////////////////////////////////////////////////////////////////////////////////////
 264   1      
 265   1        else
 266   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
 267   1       {
 268   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
 269   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
 270   2      
 271   2        DA_Convert(3,92);                            // 种子源
 272   2         _Nop();
 273   2        DA_Convert(3,92);
 274   2      
 275   2        DA_Convert(0,89);                            // 放大级
 276   2        _Nop();
 277   2        DA_Convert(0,89);
 278   2       }
 279   1      //////////////////////////////////////////////////////////////////////////////////////////////
 280   1      
 281   1      
 282   1      
 283   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
 284   1           P1M1=0x07;
 285   1           P1M0=0x00;
 286   1      
 287   1           CSAD=1;
 288   1           DCLK=1;
 289   1           DOUT=1;
 290   1      
 291   1      
 292   1      
 293   1      
 294   1      
 295   1      /*************TEC控制器初始化*********************/
 296   1           SHDN1=1;
 297   1      //   TMPGD1=1;
 298   1           LIM1=1;
 299   1      
 300   1           SHDN2=1;
 301   1      //   TMPGD2=1;
 302   1           LIM2=1;
 303   1      /*************************************************/
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 6   

 304   1      
 305   1      /*    Power_parameter[0]='P';
 306   1            Power_parameter[1]='O';
 307   1            Power_parameter[2]='W';
 308   1            Power_parameter[3]=':';
 309   1      
 310   1            Diode_parameter[0]='L';
 311   1            Diode_parameter[1]='D';
 312   1            Diode_parameter[2]='C';
 313   1            Diode_parameter[3]=':';
 314   1            Diode_parameter[8]=0x20;
 315   1            Diode_parameter[9]=0x20;
 316   1      
 317   1            TEC_parameter[0]='T';
 318   1            TEC_parameter[1]='E';
 319   1            TEC_parameter[2]='C';
 320   1            TEC_parameter[3]=':';
 321   1      */
 322   1      
 323   1           TR0=0;
 324   1           ET0=0;
 325   1           TR1=0;
 326   1           ET1=0;
 327   1           EX0=0;
 328   1      
 329   1           return;
 330   1      }
 331          
 332          /***************************************************************/
 333          
 334          
 335          
 336          /****************************操作指令执行***********************/
 337          void command()
 338          {
 339   1      
 340   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
 341   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
 342   1              {
 343   2                 stat_initial();
 344   2                 serial_initial();
 345   2                 setsucced();
 346   2              }
 347   1      
 348   1      ///////////////////////////////////设定电流////////////////////////////////////////////
 349   1             else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='='))
 350   1      
 351   1                 {
 352   2                     uint dio_cu;
 353   2                     uchar CH;
 354   2      
 355   2                     if(inbuf[5]==0x0d)                                        //格式为LD1(2)=N
 356   2                    {
 357   3                       dio_cu=inbuf[4]-48;
 358   3      
 359   3      
 360   3                    }
 361   2                     else if(inbuf[6]==0x0d)                                   //格式为LD1(2)=NN
 362   2                    {
 363   3                       dio_cu=(uint)((inbuf[4]-48)*10+(inbuf[5]-48));
 364   3      
 365   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 7   

 366   2                    else if(inbuf[7]==0x0d)                                    //格式为LD1(2)=NNN
 367   2                    {
 368   3                       dio_cu=(uint)((inbuf[4]-48)*100+(inbuf[5]-48)*10+(inbuf[6]-48));
 369   3      
 370   3                    }
 371   2      
 372   2                    else                                                    //格式为LD1(2)=NNNN
 373   2                    {
 374   3                        setfault();
 375   3                        goto setcf;
 376   3                    }
 377   2      
 378   2                    if(inbuf[2]=='1')
 379   2                    {
 380   3                      CH=3;                                     //种子源SEED
 381   3                      Set_laser_current(CH,dio_cu);
 382   3                      setsucced();
 383   3                    }
 384   2                    else if(inbuf[2]=='2')
 385   2                    {
 386   3                      CH=0;                                    //放大级AMP
 387   3                      Set_laser_current(CH,dio_cu);
 388   3                      setsucced();
 389   3                    }
 390   2                    else setfault();
 391   2      
 392   2      setcf:       _Nop();
 393   2      
 394   2                 }
 395   1      
 396   1      
 397   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
 398   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
 399   1      
 400   1                 {
 401   2                     uint init_current;
 402   2            
 403   2                     if(inbuf[7]==0x0d)                                        //格式为INIC=N
 404   2                    {
 405   3                       init_current=inbuf[6]-48;
 406   3      
 407   3      
 408   3                    }
 409   2                     else if(inbuf[8]==0x0d)                                   //格式为INIC=NN
 410   2                    {
 411   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
 412   3      
 413   3                    }
 414   2                    else if(inbuf[9]==0x0d)                                    //格式为INIC=NNN
 415   2                    {
 416   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
 417   3      
 418   3                    }
 419   2      
 420   2                    else                                                    //格式为INIC=NNNN
 421   2                    {
 422   3                        setfault();
 423   3                        goto seticf;
 424   3                    }
 425   2      
 426   2                    if(inbuf[5]=='S')
 427   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 8   

 428   3                      init_current1=init_current;
 429   3                    }
 430   2                    else if(inbuf[5]=='A')
 431   2                    {
 432   3                      init_current2=init_current;
 433   3                    }
 434   2                    else setfault();
 435   2      
 436   2      seticf:       _Nop();
 437   2      
 438   2                 }
 439   1      
 440   1      
 441   1      
 442   1      ///////////////////////////////////设定初始化模式 0/1/2/3 ////////////////////////////////////////////
 443   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
 444   1      
 445   1                 {   
 446   2                     uint init_flag_temp;
 447   2                 
 448   2                     if(inbuf[6]==0x0d)                                        
 449   2                    {
 450   3                       init_flag_temp=inbuf[5]-48;
 451   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
 452   3                        goto setief;
 453   3                      else
 454   3                        init_flag=init_flag_temp;
 455   3                    }
 456   2                    else                                                    
 457   2                    {
 458   3                        setfault();
 459   3                        goto setief;
 460   3                    }
 461   2      
 462   2      setief:       _Nop();
 463   2      
 464   2                 }
 465   1      
 466   1      
 467   1       //////////////////////////////设定功率//////////////////////////////////////////////////
 468   1              else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 469   1                  {
 470   2                     uint las_pow;
 471   2                     uchar CHH;
 472   2                     if(inbuf[4]==0x0d)                                        //格式为P1(2)=N
 473   2                    {
 474   3                       las_pow=(uint)(inbuf[3]-48);
 475   3      
 476   3                    }
 477   2                     else if(inbuf[5]==0x0d)                                   //格式为P1(2)=NN
 478   2                    {
 479   3                       las_pow=(uint)((inbuf[3]-48)*10+(inbuf[4]-48));
 480   3      
 481   3                    }
 482   2                    else if(inbuf[6]==0x0d)                                    //格式为P1(2)=NNN
 483   2                    {
 484   3                       las_pow=(uint)((inbuf[3]-48)*100+(inbuf[4]-48)*10+(inbuf[5]-48));
 485   3      
 486   3                    }
 487   2      
 488   2                    else                                                      //格式为P1(2)=NNNN
 489   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 9   

 490   3                        setfault();
 491   3                        goto setpf;
 492   3                    }
 493   2      
 494   2                    if(inbuf[2]=='1')
 495   2                    {
 496   3                      CH=3;                                     //种子源SEED
 497   3                      Set_laser_power(CHH,las_pow);
 498   3                      setsucced();
 499   3                    }
 500   2                    else if(inbuf[2]=='2')
 501   2                    {
 502   3                      CH=0;                                    //放大级AMP
 503   3                      Set_laser_power(CHH,las_pow);
 504   3                      setsucced();
 505   3                    }
 506   2                    else setfault();
 507   2      
 508   2      setpf:       _Nop();
 509   2      
 510   2      
 511   2                  }
 512   1       ////////////////////////////////////////////////////////////////////////////////////////
 513   1       //////////////////////////////设定温度//////////////////////////////////////////////////
 514   1              else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='='))
 515   1                 {
 516   2                    uint  tmp_tec=0;
 517   2                    uint kt=0;
 518   2                    if(inbuf[5]==0x0d)
 519   2                    {
 520   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 521   3      
 522   3      
 523   3      
 524   3      
 525   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
 526   3      
 527   3                    }
 528   2                    else if(inbuf[7]==0x0d)
 529   2                    {
 530   3                       tmp_tec=(inbuf[3]-48)*10+(inbuf[4]-48);
 531   3      
 532   3                       kt=((tmp_tec-15)*691+(inbuf[6]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[6]-48)*59/5+90;
 533   3      
 534   3                    }
 535   2      
 536   2                    else
 537   2                    {
 538   3                       setfault();
 539   3                       goto settf;
 540   3                    }
 541   2      
 542   2                     if(inbuf[1]=='1')
 543   2                    {
 544   3                      DA_Convert(2,kt);                         //种子源SEED
 545   3                      _Nop();
 546   3                      DA_Convert(2,kt);
 547   3                      setsucced();
 548   3                    }
 549   2                    else if(inbuf[1]=='2')
 550   2                    {
 551   3                      DA_Convert(1,kt);                         //放大级AMP
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 10  

 552   3                      _Nop();
 553   3                      DA_Convert(1,kt);
 554   3                      setsucced();
 555   3                    }
 556   2                    else setfault();
 557   2      
 558   2      settf:       _Nop();
 559   2      
 560   2      
 561   2                 }
 562   1      
 563   1       ////////////////////////////////////////////////////////////////////////////////////////
 564   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
 565   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
 566   1               {
 567   2                     
 568   2                   
 569   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
 570   2                    {
 571   3                       pwm_pulserate=inbuf[5]-48;
 572   3      
 573   3      
 574   3                    }
 575   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
 576   2                    {
 577   3                       pwm_pulserate=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 578   3      
 579   3                    }
 580   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
 581   2                    {
 582   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 583   3      
 584   3                    }
 585   2                  
 586   2                    else                                                    //格式为PURA=NNNN
 587   2                    {
 588   3                        setfault();
 589   3                        goto setprf;
 590   3                    }
 591   2                      Pwm_Set(pwm_pulserate,0,0);
 592   2                      setsucced();
 593   2      setprf:       _Nop();
 594   2      
 595   2                 }
 596   1                ////////////////////////////////////////////////////////////////////////////////////////
 597   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
 598   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
 599   1               {
 600   2                    
 601   2                   
 602   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
 603   2                    {
 604   3                       pwm_pulsewidth=inbuf[5]-48;
 605   3      
 606   3      
 607   3                    }
 608   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
 609   2                    {
 610   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 611   3      
 612   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 11  

 613   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
 614   2                    {
 615   3                       pwm_pulsewidth=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
 616   3      
 617   3                    }
 618   2                  
 619   2                    else                                                    //格式为PUWI=NNNN
 620   2                    {
 621   3                        setfault();
 622   3                        goto setpwf;
 623   3                    }
 624   2                        Pwm_Set(0,pwm_pulsewidth,0);
 625   2                      setsucced();
 626   2      setpwf:       _Nop();
 627   2      
 628   2                 }
 629   1      
 630   1                 ////////////////////////////////////////////////////////////////////////////////////////
 631   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
 632   1              else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='='))
 633   1               {
 634   2                   
 635   2                   
 636   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
 637   2                    {
 638   3                       pwm_pulsedelay=inbuf[5]-48;
 639   3      
 640   3      
 641   3                    }
 642   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
 643   2                    {
 644   3                       pwm_pulsedelay=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
 645   3      
 646   3                    }
 647   2                    else                                                    //格式为DELY=NNNN
 648   2                    {
 649   3                        setfault();
 650   3                        goto setpdf;
 651   3                    }
 652   2                      Pwm_Set(0,0,pwm_pulsedelay);
 653   2                      setsucced();
 654   2      setpdf:       _Nop();
 655   2      
 656   2                 }
 657   1      ////////////////////////////////////////////////////////////////////////////////////////
 658   1       //////////////////////////////选脉冲 开启或关闭  //////////////////////////////////////////////////
 659   1                else if((inbuf[0]=='R')&&(inbuf[1]=='F')&&(inbuf[2]=='='))
 660   1      
 661   1                 {
 662   2                    if((inbuf[4]==0x0d)&&(inbuf[3]=='1'))             //RF ON
 663   2                    {
 664   3                       RFON=1;
 665   3                       P0=0xf0;
 666   3                       RW=0;
 667   3                       RS=0;
 668   3                       delayR(10);
 669   3                       ENAB=1;
 670   3                       delayR(10);
 671   3                       ENAB=0;
 672   3                       delayR(10);
 673   3                       setsucced();
 674   3                    }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 12  

 675   2                    else if((inbuf[4]==0x0d)&&(inbuf[3]=='0'))        //RF OFF
 676   2                    {
 677   3                       RFON=0;
 678   3                       P0=0x0f;
 679   3                       RW=0;
 680   3                       RS=0;
 681   3                       delayR(10);
 682   3                       ENAB=1;
 683   3                       delayR(10);
 684   3                       ENAB=0;
 685   3                       delayR(10);
 686   3                       setsucced();
 687   3                    }
 688   2                    else
 689   2                       setfault();
 690   2      
 691   2                 }
 692   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
 693   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
 694   1      
 695   1                 {
 696   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
 697   2                    {
 698   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
 699   3                       setsucced();
 700   3                    }
 701   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
 702   2                    {
 703   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
 704   3                       setsucced();
 705   3                    }
 706   2                    else
 707   2                       setfault();
 708   2      
 709   2                 }
 710   1      
 711   1       //////////////////////////////////强制关电流///////////////////////////////////////
 712   1      
 713   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
 714   1      
 715   1                 {
 716   2                    if(inbuf[7]==0x0d)
 717   2                    {
 718   3                       if(inbuf[5]=='S')
 719   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
 720   3                       else  if(inbuf[5]=='A')
 721   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
 722   3                       else
 723   3                        {
 724   4                         setfault();
 725   4                         goto setdf;
 726   4                        }
 727   3                       if (!LIM1)
 728   3                       {
 729   4                         Set_laser_current(3,50);
 730   4                         setsucced();
 731   4                        }
 732   3                       else if(!LIM2)
 733   3                       {
 734   4                         Set_laser_current(0,50);
 735   4                         setsucced();
 736   4                        }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 13  

 737   3                       else
 738   3                        {
 739   4                         setfault();
 740   4                         goto setdf;
 741   4                        }
 742   3                    }
 743   2                    else
 744   2                       setfault();
 745   2      setdf:       _Nop();
 746   2                 }
 747   1      //////////////////////////////////总查询（电流、温度、功率）/////////////////////////////////
 748   1            else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&((inbuf[2]=='A')&&(inbuf[3]=='T'))&&(inbuf[4]=='E')&&(inbu
             -f[5]=='?'))
 749   1       {
 750   2                    uint ky;
 751   2      //              TEC_Temp();
 752   2                    inbuf[0]= 0x0d;
 753   2                    send_string_com(inbuf,1);
 754   2                      inbuf[0] ='L';
 755   2                      inbuf[1] ='D';
 756   2                      inbuf[2] ='1';
 757   2                      inbuf[3] ='=';
 758   2                  if(Laser_Fed_curent1<10)
 759   2                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
 760   3                      inbuf[5]=0x0d;
 761   3                      inbuf[6]=0x0a;
 762   3                      send_string_com(inbuf,7);
 763   3                    }else if (Laser_Fed_curent1<100)
 764   2                    { 
 765   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
 766   3                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
 767   3                      inbuf[6]=0x0d;
 768   3                      inbuf[7]=0x0a;
 769   3                      send_string_com(inbuf,8);
 770   3                    }else if (Laser_Fed_curent1<1000)
 771   2                    {
 772   3                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
 773   3                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
 774   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
 775   3                      inbuf[7]=0x0d;
 776   3                      inbuf[8]=0x0a;
 777   3                      send_string_com(inbuf,9);
 778   3                    }
 779   2                    else
 780   2                      setfault();
 781   2      
 782   2                      inbuf[0] ='L';
 783   2                      inbuf[1] ='D';
 784   2                      inbuf[2] ='2';
 785   2                      inbuf[3] ='=';
 786   2                  if(Laser_Fed_curent2<10)
 787   2                    {
 788   3                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
 789   3                      inbuf[5]=0x0d;
 790   3                      inbuf[6]=0x0a;
 791   3                      send_string_com(inbuf,7);
 792   3                    }else if (Laser_Fed_curent2<100)
 793   2                    {
 794   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
 795   3                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
 796   3                      inbuf[6]=0x0d;
 797   3                      inbuf[7]=0x0a;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 14  

 798   3                      send_string_com(inbuf,8);
 799   3                    }else if (Laser_Fed_curent2<1000)
 800   2                    {
 801   3                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
 802   3                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
 803   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
 804   3                      inbuf[7]=0x0d;
 805   3                      inbuf[8]=0x0a;
 806   3                      send_string_com(inbuf,9);
 807   3                    }
 808   2                    else
 809   2                      setfault();
 810   2                    inbuf[0]= 0x0d;
 811   2                    send_string_com(inbuf,1);
 812   2                      inbuf[0] ='P';
 813   2                      inbuf[1] ='1';
 814   2                      inbuf[2] ='=';
 815   2                if(Laser_Fed_power1<10)
 816   2                    {
 817   3                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
 818   3                      inbuf[4]=0x0d;
 819   3                      inbuf[5]=0x0a;
 820   3                      send_string_com(inbuf,6);
 821   3                    }else if (Laser_Fed_power1<100)
 822   2                    {
 823   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
 824   3                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
 825   3                      inbuf[5]=0x0d;
 826   3                      inbuf[6]=0x0a;
 827   3                      send_string_com(inbuf,7);
 828   3                    }else if (Laser_Fed_power1<1000)
 829   2                    {
 830   3                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
 831   3                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
 832   3                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
 833   3                      inbuf[6]=0x0d;
 834   3                      inbuf[7]=0x0a;
 835   3                      send_string_com(inbuf,8);
 836   3                    }
 837   2                    else
 838   2                      setfault();
 839   2                      
 840   2                      inbuf[0] ='P';
 841   2                      inbuf[1] ='2';
 842   2                      inbuf[2] ='=';
 843   2                    if(Laser_Fed_power2<10)
 844   2                    {
 845   3                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
 846   3                      inbuf[4]=0x0d;
 847   3                      inbuf[5]=0x0a;
 848   3                      send_string_com(inbuf,6);
 849   3                    }else if (Laser_Fed_power2<100)
 850   2                    {
 851   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
 852   3                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
 853   3                      inbuf[5]=0x0d;
 854   3                      inbuf[6]=0x0a;
 855   3                      send_string_com(inbuf,7);
 856   3                    }else if (Laser_Fed_power2<1000)
 857   2                    {
 858   3                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
 859   3                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 15  

 860   3                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
 861   3                      inbuf[6]=0x0d;
 862   3                      inbuf[7]=0x0a;
 863   3                      send_string_com(inbuf,8);
 864   3                    }
 865   2                    else
 866   2                      setfault();
 867   2      
 868   2                      inbuf[0]= 0x0d;
 869   2                      send_string_com(inbuf,1);
 870   2                      ky=(uint)(TEC_Fed_Tempture1);
 871   2                      inbuf[0] ='T';
 872   2                      inbuf[1] ='1';
 873   2                      inbuf[2] ='=';
 874   2                    if (ky<1000)
 875   2                    {
 876   3                      inbuf[3]  =ky/100+48;
 877   3                      inbuf[4]  =(ky/10)%10+48;
 878   3                      inbuf[5]  ='.';
 879   3                      inbuf[6]  =ky%10+48;
 880   3                      inbuf[7] =0x0d;
 881   3                      inbuf[8] =0x0a;
 882   3                      send_string_com(inbuf,9);
 883   3                    }
 884   2                    else
 885   2                     alarm();
 886   2                  
 887   2                     
 888   2                      ky=(uint)(TEC_Fed_Tempture2);
 889   2                      inbuf[0] ='T';
 890   2                      inbuf[1] ='2';
 891   2                      inbuf[2] ='=';
 892   2                    if (ky<1000)
 893   2                    {
 894   3                      inbuf[3]  =ky/100+48;
 895   3                      inbuf[4]  =(ky/10)%10+48;
 896   3                      inbuf[5]  ='.';
 897   3                      inbuf[6]  =ky%10+48;
 898   3                      inbuf[7] =0x0d;
 899   3                      inbuf[8] =0x0a;
 900   3                      send_string_com(inbuf,9);
 901   3                    }
 902   2                    else
 903   2                     alarm();
 904   2                     inbuf[0]= 0x0d;
 905   2                    send_string_com(inbuf,1);
 906   2                   if (TMPGD1)
 907   2                    {
 908   3                      inbuf[0]='T';
 909   3                      inbuf[1]='1';
 910   3                      inbuf[2]='O';
 911   3                      inbuf[3]='K';
 912   3                      inbuf[4]=0x0d;
 913   3                      inbuf[5]=0x0a;
 914   3                      send_string_com(inbuf,6);
 915   3                    }
 916   2      
 917   2                    else
 918   2                    {
 919   3                      inbuf[0]='T';
 920   3                      inbuf[1]='1';
 921   3                      inbuf[2]='N';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 16  

 922   3                      inbuf[3]='O';
 923   3                      inbuf[4]=0x0d;
 924   3                      inbuf[5]=0x0a;
 925   3                      send_string_com(inbuf,6);
 926   3                    }
 927   2      
 928   2                    if (TMPGD2)
 929   2                    {
 930   3                      inbuf[0]='T';
 931   3                      inbuf[1]='2';
 932   3                      inbuf[2]='O';
 933   3                      inbuf[3]='K';
 934   3                      inbuf[4]=0x0d;
 935   3                      inbuf[5]=0x0a;
 936   3                      send_string_com(inbuf,6);
 937   3                    }
 938   2      
 939   2                    else
 940   2                    {
 941   3                      inbuf[0]='T';
 942   3                      inbuf[1]='2';
 943   3                      inbuf[2]='N';
 944   3                      inbuf[3]='O';
 945   3                      inbuf[4]=0x0d;
 946   3                      inbuf[5]=0x0a;
 947   3                      send_string_com(inbuf,6);
 948   3                    }
 949   2      
 950   2                     inbuf[0] ='R';
 951   2                      inbuf[1] ='A';
 952   2                      inbuf[2] ='T';
 953   2                      inbuf[3] ='E';
 954   2                      inbuf[4] ='=';
 955   2                      inbuf[5]  =pwm_pulserate/10+48;
 956   2                      inbuf[6]  =pwm_pulserate%10+48;
 957   2                      inbuf[7]  ='K';
 958   2                      inbuf[8] =0x0d;
 959   2                      inbuf[9] =0x0a;
 960   2                      send_string_com(inbuf,10);
 961   2                    
 962   2                      inbuf[0] ='W';
 963   2                      inbuf[1] ='I';
 964   2                      inbuf[2] ='D';
 965   2                      inbuf[3] ='T';
 966   2                      inbuf[4] ='H';
 967   2                      inbuf[5]  ='=';
 968   2                      inbuf[6]  =pwm_pulsewidth/10+48;
 969   2                      inbuf[7]  =pwm_pulsewidth%10+48;
 970   2                      
 971   2                      inbuf[8]  ='L';
 972   2                      inbuf[9] =0x0d;
 973   2                      inbuf[10] =0x0a;
 974   2                      send_string_com(inbuf,11);
 975   2                      
 976   2                      inbuf[0] ='D';
 977   2                      inbuf[1] ='E';
 978   2                      inbuf[2] ='L';
 979   2                      inbuf[3] ='A';
 980   2                      inbuf[4] ='Y';
 981   2                      inbuf[5]  ='=';
 982   2                      inbuf[6]  =pwm_pulsedelay/10+48;
 983   2                      inbuf[7]  =pwm_pulsedelay%10+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 17  

 984   2                      
 985   2                      inbuf[8]  ='L';
 986   2                      inbuf[9] =0x0d;
 987   2                      inbuf[10] =0x0a;
 988   2                      send_string_com(inbuf,11);
 989   2                        inbuf[0] ='R';
 990   2                        inbuf[1] ='F';
 991   2                        inbuf[2] ='P';
 992   2                        inbuf[3] ='O';
 993   2                        inbuf[4] ='W';
 994   2                        inbuf[5] ='E';
 995   2                        inbuf[6] ='R';
 996   2                        inbuf[7] =' ';
 997   2                        if (RFON==1)
 998   2                        {
 999   3                        inbuf[8]  ='O';
1000   3                        inbuf[9] = 'N';
1001   3                        inbuf[10] = ' ';
1002   3                        }
1003   2                        else
1004   2                        {inbuf[8]  ='O';
1005   3                        inbuf[9]  = 'F';
1006   3                        inbuf[10] = 'F';
1007   3                        } 
1008   2                        inbuf[11] =0x0d;
1009   2                        inbuf[12] =0x0a;
1010   2                        send_string_com(inbuf,13);
1011   2      
1012   2      }
1013   1      
1014   1      
1015   1      
1016   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
1017   1            else if((inbuf[0]=='L')&&(inbuf[1]=='D')&&((inbuf[2]=='1')||(inbuf[2]=='2'))&&(inbuf[3]=='?'))
1018   1                 {
1019   2                  if(inbuf[2]=='1')
1020   2                  {   inbuf[0] ='L';
1021   3                      inbuf[1] ='D';
1022   3                      inbuf[2] ='1';
1023   3                      inbuf[3] ='=';
1024   3                  if(Laser_Fed_curent1<10)
1025   3                    { inbuf[4]=(uchar)(Laser_Fed_curent1)+48;
1026   4                      inbuf[5]=0x0d;
1027   4                      inbuf[6]=0x0a;
1028   4                      send_string_com(inbuf,7);
1029   4                    }else if (Laser_Fed_curent1<100)
1030   3                    { 
1031   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /10)+48;
1032   4                      inbuf[5]=(uchar)(Laser_Fed_curent1 %10)+48;
1033   4                      inbuf[6]=0x0d;
1034   4                      inbuf[7]=0x0a;
1035   4                      send_string_com(inbuf,8);
1036   4                    }else if (Laser_Fed_curent1<1000)
1037   3                    {
1038   4                      inbuf[4]=(uchar)(Laser_Fed_curent1 /100)+48;
1039   4                      inbuf[5]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
1040   4                      inbuf[6]=(uchar)(Laser_Fed_curent1 %10)+48;
1041   4                      inbuf[7]=0x0d;
1042   4                      inbuf[8]=0x0a;
1043   4                      send_string_com(inbuf,9);
1044   4                    }
1045   3                    else
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 18  

1046   3                      setfault();
1047   3      
1048   3                     }
1049   2       //////////////////////////////////////////////////////////
1050   2                  else if(inbuf[2]=='2')
1051   2                    {  inbuf[0] ='L';
1052   3                      inbuf[1] ='D';
1053   3                      inbuf[2] ='2';
1054   3                      inbuf[3] ='=';
1055   3                  if(Laser_Fed_curent2<10)
1056   3                    {
1057   4                      inbuf[4]=(uchar)(Laser_Fed_curent2)+48;
1058   4                      inbuf[5]=0x0d;
1059   4                      inbuf[6]=0x0a;
1060   4                      send_string_com(inbuf,7);
1061   4                    }else if (Laser_Fed_curent2<100)
1062   3                    {
1063   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /10)+48;
1064   4                      inbuf[5]=(uchar)(Laser_Fed_curent2 %10)+48;
1065   4                      inbuf[6]=0x0d;
1066   4                      inbuf[7]=0x0a;
1067   4                      send_string_com(inbuf,8);
1068   4                    }else if (Laser_Fed_curent2<1000)
1069   3                    {
1070   4                      inbuf[4]=(uchar)(Laser_Fed_curent2 /100)+48;
1071   4                      inbuf[5]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
1072   4                      inbuf[6]=(uchar)(Laser_Fed_curent2 %10)+48;
1073   4                      inbuf[7]=0x0d;
1074   4                      inbuf[8]=0x0a;
1075   4                      send_string_com(inbuf,9);
1076   4                    }
1077   3                    else
1078   3                      setfault();
1079   3                 }
1080   2               }
1081   1      
1082   1      
1083   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
1084   1            else if((inbuf[0]=='P')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1085   1      
1086   1                 {
1087   2                  if(inbuf[1]=='1')
1088   2                    {
1089   3                     inbuf[0] ='P';
1090   3                      inbuf[1] ='1';
1091   3                      inbuf[2] ='=';
1092   3                    if(Laser_Fed_power1<10)
1093   3                    {
1094   4                      inbuf[3]=(uchar)(Laser_Fed_power1)+48;
1095   4                      inbuf[4]=0x0d;
1096   4                      inbuf[5]=0x0a;
1097   4                      send_string_com(inbuf,6);
1098   4                    }else if (Laser_Fed_power1<100)
1099   3                    {
1100   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /10)+48;
1101   4                      inbuf[4]=(uchar)(Laser_Fed_power1 %10)+48;
1102   4                      inbuf[5]=0x0d;
1103   4                      inbuf[6]=0x0a;
1104   4                      send_string_com(inbuf,7);
1105   4                    }else if (Laser_Fed_power1<1000)
1106   3                    {
1107   4                      inbuf[3]=(uchar)(Laser_Fed_power1 /100)+48;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 19  

1108   4                      inbuf[4]=(uchar)((Laser_Fed_power1 /10)%10)+48;
1109   4                      inbuf[5]=(uchar)(Laser_Fed_power1 %10)+48;
1110   4                      inbuf[6]=0x0d;
1111   4                      inbuf[7]=0x0a;
1112   4                      send_string_com(inbuf,8);
1113   4                    }
1114   3                    else
1115   3                      setfault();
1116   3                      
1117   3                    }
1118   2                    else if(inbuf[1]=='2')
1119   2                     {
1120   3                      inbuf[0] ='P';
1121   3                      inbuf[1] ='2';
1122   3                      inbuf[2] ='=';
1123   3                    if(Laser_Fed_power2<10)
1124   3                    {
1125   4                      inbuf[3]=(uchar)(Laser_Fed_power2)+48;
1126   4                      inbuf[4]=0x0d;
1127   4                      inbuf[5]=0x0a;
1128   4                      send_string_com(inbuf,6);
1129   4                    }else if (Laser_Fed_power2<100)
1130   3                    {
1131   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /10)+48;
1132   4                      inbuf[4]=(uchar)(Laser_Fed_power2 %10)+48;
1133   4                      inbuf[5]=0x0d;
1134   4                      inbuf[6]=0x0a;
1135   4                      send_string_com(inbuf,7);
1136   4                    }else if (Laser_Fed_power2<1000)
1137   3                    {
1138   4                      inbuf[3]=(uchar)(Laser_Fed_power2 /100)+48;
1139   4                      inbuf[4]=(uchar)((Laser_Fed_power2 /10)%10)+48;
1140   4                      inbuf[5]=(uchar)(Laser_Fed_power2 %10)+48;
1141   4                      inbuf[6]=0x0d;
1142   4                      inbuf[7]=0x0a;
1143   4                      send_string_com(inbuf,8);
1144   4                    }
1145   3                    else
1146   3                      setfault();
1147   3                  }
1148   2                 }
1149   1      
1150   1      ///////////////////////////////////查询PWM情况////////////////////////////////
1151   1            else if((inbuf[0]=='P')&&((inbuf[1]=='W')&&(inbuf[2]=='M'))&&(inbuf[3]=='?'))
1152   1                 {
1153   2      
1154   2                      inbuf[0] ='R';
1155   2                      inbuf[1] ='A';
1156   2                      inbuf[2] ='T';
1157   2                      inbuf[3] ='E';
1158   2                      inbuf[4] ='=';
1159   2                      inbuf[5]  =pwm_pulserate/10+48;
1160   2                      inbuf[6]  =pwm_pulserate%10+48;
1161   2                      inbuf[7]  ='K';
1162   2                      inbuf[8] =0x0d;
1163   2                      inbuf[9] =0x0a;
1164   2                      send_string_com(inbuf,10);
1165   2                    
1166   2                     inbuf[0] ='W';
1167   2                      inbuf[1] ='I';
1168   2                      inbuf[2] ='D';
1169   2                      inbuf[3] ='T';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 20  

1170   2                      inbuf[4] ='H';
1171   2                      inbuf[5]  ='=';
1172   2                      inbuf[6]  =pwm_pulsewidth/10+48;
1173   2                      inbuf[7]  =pwm_pulsewidth%10+48;
1174   2                      
1175   2                      inbuf[8]  ='L';
1176   2                      inbuf[9] =0x0d;
1177   2                      inbuf[10] =0x0a;
1178   2                      send_string_com(inbuf,11);
1179   2                      
1180   2                      inbuf[0] ='D';
1181   2                      inbuf[1] ='E';
1182   2                      inbuf[2] ='L';
1183   2                      inbuf[3] ='A';
1184   2                      inbuf[4] ='Y';
1185   2                      inbuf[5]  ='=';
1186   2                      inbuf[6]  =pwm_pulsedelay/10+48;
1187   2                      inbuf[7]  =pwm_pulsedelay%10+48;
1188   2                      
1189   2                      inbuf[8]  ='L';
1190   2                      inbuf[9] =0x0d;
1191   2                      inbuf[10] =0x0a;
1192   2                      send_string_com(inbuf,11);
1193   2                      inbuf[0] ='R';
1194   2                      inbuf[1] ='F';
1195   2                      inbuf[2] ='P';
1196   2                      inbuf[3] ='O';
1197   2                      inbuf[4] ='W';
1198   2                      inbuf[5] ='E';
1199   2                      inbuf[6] ='R';
1200   2                      inbuf[7] =' ';
1201   2                      if (RFON==1)
1202   2                      {
1203   3                       inbuf[8]  ='O';
1204   3                       inbuf[9] = 'N';
1205   3                       inbuf[10] = ' ';
1206   3                      }
1207   2                      else
1208   2                        {inbuf[8]  ='O';
1209   3                        inbuf[9]  = 'F';
1210   3                        inbuf[10] = 'F';
1211   3                      } 
1212   2                      inbuf[11] =0x0d;
1213   2                      inbuf[12] =0x0a;
1214   2                      send_string_com(inbuf,13);
1215   2      
1216   2      
1217   2                 }
1218   1               
1219   1      
1220   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
1221   1            else if((inbuf[0]=='T')&&((inbuf[1]=='1')||(inbuf[1]=='2'))&&(inbuf[2]=='?'))
1222   1                 {
1223   2      
1224   2                    uint ky;
1225   2      //              TEC_Temp();
1226   2                    if (inbuf[1]=='1')
1227   2                    {  ky=(uint)(TEC_Fed_Tempture1);
1228   3                      inbuf[0] ='T';
1229   3                      inbuf[1] ='1';
1230   3                      inbuf[2] ='=';
1231   3                    if (ky<1000)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 21  

1232   3                    {
1233   4                      inbuf[3]  =ky/100+48;
1234   4                      inbuf[4]  =(ky/10)%10+48;
1235   4                      inbuf[5]  ='.';
1236   4                      inbuf[6]  =ky%10+48;
1237   4                      inbuf[7] =0x0d;
1238   4                      inbuf[8] =0x0a;
1239   4                      send_string_com(inbuf,9);
1240   4                    }
1241   3                    else
1242   3                     alarm();  
1243   3                    }
1244   2                  else if (inbuf[1]=='2')
1245   2                    { 
1246   3                      ky=(uint)(TEC_Fed_Tempture2);
1247   3                      inbuf[0] ='T';
1248   3                      inbuf[1] ='2';
1249   3                      inbuf[2] ='=';
1250   3                    if (ky<1000)
1251   3                    {
1252   4                      inbuf[3]  =ky/100+48;
1253   4                      inbuf[4]  =(ky/10)%10+48;
1254   4                      inbuf[5]  ='.';
1255   4                      inbuf[6]  =ky%10+48;
1256   4                      inbuf[7] =0x0d;
1257   4                      inbuf[8] =0x0a;
1258   4                      send_string_com(inbuf,9);
1259   4                    }
1260   3                    else
1261   3                     alarm();
1262   3                 }
1263   2               }
1264   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
1265   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1266   1      
1267   1                 {
1268   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1269   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1270   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1271   2      
1272   2                    inbuf[4]='S';
1273   2                    inbuf[5]='=';
1274   2                    inbuf[6]=inbuf[6]+48;
1275   2                    inbuf[7]='.';
1276   2                    inbuf[8]=inbuf[8]+48;
1277   2                    inbuf[9]=inbuf[9]+48;
1278   2                    inbuf[10]=0x0d;
1279   2                    inbuf[11]=0x0a;
1280   2      
1281   2                    send_string_com(inbuf,12);
1282   2      
1283   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1284   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1285   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1286   2      
1287   2                    inbuf[4]='A';
1288   2                    inbuf[5]='=';
1289   2                    inbuf[6]=inbuf[6]+48;
1290   2                    inbuf[7]='.';
1291   2                    inbuf[8]=inbuf[8]+48;
1292   2                    inbuf[9]=inbuf[9]+48;
1293   2                    inbuf[10]=0x0d;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 22  

1294   2                    inbuf[11]=0x0a;
1295   2      
1296   2                    send_string_com(inbuf,12);
1297   2      
1298   2      
1299   2                 }
1300   1      
1301   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1302   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1303   1      
1304   1                 {
1305   2      
1306   2      
1307   2      
1308   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1309   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1310   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1311   2      
1312   2                    inbuf[4]='S';
1313   2                    inbuf[5]='=';
1314   2                    inbuf[6]=inbuf[6]+48;
1315   2                    inbuf[7]='.';
1316   2                    inbuf[8]=inbuf[8]+48;
1317   2                    inbuf[9]=inbuf[9]+48;
1318   2                    inbuf[10]=0x0d;
1319   2                    inbuf[11]=0x0a;
1320   2      
1321   2                    send_string_com(inbuf,12);
1322   2      
1323   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1324   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1325   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1326   2      
1327   2                    inbuf[4]='A';
1328   2                    inbuf[5]='=';
1329   2                    inbuf[6]=inbuf[6]+48;
1330   2                    inbuf[7]='.';
1331   2                    inbuf[8]=inbuf[8]+48;
1332   2                    inbuf[9]=inbuf[9]+48;
1333   2                    inbuf[10]=0x0d;
1334   2                    inbuf[11]=0x0a;
1335   2      
1336   2                    send_string_com(inbuf,12);
1337   2      
1338   2                 }
1339   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1340   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1341   1      
1342   1                 {
1343   2                    if (TMPGD1)
1344   2                    {
1345   3                      inbuf[4]='S';
1346   3                      inbuf[5]=' ';
1347   3                      inbuf[6]='O';
1348   3                      inbuf[7]='K';
1349   3                      inbuf[8]=0x0d;
1350   3                      inbuf[9]=0x0a;
1351   3                      send_string_com(inbuf,10);
1352   3                    }
1353   2      
1354   2                    else
1355   2                    {
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 23  

1356   3                      inbuf[4]='S';
1357   3                      inbuf[5]=' ';
1358   3                      inbuf[6]='N';
1359   3                      inbuf[7]='O';
1360   3                      inbuf[8]=0x0d;
1361   3                      inbuf[9]=0x0a;
1362   3                      send_string_com(inbuf,10);
1363   3                    }
1364   2      
1365   2                    if (TMPGD2)
1366   2                    {
1367   3                      inbuf[4]='A';
1368   3                      inbuf[5]=' ';
1369   3                      inbuf[6]='O';
1370   3                      inbuf[7]='K';
1371   3                      inbuf[8]=0x0d;
1372   3                      inbuf[9]=0x0a;
1373   3                      send_string_com(inbuf,10);
1374   3                    }
1375   2      
1376   2                    else
1377   2                    {
1378   3                      inbuf[4]='A';
1379   3                      inbuf[5]=' ';
1380   3                      inbuf[6]='N';
1381   3                      inbuf[7]='O';
1382   3                      inbuf[8]=0x0d;
1383   3                      inbuf[9]=0x0a;
1384   3                      send_string_com(inbuf,10);
1385   3                    }
1386   2      
1387   2                 }
1388   1      
1389   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1390   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1391   1      
1392   1                 {
1393   2                    if (SHDN1)
1394   2                    {
1395   3                      inbuf[0]='T';
1396   3                      inbuf[1]='E';
1397   3                      inbuf[2]='C';
1398   3                      inbuf[3]='1';
1399   3                      inbuf[4]=' ';
1400   3                      inbuf[5]='O';
1401   3                      inbuf[6]='N';
1402   3                      inbuf[7]=0x0d;
1403   3                      inbuf[8]=0x0a;
1404   3                      send_string_com(inbuf,9);
1405   3                    }
1406   2      
1407   2                    else
1408   2                    {
1409   3                      inbuf[0]='T';
1410   3                      inbuf[1]='E';
1411   3                      inbuf[2]='C';
1412   3                      inbuf[3]='1';
1413   3                      inbuf[4]=' ';
1414   3                      inbuf[5]='O';
1415   3                      inbuf[6]='F';
1416   3                      inbuf[7]='F';
1417   3                      inbuf[8]=0x0d;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 24  

1418   3                      inbuf[9]=0x0a;
1419   3                      send_string_com(inbuf,10);
1420   3                    }
1421   2      
1422   2                    if (SHDN2)
1423   2                    {
1424   3                      inbuf[0]='T';
1425   3                      inbuf[1]='E';
1426   3                      inbuf[2]='C';
1427   3                      inbuf[3]='2';
1428   3                      inbuf[4]=' ';
1429   3                      inbuf[5]='O';
1430   3                      inbuf[6]='N';
1431   3                      inbuf[7]=0x0d;
1432   3                      inbuf[8]=0x0a;
1433   3                      send_string_com(inbuf,9);
1434   3                    }
1435   2      
1436   2                    else
1437   2                    {
1438   3                      inbuf[0]='T';
1439   3                      inbuf[1]='E';
1440   3                      inbuf[2]='C';
1441   3                      inbuf[3]='2';
1442   3                      inbuf[4]=' ';
1443   3                      inbuf[5]='O';
1444   3                      inbuf[6]='F';
1445   3                      inbuf[7]='F';
1446   3                      inbuf[8]=0x0d;
1447   3                      inbuf[9]=0x0a;
1448   3                      send_string_com(inbuf,10);
1449   3                    }
1450   2                 }
1451   1      
1452   1      ///////////////////////////////////////////////////////////////////////////////////
1453   1      
1454   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1455   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1456   1      
1457   1                 {
1458   2                    if (CONT_MOD)
1459   2                    {
1460   3                      inbuf[0]='M';
1461   3                      inbuf[1]='O';
1462   3                      inbuf[2]='D';
1463   3                      inbuf[3]='=';
1464   3                      inbuf[4]='A';
1465   3                      inbuf[5]='P';
1466   3                      inbuf[6]='C';
1467   3                      inbuf[7]=0x0d;
1468   3                      inbuf[8]=0x0a;
1469   3                      send_string_com(inbuf,9);
1470   3                    }
1471   2      
1472   2                    else
1473   2                    {
1474   3                      inbuf[0]='M';
1475   3                      inbuf[1]='O';
1476   3                      inbuf[2]='D';
1477   3                      inbuf[3]='=';
1478   3                      inbuf[4]='A';
1479   3                      inbuf[5]='C';
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 25  

1480   3                      inbuf[6]='C';
1481   3                      inbuf[7]=0x0d;
1482   3                      inbuf[8]=0x0a;
1483   3                      send_string_com(inbuf,9);
1484   3                    }
1485   2                 }
1486   1      
1487   1      
1488   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1489   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1490   1            {
1491   2                 if(inbuf[6]==0x0d)
1492   2                    {
1493   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1494   3                       setsucced();
1495   3                    }
1496   2                 else
1497   2                    setfault();
1498   2            }
1499   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1500   1      
1501   1            else
1502   1             setfault();                              //设置错误
1503   1      
1504   1      
1505   1      
1506   1           return;
1507   1      
1508   1      }
1509          /*******************************************************************************/
1510          
1511          
1512          
1513          
1514          
1515          /*****************************设置显示****************************************
1516          void Lcd_disp()
1517          {
1518           wr_lcd (comm,0x30);                    //设定工作方式
1519           delay(1);
1520           wr_lcd (comm,0x01);                    //清屏
1521           delay(1);
1522           wr_lcd (comm,0x0d);                    //开显示
1523           delay(1);
1524           wr_lcd (comm,0x10);
1525           delay(30);
1526          
1527           if(CONT_MOD)                          //CONT_MOD: 1 APC, 0 ACC
1528          
1529          //*****************APC模式显示设定功率*********************************
1530           {
1531             chn_disp (tab13,8,0x80);
1532             delayR(50);
1533             chn_disp (Power_parameter1,6,0x84);
1534           }
1535          
1536          //********************************************************************
1537           else
1538          //****************ACC模式显示电流设定**********************************
1539           {
1540            chn_disp (tab9,8,0x80);
1541            delayR(50);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 26  

1542            chn_disp (Diode_parameter1,6,0x84);
1543          
1544           }
1545          //*********************************************************************
1546          
1547           delayR(50);
1548          
1549          //*****************显示设定温度****************************************
1550          
1551           delayR(50);
1552           chn_disp (TEC_parameter1,4,0x94);
1553           delayR(50);
1554           chn_disp (tab11,2,0x96);
1555           delayR(50);
1556          // wr_lcd (comm,0x90);
1557          //********************************************************************
1558          
1559          }
1560          /**************************************************************************
1561          
1562          
1563          /*****************************判断按键电压*********************************
1564          void Key_Button()
1565          {
1566            uchar kk=10;
1567            uchar tec_a=0;
1568            uchar tec_b=0;
1569            Key_V=0;
1570          
1571          
1572          
1573          
1574            return;
1575          }
1576          
1577          /**************************************************************************/
1578          
1579          /**********************二极管电流监测**************************************/
1580          void Diode_curent_Check()
1581          {
1582   1          uchar k=16;
1583   1      //    float a,b;
1584   1          AD_inbuf[0]=0;
1585   1          AD_inbuf[1]=0;
1586   1          do
1587   1          {
1588   2            AD_code=AD_Convert(0);                  //种子源电流
1589   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
1590   2      
1591   2            AD_code=AD_Convert(3);                  //放大级电流
1592   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
1593   2      
1594   2            k--;
1595   2          }while(k);
1596   1      
1597   1      
1598   1          AD_inbuf[0]=AD_inbuf[0]/16;
1599   1          AD_inbuf[1]=AD_inbuf[1]/16;
1600   1      
1601   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
1602   1          Laser_meds_curent1=Laser_Fed_curent1;
1603   1          if (Laser_Fed_curent1<10)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 27  

1604   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
1605   2              Diode_parameter1[1]=0x6d;
1606   2              Diode_parameter1[2]=0x41;
1607   2              Diode_parameter1[3]=0x20;
1608   2              Diode_parameter1[4]=0x20;
1609   2      
1610   2            } else if(Laser_Fed_curent1<100)
1611   1      
1612   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
1613   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
1614   2              Diode_parameter1[2]=0x6d;
1615   2              Diode_parameter1[3]=0x41;
1616   2              Diode_parameter1[4]=0x20;
1617   2            } else if(Laser_Fed_curent1<1000)
1618   1      
1619   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
1620   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
1621   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
1622   2              Diode_parameter1[3]=0x6d;
1623   2              Diode_parameter1[4]=0x41;
1624   2            }
1625   1      
1626   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
1627   1          Laser_meds_curent2=Laser_Fed_curent2;
1628   1          if (Laser_Fed_curent2<10)
1629   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
1630   2              Diode_parameter2[1]=0x6d;
1631   2              Diode_parameter2[2]=0x41;
1632   2              Diode_parameter2[3]=0x20;
1633   2              Diode_parameter2[4]=0x20;
1634   2      
1635   2            } else if(Laser_Fed_curent2<100)
1636   1      
1637   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
1638   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
1639   2              Diode_parameter2[2]=0x6d;
1640   2              Diode_parameter2[3]=0x41;
1641   2              Diode_parameter2[4]=0x20;
1642   2            } else if(Laser_Fed_curent2<1000)
1643   1      
1644   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
1645   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
1646   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
1647   2              Diode_parameter2[3]=0x6d;
1648   2              Diode_parameter2[4]=0x41;
1649   2            }
1650   1      
1651   1          return;
1652   1      }
1653          /**************************************************************************/
1654          /*****************************激光功率检测*********************************/
1655          void Laser_power_Check()
1656          {
1657   1      
1658   1          uchar k=10;
1659   1          float a,b;
1660   1          AD_inbuf[8]=0;
1661   1          AD_inbuf[9]=0;
1662   1          do
1663   1          {
1664   2            AD_code=AD_Convert(1);                  //种子源
1665   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 28  

1666   2      
1667   2            AD_code=AD_Convert(4);                  //放大级
1668   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
1669   2            k--;
1670   2          }while(k);
1671   1      
1672   1      
1673   1      
1674   1          AD_inbuf[8]=AD_inbuf[8]/10;
1675   1          AD_inbuf[9]=AD_inbuf[9]/10;
1676   1      
1677   1          AD_code=AD_inbuf[8];
1678   1          a=(float)(AD_code);
1679   1          a=a*2.5;
1680   1          a=a/4096+0.02015;
1681   1          b=a*a*117.314+275.543*a-0.806;
1682   1      
1683   1          Laser_Fed_power1=(uint)(b);
1684   1          Laser_meds_power1=Laser_Fed_power1;
1685   1      
1686   1          if (Laser_Fed_power1<10)
1687   1            { Power_parameter1[0]=Laser_Fed_power1+48;
1688   2              Power_parameter1[1]=0x6d;
1689   2              Power_parameter1[2]=0x77;
1690   2              Power_parameter1[3]=0x20;
1691   2              Power_parameter1[4]=0x20;
1692   2              Power_parameter1[5]=0x20;
1693   2      
1694   2            } else if(Laser_Fed_power1<100)
1695   1      
1696   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
1697   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
1698   2              Power_parameter1[2]=0x6d;
1699   2              Power_parameter1[3]=0x77;
1700   2              Power_parameter1[4]=0x20;
1701   2              Power_parameter1[5]=0x20;
1702   2            } else if(Laser_Fed_power1<1000)
1703   1      
1704   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
1705   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
1706   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
1707   2              Power_parameter1[3]=0x6d;
1708   2              Power_parameter1[4]=0x77;
1709   2              Power_parameter1[5]=0x20;
1710   2            }
1711   1      
1712   1          AD_code=AD_inbuf[9];
1713   1          a=(float)(AD_code);
1714   1          a=a*2.5;
1715   1          a=a/4096+0.02015;
1716   1          b=a*a*117.314+275.543*a-0.806;
1717   1      
1718   1          Laser_Fed_power2=(uint)(b);
1719   1          Laser_meds_power2=Laser_Fed_power2;
1720   1      
1721   1          if (Laser_Fed_power2<10)
1722   1            { Power_parameter2[0]=Laser_Fed_power2+48;
1723   2              Power_parameter2[1]=0x6d;
1724   2              Power_parameter2[2]=0x77;
1725   2              Power_parameter2[3]=0x20;
1726   2              Power_parameter2[4]=0x20;
1727   2              Power_parameter2[5]=0x20;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 29  

1728   2      
1729   2            } else if(Laser_Fed_power2<100)
1730   1      
1731   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
1732   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
1733   2              Power_parameter2[2]=0x6d;
1734   2              Power_parameter2[3]=0x77;
1735   2              Power_parameter2[4]=0x20;
1736   2              Power_parameter2[5]=0x20;
1737   2            } else if(Laser_Fed_power2<1000)
1738   1      
1739   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
1740   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
1741   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
1742   2              Power_parameter2[3]=0x6d;
1743   2              Power_parameter2[4]=0x77;
1744   2              Power_parameter2[5]=0x20;
1745   2            }
1746   1      
1747   1          return;
1748   1      
1749   1      
1750   1      
1751   1      }
1752          /**************************************************************************/
1753          
1754          
1755          /*****************************当前冷却温度*********************************/
1756          void TEC_Temp()
1757          {
1758   1          uint  tx1=0;
1759   1          uint  tx2=0;
1760   1          uchar kt=16;
1761   1          AD_inbuf[6]=0;
1762   1          AD_inbuf[7]=0;
1763   1          do
1764   1          {
1765   2            AD_code=AD_Convert(2);        //种子源TEC温度
1766   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
1767   2      
1768   2            AD_code=AD_Convert(5);        //放大级TEC温度
1769   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
1770   2            kt--;
1771   2          }while(kt);
1772   1      
1773   1           AD_inbuf[6]=AD_inbuf[6]/16;
1774   1           AD_inbuf[7]=AD_inbuf[7]/16;
1775   1           TEC_meds_tempture1=AD_inbuf[6];
1776   1           TEC_meds_tempture2=AD_inbuf[7];
1777   1      
1778   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
1779   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
1780   1           tx1= (uint)(TEC_Fed_Tempture1);
1781   1           TEC_meds_tempture1=tx1;
1782   1           tx2= (uint)(TEC_Fed_Tempture2);
1783   1           TEC_meds_tempture2=tx2;
1784   1      
1785   1           TEC_parameter1[0]=tx1 /100+48;
1786   1           TEC_parameter1[1]=(tx1 /10)%10+48;
1787   1           TEC_parameter1[2]=0x2e;
1788   1           TEC_parameter1[3]=tx1 %10+48;
1789   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 30  

1790   1      
1791   1           TEC_parameter2[0]=tx2 /100+48;
1792   1           TEC_parameter2[1]=(tx2 /10)%10+48;
1793   1           TEC_parameter2[2]=0x2e;
1794   1           TEC_parameter2[3]=tx2 %10+48;
1795   1      
1796   1      
1797   1        return;
1798   1      }
1799          
1800          /**************************************************************************/
1801          
1802          /*****************************当前TEC两端电压******************************/
1803          void TEC_V_Check()                                                 //???????????????????????
1804          {
1805   1          uchar kk=20;
1806   1          AD_inbuf[4]=0;
1807   1          AD_inbuf[5]=0;
1808   1          do
1809   1          {
1810   2            MCU_ADC(1);
1811   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
1812   2            MCU_ADC(2);
1813   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
1814   2            kk--;
1815   2          }while(kk);
1816   1      
1817   1      
1818   1           TEC_VO1=AD_inbuf[4]/20 ;
1819   1           TEC_VO1=TEC_VO1*5;
1820   1           TEC_VO2=AD_inbuf[4]/20 ;
1821   1           TEC_VO2=TEC_VO2*5;
1822   1      
1823   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
1824   1      //     TEC_parameter[1]=0x2e;
1825   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
1826   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
1827   1      //     TEC_parameter[4]=0xa0;
1828   1      //     TEC_parameter[5]=0x56;
1829   1          return;
1830   1      }
1831          
1832          /**************************************************************************/
1833          
1834          /*****************************监测二极管电压******************************/
1835          void Pdiod_V_Check()
1836          {
1837   1          uchar kk=10;
1838   1          AD_inbuf[2]=0;
1839   1          AD_inbuf[3]=0;
1840   1          do
1841   1          {
1842   2            AD_code=AD_Convert(1);             //种子源激光二极管
1843   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
1844   2      
1845   2            AD_code=AD_Convert(4);             //放大级激光二极管
1846   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
1847   2            kk--;
1848   2          }while(kk);
1849   1      
1850   1           PDiode_V1= AD_inbuf[2]/10;
1851   1           PDiode_V2= AD_inbuf[3]/10;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 31  

1852   1           PDiode_V1=(PDiode_V1*5)/2;
1853   1           PDiode_V2=(PDiode_V2*5)/2;
1854   1          return;
1855   1      }
1856          /**************************************************************************/
1857          
1858          
1859          
1860          /*******************************设定温度值*************************************
1861          
1862          void Set_TEC_TEMP(uint tempture)
1863          {
1864               uint kt;
1865          
1866                kt=(uint)((tempture-15)*4096/35);
1867                DA_Convert(1,kt);
1868          
1869          
1870          
1871          
1872             return;
1873          }
1874          
1875          
1876          /******************************************************************************/
1877          
1878          /*****************************设定功率值**********************************/
1879          void Set_laser_power(uchar Channel,uint power)
1880          {
1881   1        float  u,v;
1882   1        uint   temp_p;
1883   1      
1884   1        if (power<3) power=3;
1885   1        if (power>600) power=600;
1886   1        u=(float)(power);
1887   1        v=(u*u/1000)*3.46;
1888   1        v=6.5068*u+29.61-v;
1889   1        temp_p=(uint)(v);
1890   1      
1891   1      
1892   1        if(Channel==3)                                         //设定种子源功率
1893   1        {
1894   2      
1895   2          if(SHDN1)
1896   2           {
1897   3      
1898   3                DA_Convert(3,temp_p);
1899   3                _Nop();
1900   3                DA_Convert(3,temp_p);
1901   3           }
1902   2      
1903   2           Laser_Set_power1=power;
1904   2         }
1905   1      
1906   1      
1907   1          else if(Channel==0)
1908   1        {
1909   2      
1910   2          if(SHDN2)                                             //设定放大级功率
1911   2           {
1912   3      
1913   3                DA_Convert(0,temp_p);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 32  

1914   3                _Nop();
1915   3                DA_Convert(0,temp_p);
1916   3           }
1917   2      
1918   2           Laser_Set_power2=power;
1919   2         }
1920   1      
1921   1         else  _Nop();
1922   1      
1923   1         Laser_power_Check();
1924   1      
1925   1      
1926   1          return;
1927   1      
1928   1      }
1929          
1930          
1931          /*************************************************************************/
1932          
1933          /*****************************设定电流值**********************************/
1934          
1935          void Set_laser_current(uchar Channel,uint current)
1936          {
1937   1      
1938   1          uint tmp_c1;
1939   1      
1940   1          if (current<30) current=30;
1941   1          if (current>900) current=900;
1942   1      
1943   1      
1944   1      
1945   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
1946   1      
1947   1      
1948   1      
1949   1      
1950   1      
1951   1          if(Channel==3)
1952   1          {
1953   2             if(SHDN1)
1954   2             {
1955   3      
1956   3                  DA_Convert(3,tmp_c1);
1957   3                  _Nop();
1958   3                  DA_Convert(3,tmp_c1);
1959   3      
1960   3                  Laser_Set_curent1=current;
1961   3             }
1962   2      
1963   2             _Nop();
1964   2          }
1965   1      
1966   1          else if(Channel==0)
1967   1          {
1968   2             if(SHDN2)
1969   2             {
1970   3      
1971   3                  DA_Convert(0,tmp_c1);
1972   3                  _Nop();
1973   3                  DA_Convert(0,tmp_c1);
1974   3      
1975   3                  Laser_Set_curent2=current;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 33  

1976   3             }
1977   2      
1978   2             _Nop();
1979   2          }
1980   1      
1981   1      
1982   1      
1983   1      
1984   1      /*
1985   1        if (tmp_c1>tmp_c0)
1986   1          {
1987   1            do
1988   1            {
1989   1      
1990   1              while(!TMPGD)
1991   1              {
1992   1                TEC_Temp();
1993   1                if(tx>280)
1994   1              {
1995   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
1996   1                send_string_com(inbuf1,9);
1997   1                t=0;
1998   1                SHDN=0;
1999   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
2000   1                tmp_c1=246;
2001   1                Laser_Set_curent=30;
2002   1                 do
2003   1               {
2004   1                tmp_c0=tmp_c0-2;
2005   1                DA_Convert(0,tmp_c0);
2006   1                m++;
2007   1      
2008   1                 if(m==240)
2009   1                 {
2010   1                  Diode_curent_Check();
2011   1                  TEC_Temp();
2012   1                  chn_disp (tab6,6,0x80);
2013   1                  delayR(500);
2014   1                  chn_disp (Diode_parameter,6,0x83);
2015   1                  delayR(500);
2016   1                  chn_disp (tab7,4,0x90);
2017   1                  delayR(500);
2018   1                  chn_disp (TEC_parameter,4,0x92);
2019   1                  delayR(100);
2020   1                  chn_disp (tab11,2,0x94);
2021   1                  m=0;
2022   1                 }
2023   1                 delayR(10000);
2024   1                 }while(tmp_c0-tmp_c1);
2025   1                 chn_disp (inbuf1,7,0x96);
2026   1                 goto quit;
2027   1               }
2028   1              }
2029   1      
2030   1      
2031   1              
2032   1      
2033   1      
2034   1           if(m==160)
2035   1          {
2036   1           TEC_Temp();
2037   1           Diode_curent_Check();
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 34  

2038   1           chn_disp (tab6,6,0x80);
2039   1           delayR(500);
2040   1           chn_disp (Diode_parameter,6,0x83);
2041   1           delayR(500);
2042   1           chn_disp (tab7,4,0x90);
2043   1           delayR(500);
2044   1           chn_disp (TEC_parameter,4,0x92);
2045   1           delayR(100);
2046   1           chn_disp (tab11,2,0x94);
2047   1           m=0;
2048   1          }
2049   1      
2050   1      
2051   1      
2052   1      
2053   1      
2054   1      
2055   1      
2056   1             delayR(10000);
2057   1            }while((tmp_c1-tmp_c0)&& SHDN);
2058   1      
2059   1             delayR(180);
2060   1      
2061   1          }
2062   1        else if(tmp_c1<tmp_c0)
2063   1      
2064   1          {
2065   1             do
2066   1            {
2067   1              
2068   1           if(m==160)
2069   1           {
2070   1           Diode_curent_Check();
2071   1           TEC_Temp();
2072   1           chn_disp (tab6,6,0x80);
2073   1           delayR(500);
2074   1           chn_disp (Diode_parameter,6,0x83);
2075   1           delayR(500);
2076   1           chn_disp (tab7,4,0x90);
2077   1           delayR(500);
2078   1           chn_disp (TEC_parameter,4,0x92);
2079   1           delayR(100);
2080   1           chn_disp (tab11,2,0x94);
2081   1           m=0;
2082   1           }
2083   1           delayR(10000);
2084   1            }while(tmp_c0-tmp_c1);
2085   1      
2086   1           delay(100);
2087   1      
2088   1          }        */
2089   1          Diode_curent_Check();
2090   1      
2091   1      
2092   1          return;
2093   1      
2094   1      }
2095          
2096          /***************************************************************************/
2097          
2098          /*****************************外部AD转换程序*******************************/
2099          uint AD_Convert(uchar Channel)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 35  

2100          {
2101   1         uchar i,Dath,Datl,temp,Contbit;
2102   1         uint Dat_ad;
2103   1         Dath=0;
2104   1         Datl=0;
2105   1         temp=0;
2106   1         Dat_ad=0;
2107   1         switch (Channel)                        //  内部REF
2108   1          {
2109   2              case 0:Contbit=0x00;break;
2110   2              case 1:Contbit=0x08;break;
2111   2              case 2:Contbit=0x10;break;
2112   2              case 3:Contbit=0x18;break;
2113   2              case 4:Contbit=0x20;break;
2114   2              case 5:Contbit=0x28;break;
2115   2              case 6:Contbit=0x30;break;
2116   2              case 7:Contbit=0x38;break;
2117   2              default: break;
2118   2          }
2119   1      
2120   1          CSAD=0;
2121   1          _Nop();
2122   1          DCLK=1;
2123   1      
2124   1         for(i=0;i<8;i++)
2125   1         {
2126   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
2127   2      
2128   2            DCLK=0;
2129   2            _Nop();
2130   2            DCLK=1;
2131   2            _Nop();
2132   2      
2133   2         }
2134   1      
2135   1          CSAD=1;
2136   1          _Nop();
2137   1      
2138   1          CSAD=0;
2139   1          _Nop();
2140   1      
2141   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
2142   1          {
2143   2            ADIN=(bit)(Contbit&(0x80>>i));
2144   2      
2145   2            DCLK=0;
2146   2            _Nop();
2147   2            DCLK=1;
2148   2            _Nop();
2149   2            Dath=DOUT;
2150   2            Dath=Dath<<(7-i);
2151   2            temp=temp|Dath;
2152   2          }
2153   1      
2154   1           Dath=temp;
2155   1           temp=0;
2156   1          for(i=0;i<8;i++)
2157   1          {
2158   2            DCLK=0;
2159   2            _Nop();
2160   2            DCLK=1;
2161   2            Datl=DOUT;
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 36  

2162   2            Datl=Datl<<(7-i);
2163   2            temp=temp|Datl;
2164   2            _Nop();
2165   2      
2166   2          }
2167   1      
2168   1           Datl=temp;
2169   1           Dat_ad=(Dath*256+Datl)&0x0fff;
2170   1      
2171   1           CSAD=1;
2172   1      
2173   1      
2174   1      
2175   1            _Nop();
2176   1      
2177   1            return(Dat_ad);
2178   1      }
2179          
2180          
2181          
2182          /**************************************************************************/
2183          /*****************************外部PWM设置程序*******************************/
2184          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
2185          { 
2186   1        uchar pulserate,pulsewidth,pulsedelay;
2187   1      
2188   1        if (pwm_pulserate>0)
2189   1        {
2190   2          //pulserate=1000000/pwm_pulserate/12.5/32;             //80M晶振
2191   2          //pulserate=1000000/pwm_pulserate/8/32;             //125M晶振
2192   2          pulserate=1000000/pwm_pulserate/5/32;             //200M晶振
2193   2          if(pulserate>255)
2194   2            pulserate=255;
2195   2          P0=pulserate;
2196   2          RW=1;
2197   2      
2198   2          RS=0;
2199   2          delayR(10);
2200   2          ENAB=1;
2201   2          delayR(10);
2202   2          ENAB=0;
2203   2          delayR(10);
2204   2          RW=0;
2205   2          RS=0;
2206   2        }
2207   1        
2208   1        if (pwm_pulsewidth>0)
2209   1        {
2210   2          pulsewidth=pwm_pulsewidth   ;      //80M晶振
2211   2          if (pulsewidth>15)
2212   2            pulsewidth=15;
2213   2          P0=pulsewidth;
2214   2          RW=0;
2215   2          RS=1;
2216   2          delayR(10);
2217   2          ENAB=1;
2218   2          delayR(10);
2219   2          ENAB=0;
2220   2          delayR(10);
2221   2          RW=0;
2222   2          RS=0;
2223   2        }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 37  

2224   1        
2225   1        if (pwm_pulsedelay>0)
2226   1        {
2227   2          pulsedelay= pwm_pulsedelay ;                 //80M晶振
2228   2          if (pulsedelay>31)
2229   2            pulsedelay=31;
2230   2          P0=pulsedelay;
2231   2          RW=1;
2232   2          RS=1;
2233   2          delayR(10);
2234   2          ENAB=1;
2235   2          delayR(10);
2236   2          ENAB=0;
2237   2          delayR(10);
2238   2          RW=0;
2239   2          RS=0;
2240   2          
2241   2      
2242   2      
2243   2        }
2244   1      
2245   1      
2246   1      
2247   1      }
2248          /**************************************************************************/
2249          /*****************************外部DA转换程序*******************************/
2250          void DA_Convert(uchar Channel, uint Dcode)
2251          {
2252   1      
2253   1        uint  Comdat=0;
2254   1         uchar i;
2255   1         switch (Channel)
2256   1          {
2257   2              case 0:Comdat=Dcode+0x1000;break;
2258   2              case 1:Comdat=Dcode+0x5000;break;
2259   2              case 2:Comdat=Dcode+0x9000;break;
2260   2              case 3:Comdat=Dcode+0xd000;break;
2261   2              default: break;
2262   2          }
2263   1      
2264   1          LDAC=1;                               //数据刷新
2265   1          _Nop();
2266   1          CSDA=0;                               //片选有效
2267   1          FS=1;
2268   1          _Nop();
2269   1          FS=0;
2270   1         for(i=0;i<16;i++)
2271   1        {
2272   2             DINDA=(bit)(Comdat&0x8000);
2273   2             SCLK=1;
2274   2             Comdat=Comdat<<1;
2275   2             _Nop();
2276   2             SCLK=0;
2277   2      
2278   2         }
2279   1      
2280   1         LDAC=0;
2281   1         _Nop();
2282   1         CSDA=1;                             //片选无效
2283   1         Dcode=0;
2284   1        return;
2285   1      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 38  

2286   1      }
2287          /**************************************************************************/
2288          
2289          
2290          /*****************************单片机内部AD********************************/
2291           void MCU_ADC(BYTE CHN)
2292           {
2293   1          BYTE    AD_finished;
2294   1          switch (CHN)
2295   1          {
2296   2              case 0: P1ASF=0x01;break;
2297   2              case 1: P1ASF=0x02;break;
2298   2              case 2:P1ASF=0x04;break;
2299   2              case 3:P1ASF=0x08;break;
2300   2              case 7:P1ASF=0x80;break;
2301   2      
2302   2              default: break;
2303   2          }
2304   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
2305   1          ADC_RES=0;
2306   1          ADC_RESL=0;
2307   1      
2308   1          CHN &= 0x07;                        //0000,0111 清0高5位
2309   1      
2310   1          ADC_CONTR =ADC_SPEEDH ;
2311   1          _nop_();
2312   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
2313   1          _nop_();
2314   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
2315   1          delayR(10);
2316   1          ADC_CONTR |= 0x08;
2317   1          delayR(10);
2318   1          AD_finished = 0;
2319   1          while (AD_finished ==0 )            //等待A/D转换结束
2320   1          {
2321   2            AD_finished = (ADC_CONTR & 0x10);
2322   2          }
2323   1          ADC_CONTR &= 0xE7;
2324   1      
2325   1          P1ASF=0x00;
2326   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
2327   1      
2328   1          return;
2329   1       }
2330          
2331          /*************************************************************************/
2332          
2333          
2334          
2335          void Error_Process()
2336          {
2337   1      
2338   1       _Nop();
2339   1       return;
2340   1      
2341   1      }
2342          
2343          
2344          
2345          /*********以下是长延时程序***********************************************/
2346          
2347          void delay(uint delay_k)
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 39  

2348          {
2349   1          uint k0=0;
2350   1          do
2351   1          {
2352   2          do{k0--;}while(k0);
2353   2          delay_k--;
2354   2          }while(delay_k);
2355   1      
2356   1      }
2357          
2358          /*********以下是短延时程序***********************************************/
2359          void delayR(uint delay_k)
2360          {
2361   1          do{delay_k--;}while(delay_k);
2362   1      
2363   1      
2364   1      }
2365          
2366          /*********************************************************************/
2367          
2368          /**************************以下是外部中断0程序************************/
2369           void INT_0() interrupt 0 using 0
2370           {
2371   1          if (!LIM1)
2372   1          Error_Process();
2373   1          else  _Nop();
2374   1      
2375   1          if (!LIM2)
2376   1          Error_Process();
2377   1          else  _Nop();
2378   1          return;
2379   1       }
2380          /*********************************************************************/
2381          
2382          /***************************以下是外部中断1程序***********************/
2383          void INT_1() interrupt 2 using 1
2384          {
2385   1        _Nop();
2386   1        //chn_disp (tab16,20,0x80);
2387   1        //delayR(10000);
2388   1        //chn_disp (tab17,20,0x90);
2389   1        //delay(1000);
2390   1      }
2391          /***********************************************************************/
2392          
2393          
2394          
2395          
2396          
2397          /*****************以下是串口中断程序*******************************/
2398          
2399          void RS232() interrupt 4 using 3
2400          {
2401   1      
2402   1         if(RI)
2403   1         {
2404   2              RI=0;
2405   2      
2406   2              if (SBUF==0x0A)
2407   2              {
2408   3                   read_flag=1;
2409   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 40  

2410   3                }
2411   2      
2412   2              else
2413   2              {
2414   3      
2415   3      
2416   3                   inbuf[t]=SBUF;
2417   3                   t++;
2418   3      
2419   3      
2420   3      
2421   3              }
2422   2      
2423   2         }
2424   1      
2425   1           return;
2426   1      }
2427          
2428          /**********************************************************************/
2429          
2430          /*****************定时器中断程序*******************************/
2431          
2432          void tm0_isr() interrupt 1 using 1
2433          {               
2434   1           TL0 = 0x30;   //设置定时初值
2435   1           TH0 = 0xF8;   //设置定时初值
2436   1           if (count-- == 0)               //1ms * 1000 -> 1s
2437   1           {
2438   2           count = 1000;               //reset counter
2439   2           }
2440   1      }
2441          
2442          /*************************设置错误***************************/
2443          void setfault()
2444          {
2445   1      
2446   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
2447   1      
2448   1        send_string_com(inbuf1,10);
2449   1      
2450   1        t=0;
2451   1      }
2452          /*************************************************************/
2453          
2454          
2455          /*************************设置成功***************************/
2456          void setsucced()
2457          {
2458   1      
2459   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
2460   1      
2461   1        send_string_com(inbuf1,11);
2462   1        t=0;
2463   1        return;
2464   1      }
2465          /*************************************************************/
2466          
2467          
2468          
2469          
2470          
2471          
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 41  

2472          /********************************警告*************************/
2473          void alarm()
2474          {
2475   1         uchar t=6;
2476   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
2477   1      
2478   1         send_string_com(inbuf1,7);
2479   1        do
2480   1        {
2481   2         delay(50);
2482   2         t--;
2483   2        }while(t);
2484   1         send_string_com(inbuf1,5);
2485   1         t=6;
2486   1         do
2487   1        {
2488   2         delay(50);
2489   2         t--;
2490   2        }while(t);
2491   1         send_string_com(inbuf1,5);
2492   1      
2493   1      }
2494          /*************************************************************/
2495          
2496          
2497          
2498          /************************主程序*******************************/
2499          void main()
2500          {
2501   1         uchar  i=10;
2502   1         uchar  tmp0=0;
2503   1      // setsucced();
2504   1      // delay(5000);
2505   1      // setsucced();
2506   1      // delay(5000);
2507   1      // setsucced();
2508   1         stat_initial();                               //状态初始划
2509   1         serial_initial();                             //串口初始化
2510   1      // delay(20000);
2511   1      // setsucced();
2512   1      // delay(5000);
2513   1      // setsucced();
2514   1      // delay(5000);
2515   1      // setsucced();
2516   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2517   1      
2518   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2519   1       {
2520   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2521   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2522   2      
2523   2        DA_Convert(3,25);                          // 种子源
2524   2         _Nop();
2525   2        DA_Convert(3,25);
2526   2      
2527   2        DA_Convert(0,25);                          // 放大级
2528   2         _Nop();
2529   2        DA_Convert(0,25);
2530   2       }
2531   1      //////////////////////////////////////////////////////////////////////////////////////////////
2532   1      
2533   1        else
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 42  

2534   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2535   1       {
2536   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2537   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
2538   2      
2539   2        DA_Convert(3,88);                            // 种子源
2540   2         _Nop();
2541   2        DA_Convert(3,88);
2542   2      
2543   2        DA_Convert(0,88);                            // 放大级
2544   2        _Nop();
2545   2        DA_Convert(0,88);
2546   2       }
2547   1      //////////////////////////////////////////////////////////////////////////////////////////////
2548   1      ///////////////////////////////////上电开始显示//////////////////////////////////////////////tang
2549   1       /*  init_lcd ();
2550   1         delay(5);
2551   1         wr_lcd (comm,0x30);
2552   1         delay(30);                                    //需要足够的等待延时
2553   1         chn_disp (tab1,14,0x80);
2554   1         delay(5);
2555   1         chn_disp (tab2,20,0x90);
2556   1         delay(5);
2557   1         clrram();
2558   1         delay(5);
2559   1         chn_disp (tab3,10,0x80);
2560   1         chn_disp (tab4,12,0x90);
2561   1      
2562   1         clrram();
2563   1         delay(10);
2564   1         chn_disp (tab5,10,0x80);
2565   1         delay(5);
2566   1      */////////////////////////////////////////////////////////////////////////////////////////////
2567   1      
2568   1      
2569   1      
2570   1        do
2571   1         {
2572   2      
2573   2           delay(1);
2574   2      
2575   2           if(read_flag)
2576   2            {
2577   3              command();                        //指令识别
2578   3              read_flag=0;                      //取数标志清0
2579   3              t=0;
2580   3            }
2581   2      
2582   2           _Nop();
2583   2      
2584   2      
2585   2          if(Sys_mod)
2586   2       {
2587   3      
2588   3      
2589   3      /***************************检查按键**************************************/
2590   3      
2591   3       // Key_Button();  tang
2592   3      
2593   3      
2594   3      ///////////////////////////////////////////////////////////////////////////
2595   3      
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 43  

2596   3      /***************************检查当前实际功率值****************************/
2597   3       //Laser_power_Check(); tang
2598   3      
2599   3      
2600   3      /*************************************************************************/
2601   3      /***************************检测当前实际电流值****************************/
2602   3      
2603   3       Diode_curent_Check();
2604   3      
2605   3      
2606   3      
2607   3      
2608   3      ///////////////////////////////////////////////////////////////////////////
2609   3      
2610   3      
2611   3      /***************************检测当前冷却温度******************************/
2612   3         TEC_Temp();
2613   3      
2614   3      
2615   3      
2616   3         if(TEC_meds_tempture1>350)
2617   3      
2618   3         {
2619   4      
2620   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2621   4           if(CONT_MOD)
2622   4           {
2623   5           Set_laser_power(0,3);       //tang
2624   5           Set_laser_power(3,3);
2625   5           }
2626   4           else
2627   4           {
2628   5           Set_laser_current(0,30);
2629   5           Set_laser_current(3,30);
2630   5           }
2631   4           SHDN1=0;
2632   4           SHDN2=0;
2633   4           send_string_com(inbuf1,9);
2634   4           t=0;
2635   4           }
2636   3      
2637   3         if(TEC_meds_tempture2>350)
2638   3      
2639   3         {
2640   4      
2641   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2642   4           if(CONT_MOD)
2643   4           {
2644   5           Set_laser_power(0,3);       //tang
2645   5           Set_laser_power(3,3);
2646   5           }
2647   4           else
2648   4           {
2649   5           Set_laser_current(0,30);
2650   5           Set_laser_current(3,30);
2651   5           }
2652   4           SHDN1=0;
2653   4           
2654   4           SHDN2=0;
2655   4           send_string_com(inbuf1,9);
2656   4           t=0;
2657   4         }
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 44  

2658   3      //////////////////////////////////////////////////////////////////////////
2659   3      
2660   3      
2661   3      /***************************检测监测二极管反馈电压************************/
2662   3      
2663   3       Pdiod_V_Check();
2664   3      
2665   3      
2666   3      
2667   3      //////////////////////////////////////////////////////////////////////////
2668   3      
2669   3      
2670   3      /***************************检测TEC温控是否完成**************************/
2671   3      
2672   3      
2673   3      
2674   3      
2675   3      
2676   3      /////////////////////////////////////////////////////////////////////////
2677   3      
2678   3      
2679   3      /***************************检测TEC两端电压是否正常*********************/
2680   3      
2681   3        TEC_V_Check();
2682   3      
2683   3        if( TEC_VO1>3.1) Error_Process();
2684   3        if( TEC_VO2>3.1) Error_Process();
2685   3      
2686   3      ////////////////////////////////////////////////////////////////////////
2687   3      
2688   3      
2689   3      /****************************LCD显示***********************************
2690   3      
2691   3      
2692   3           chn_disp (tab6,4,0x80);
2693   3           delayR(50);
2694   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2695   3           delayR(50);
2696   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2697   3      
2698   3      
2699   3           chn_disp (tab7,4,0x90);
2700   3           delayR(50);
2701   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2702   3           delayR(50);
2703   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2704   3      
2705   3      
2706   3      
2707   3      
2708   3      
2709   3           if(CONT_MOD)
2710   3           {
2711   3              chn_disp (tab14,6,0x87);
2712   3              delayR(50);
2713   3              chn_disp (tab14,6,0x97);
2714   3            }
2715   3           else
2716   3           {
2717   3              chn_disp (tab15,6,0x87);
2718   3              delayR(50);
2719   3              chn_disp (tab15,6,0x97);
C51 COMPILER V7.02b   DUALDRIVER_GBK                                                       01/17/2014 11:25:52 PAGE 45  

2720   3           }
2721   3      
2722   3      //////////////////////////////////////////////////////////////////////*/
2723   3      }
2724   2      
2725   2      else
2726   2      {
2727   3          // chn_disp (tab16,20,0x80);
2728   3         // delayR(10000);
2729   3          // chn_disp (tab17,20,0x90);
2730   3      }
2731   2      
2732   2          }while(1);
2733   1      
2734   1      
2735   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9144    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47      92
   IDATA SIZE       =    114    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

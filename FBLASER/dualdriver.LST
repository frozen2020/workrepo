C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 1   


C51 COMPILER V7.02b, COMPILATION OF MODULE DUALDRIVER
OBJECT MODULE PLACED IN dualdriver.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE dualdriver.C BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /*双路光纤激光器控制器固件驱动程序       作者：许卫星
   2          /* 晶振频率24M*/
   3          
   4          #include<stdio.h>
   5          #include<math.h>
   6          #include<intrins.h>
   7          #include<STC_NEW_8051.h>
   8          
   9          
  10          #define  _Nop() _nop_()              // 定义空指令
  11          #define  uchar unsigned char
  12          #define  uint  unsigned int
  13          typedef unsigned char BYTE;
  14          #define  INBUF_LEN 15                //数据长度
  15          #define comm  0
  16          #define dat   1
  17          
  18          
  19          uchar  inbuf0[INBUF_LEN];            //读取数据缓冲区
  20          uchar  inbuf[INBUF_LEN];             //处理数据缓冲区
  21          uint   idata AD_inbuf[10];           //AD采集数据
  22          
  23          uchar code tab1[]={"光纤激光控制器"};
  24          uchar code tab2[]={"苏州德龙激光有限公司"};
  25          uchar code tab3[]={"正在初始化"};
  26          uchar code tab4[]={"请稍候......"};
  27          uchar code tab5[]={"初始化完成"};
  28          uchar code tab6[]={"SED:"};
  29          uchar code tab7[]={"AMP:"};
  30          uchar code tab8[]={"VOTEC:1.42v"};
  31          
  32          uchar code tab9[]={"设定电流"};
  33          uchar code tab10[]={"设定温度"};
  34          uchar code tab11[]={"℃"};
  35          uchar code tab12[]={"POW:"};
  36          uchar code tab13[]={"设定功率"};
  37          uchar code tab14[]={"℃ APC"};
  38          uchar code tab15[]={"℃ ACC"};
  39          uchar code tab16[]={"系统采集控制模式中  "};
  40          uchar code tab17[]={"...................."};
  41          uchar idata  TEC_parameter1[6];
  42          uchar idata  TEC_parameter2[6];
  43          uchar idata  Diode_parameter1[6];
  44          uchar idata  Diode_parameter2[6];
  45          uchar idata  Power_parameter1[6];
  46          uchar idata  Power_parameter2[6];
  47          uchar  set_flag;
  48          
  49          bit     Sys_mod;                            //系统工作模式  1:主动模式，0：系统采集模式
  50          
  51          uint   idata MCU_AD_code;
  52          uint   idata AD_code;
  53          uint   idata Laser_Set_curent1;             //设定种子源激光二极管电流值
  54          uint   idata Laser_Set_curent2;             //设定放大级激光二极管电流值
  55          uint   idata Laser_Fed_curent1;             //实际种子源激光二极管电流值
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 2   

  56          uint   idata Laser_Fed_curent2;             //实际放大级激光二极管电流值
  57          uint   idata Laser_meds_curent1;            //种子源中间设定电流
  58          uint   idata Laser_meds_curent2;            //放大级中间设定电流 
  59          uint   init_current1;                       //种子源初始电流
  60          uint   init_current2;                       //放大级初始电流
  61          uint   init_flag;                           //初始电流标志位 0：不启用 1：仅放大级 2：仅
             -种子源 3：双路
  62          
  63          uint   idata Laser_Set_power1;             //设定种子源激光功率
  64          uint   idata Laser_Set_power2;             //设定放大级激光功率
  65          uint   idata Laser_Fed_power1;             //种子源实际激光功率
  66          uint   idata Laser_Fed_power2;             //放大级实际激光功率
  67          uint   idata Laser_meds_power1;            //种子源中间设定功率
  68          uint   idata Laser_meds_power2;            //放大级中间设定功率
  69          
  70          float  idata TEC_Set_Tempture1;             //种子源设定冷却温度
  71          float  idata TEC_Set_Tempture2;             //放大级设定冷却温度
  72          float  idata TEC_Fed_Tempture1;             //种子源当前冷却温度
  73          float  idata TEC_Fed_Tempture2;             //放大级当前冷却温度
  74          uint   idata TEC_meds_tempture1;            //种子源中间设定温度
  75          uint   idata TEC_meds_tempture2;            //放大级中间设定温度
  76          
  77          uint   idata Key_V;                         //按键电压
  78          
  79          uint   idata PDiode_V1;                     //监测种子源电流二极管反馈电压
  80          uint   idata PDiode_V2;                     //监测放大级电流二极管反馈电压
  81          uint   idata TEC_VO1;                       //种子源TEC两端电压值
  82          uint   idata TEC_VO2;                       //放大级TEC两端电压值
  83          
  84          
  85          
  86          uchar  t=0;                                 // 缓冲区数据段
  87          
  88          bit  read_flag=0;                           // 读取标志位
  89          bit  las_di_ok=0;                           //激光二极管电流，1－OK
  90          
  91          
  92          //////////////////////////输入控制位/////////////////////////////////////////////////////
  93          
  94          sbit KEYB=P1^0;                      //3键盘输入（模拟量）
  95          
  96          
  97          
  98          sbit TMPGD1=P2^3;                    //TEC温度OK ，H－OK          1为种子源驱动
  99          sbit TMPGD2=P2^7;                    //TEC温度OK ，H－OK          2为放大级驱动
 100          sbit DOUT=P1^6;                      //AD串行输出
 101          
 102          sbit CONT_MOD=P4^3;                  //控制模式识别，1为APC，0为ACC
 103          
 104          //////////////////////////输出控制位/////////////////////////////////////////////////////
 105          sbit LDAC=P2^2;                      //DA装载信号
 106          sbit CSDA=P4^0;                      //DA选通信号
 107          sbit DINDA=P2^1;                     //DA串行数据输入
 108          //sbit SCLK=P1^7;                    //DA时钟输入         09.02 P1.7修改成模拟量输入
 109          sbit SCLK=P2^0;                      //DA时钟输入
 110          sbit SHDN1=P3^6;                     //关闭TEC温控，L－关闭
 111          sbit SHDN2=P2^6;                     //关闭TEC温控，L－关闭
 112          
 113          sbit FS=P3^7;                        //DA帧信号
 114          sbit ENAB=P4^4;                      //LCD使能信号，下降沿
 115          sbit RW=P4^5;                        //LCD读写信号，H－read，L－write
 116          sbit RS=P4^1;                        //LCD选通信号 ，H－date，L－instruction
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 3   

 117          sbit LIM1=P3^5;                      //激光二极管过流中断信号
 118          sbit LIM2=P2^5;                      //激光二极管过流中断信号
 119          //sbit INT1=P3^3;                    //外部中断信号1（备用）
 120          sbit DCLK=P1^7;                      //AD时钟信号
 121          sbit ADIN=P1^5;                      //AD串行数据输入
 122          sbit CSAD=P2^4;                      //AD选通信号，L－选通
 123          sbit LCD_BUSY=P0^7;
 124          
 125          
 126          
 127          /***************向串口发送一个字符串*****************/
 128          void send_string_com(uchar *str,uchar strlen)
 129          {
 130   1          uchar k=0;
 131   1          do
 132   1          {
 133   2              SBUF=*(str + k);
 134   2              while(TI==0);
 135   2              TI=0;
 136   2              k++;
 137   2          } while(k < strlen);
 138   1      }
 139          /************************************************************************/
 140          
 141          
 142          
 143          
 144          /***********以下是串口初始化程序********************************************/
 145          void serial_initial()
 146          {
 147   1      
 148   1      
 149   1            PCON |= 0x80;             //使能波特率倍速位SMOD
 150   1            SCON = 0x50;              //8位数据,可变波特率
 151   1            BRT = 0x64;               //设定独立波特率发生器重装值
 152   1            AUXR |= 0x04;             //独立波特率发生器时钟为Fosc,即1T
 153   1            AUXR |= 0x01;             //串口1选择独立波特率发生器为波特率发生器
 154   1            AUXR |= 0x10;             //启动独立波特率发生器
 155   1      
 156   1            TMOD=0x21;                //T1工作在方式2（8位模式）T工作在方式1（16位模式）
 157   1            AUXR &= 0x3f;             //T0,T1工作在1T/12
 158   1      
 159   1            IPH=0x14;
 160   1            IP=0x24;
 161   1            ES=1;
 162   1            ET0=1;
 163   1            IT0=1;
 164   1            EX0=1;
 165   1            IT1=1;
 166   1            EX1=1;
 167   1            EA=1;
 168   1            TL0 = 0x30;   //设置定时初值
 169   1            TH0 = 0xF8;   //设置定时初值
 170   1            TF0 = 0;    //清除TF0标志
 171   1            TR0 = 1;    //定时器0开始计时
 172   1      
 173   1            return;
 174   1      }
 175          
 176          /**********************************************************************/
 177          
 178          
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 4   

 179          
 180          /*********以下是长延时程序***********************************************/
 181          
 182          void delay(uint delay_k)
 183          {
 184   1          uint k0=0;
 185   1          do
 186   1          {
 187   2          do{k0--;}while(k0);
 188   2          delay_k--;
 189   2          }while(delay_k);
 190   1      
 191   1      }
 192          
 193          /*********以下是短延时程序***********************************************/
 194          void delayR(uint delay_k)
 195          {
 196   1          do{delay_k--;}while(delay_k);
 197   1      
 198   1      
 199   1      }
 200          
 201          /*********************************************************************/
 202          
 203          
 204          
 205          /*************************设置错误***************************/
 206          void setfault()
 207          {
 208   1      
 209   1        uchar inbuf1[10]={'s','e','t','f','a','u','l','t',0x0d,0x0a};
 210   1      
 211   1        send_string_com(inbuf1,10);
 212   1      
 213   1        t=0;
 214   1      }
 215          /*************************************************************/
 216          
 217          
 218          /*************************设置成功***************************/
 219          void setsucced()
 220          {
 221   1      
 222   1        uchar inbuf1[11]={'s','e','t','s','u','c','c','e','d',0x0d,0x0a};
 223   1      
 224   1        send_string_com(inbuf1,11);
 225   1        t=0;
 226   1        return;
 227   1      }
 228          /*************************************************************/
 229          
 230          
 231          
 232          
 233          /*****************************单片机内部AD********************************/
 234           void MCU_ADC(BYTE CHN)
 235           {
 236   1          BYTE    AD_finished;
 237   1          switch (CHN)
 238   1          {
 239   2              case 0: P1ASF=0x01;break;
 240   2              case 1: P1ASF=0x02;break;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 5   

 241   2              case 2:P1ASF=0x04;break;
 242   2              case 3:P1ASF=0x08;break;
 243   2              case 7:P1ASF=0x80;break;
 244   2      
 245   2              default: break;
 246   2          }
 247   1          AUXR1 &= ~0x04;                     //0000,0100, 令 ADRJ=0
 248   1          ADC_RES=0;
 249   1          ADC_RESL=0;
 250   1      
 251   1          CHN &= 0x07;                        //0000,0111 清0高5位
 252   1      
 253   1          ADC_CONTR =ADC_SPEEDH ;
 254   1          _nop_();
 255   1          ADC_CONTR |= CHN ;                  //选择 A/D 当前通道
 256   1          _nop_();
 257   1          ADC_CONTR |= 0x80;                  //启动 A/D 电源
 258   1          delayR(10);
 259   1          ADC_CONTR |= 0x08;
 260   1          delayR(10);
 261   1          AD_finished = 0;
 262   1          while (AD_finished ==0 )            //等待A/D转换结束
 263   1          {
 264   2            AD_finished = (ADC_CONTR & 0x10);
 265   2          }
 266   1          ADC_CONTR &= 0xE7;
 267   1      
 268   1          P1ASF=0x00;
 269   1          MCU_AD_code=ADC_RES*4+ADC_RESL;
 270   1      
 271   1          return;
 272   1       }
 273          
 274          /*************************************************************************/
 275          
 276          
 277          /********************************警告*************************/
 278          void alarm()
 279          {
 280   1         uchar t=6;
 281   1         uchar inbuf1[7]={'A','l','a','r','m',0x0d,0x0a};
 282   1      
 283   1         send_string_com(inbuf1,7);
 284   1        do
 285   1        {
 286   2         delay(50);
 287   2         t--;
 288   2        }while(t);
 289   1         send_string_com(inbuf1,5);
 290   1         t=6;
 291   1         do
 292   1        {
 293   2         delay(50);
 294   2         t--;
 295   2        }while(t);
 296   1         send_string_com(inbuf1,5);
 297   1      
 298   1      }
 299          /*************************************************************/
 300          
 301          
 302          
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 6   

 303          /**********************二极管电流监测**************************************/
 304          void Diode_curent_Check()
 305          {
 306   1          uchar k=16;
 307   1      //    float a,b;
 308   1          AD_inbuf[0]=0;
 309   1          AD_inbuf[1]=0;
 310   1          do
 311   1          {
 312   2            AD_code=AD_Convert(0);                  //种子源电流
*** WARNING C206 IN LINE 312 OF DUALDRIVER.C: 'AD_Convert': missing function-prototype
*** ERROR C267 IN LINE 312 OF DUALDRIVER.C: 'AD_Convert': requires ANSI-style prototype
 313   2            AD_inbuf[0]= AD_code+AD_inbuf[0];
 314   2      
 315   2            AD_code=AD_Convert(3);                  //放大级电流
 316   2            AD_inbuf[1]= AD_code+AD_inbuf[1];
 317   2      
 318   2            k--;
 319   2          }while(k);
 320   1      
 321   1      
 322   1          AD_inbuf[0]=AD_inbuf[0]/16;
*** ERROR C193 IN LINE 322 OF DUALDRIVER.C: '/': bad operand type
 323   1          AD_inbuf[1]=AD_inbuf[1]/16;
*** ERROR C193 IN LINE 323 OF DUALDRIVER.C: '/': bad operand type
 324   1      
 325   1          Laser_Fed_curent1=(AD_inbuf[0]*5/6-AD_inbuf[0]*15/768)/2;     //R=1.5欧
*** ERROR C193 IN LINE 325 OF DUALDRIVER.C: '*': bad operand type
 326   1          Laser_meds_curent1=Laser_Fed_curent1;
 327   1          if (Laser_Fed_curent1<10)
 328   1            { Diode_parameter1[0]=Laser_Fed_curent1+48;
 329   2              Diode_parameter1[1]=0x6d;
 330   2              Diode_parameter1[2]=0x41;
 331   2              Diode_parameter1[3]=0x20;
 332   2              Diode_parameter1[4]=0x20;
 333   2      
 334   2            } else if(Laser_Fed_curent1<100)
 335   1      
 336   1            { Diode_parameter1[0]=Laser_Fed_curent1 /10+48;
 337   2              Diode_parameter1[1]=Laser_Fed_curent1 %10+48;
 338   2              Diode_parameter1[2]=0x6d;
 339   2              Diode_parameter1[3]=0x41;
 340   2              Diode_parameter1[4]=0x20;
 341   2            } else if(Laser_Fed_curent1<1000)
 342   1      
 343   1            { Diode_parameter1[0]=Laser_Fed_curent1 /100+48;
 344   2              Diode_parameter1[1]=(Laser_Fed_curent1 %100)/10+48;
 345   2              Diode_parameter1[2]=Laser_Fed_curent1 %10+48;
 346   2              Diode_parameter1[3]=0x6d;
 347   2              Diode_parameter1[4]=0x41;
 348   2            }
 349   1      
 350   1          Laser_Fed_curent2=(AD_inbuf[1]*5/6-AD_inbuf[1]*15/768)/2;     //R=1.5欧
*** ERROR C193 IN LINE 350 OF DUALDRIVER.C: '*': bad operand type
 351   1          Laser_meds_curent2=Laser_Fed_curent2;
 352   1          if (Laser_Fed_curent2<10)
 353   1            { Diode_parameter2[0]=Laser_Fed_curent2+48;
 354   2              Diode_parameter2[1]=0x6d;
 355   2              Diode_parameter2[2]=0x41;
 356   2              Diode_parameter2[3]=0x20;
 357   2              Diode_parameter2[4]=0x20;
 358   2      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 7   

 359   2            } else if(Laser_Fed_curent2<100)
 360   1      
 361   1            { Diode_parameter2[0]=Laser_Fed_curent2 /10+48;
 362   2              Diode_parameter2[1]=Laser_Fed_curent2 %10+48;
 363   2              Diode_parameter2[2]=0x6d;
 364   2              Diode_parameter2[3]=0x41;
 365   2              Diode_parameter2[4]=0x20;
 366   2            } else if(Laser_Fed_curent2<1000)
 367   1      
 368   1            { Diode_parameter2[0]=Laser_Fed_curent2 /100+48;
 369   2              Diode_parameter2[1]=(Laser_Fed_curent2 %100)/10+48;
 370   2              Diode_parameter2[2]=Laser_Fed_curent2 %10+48;
 371   2              Diode_parameter2[3]=0x6d;
 372   2              Diode_parameter2[4]=0x41;
 373   2            }
 374   1      
 375   1          return;
 376   1      }
 377          /**************************************************************************/
 378          /*****************************激光功率检测*********************************/
 379          void Laser_power_Check()
 380          {
 381   1      
 382   1          uchar k=10;
 383   1          float a,b;
 384   1          AD_inbuf[8]=0;
 385   1          AD_inbuf[9]=0;
 386   1          do
 387   1          {
 388   2            AD_code=AD_Convert(1);                  //种子源
 389   2            AD_inbuf[8]= AD_code+AD_inbuf[8];
 390   2      
 391   2            AD_code=AD_Convert(4);                  //放大级
 392   2            AD_inbuf[9]= AD_code+AD_inbuf[9];
 393   2            k--;
 394   2          }while(k);
 395   1      
 396   1      
 397   1      
 398   1          AD_inbuf[8]=AD_inbuf[8]/10;
*** ERROR C193 IN LINE 398 OF DUALDRIVER.C: '/': bad operand type
 399   1          AD_inbuf[9]=AD_inbuf[9]/10;
*** ERROR C193 IN LINE 399 OF DUALDRIVER.C: '/': bad operand type
 400   1      
 401   1          AD_code=AD_inbuf[8];
 402   1          a=(float)(AD_code);
 403   1          a=a*2.5;
 404   1          a=a/4096+0.02015;
 405   1          b=a*a*117.314+275.543*a-0.806;
 406   1      
 407   1          Laser_Fed_power1=(uint)(b);
 408   1          Laser_meds_power1=Laser_Fed_power1;
 409   1      
 410   1          if (Laser_Fed_power1<10)
 411   1            { Power_parameter1[0]=Laser_Fed_power1+48;
 412   2              Power_parameter1[1]=0x6d;
 413   2              Power_parameter1[2]=0x77;
 414   2              Power_parameter1[3]=0x20;
 415   2              Power_parameter1[4]=0x20;
 416   2              Power_parameter1[5]=0x20;
 417   2      
 418   2            } else if(Laser_Fed_power1<100)
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 8   

 419   1      
 420   1            { Power_parameter1[0]=Laser_Fed_power1/10+48;
 421   2              Power_parameter1[1]=Laser_Fed_power1 %10+48;
 422   2              Power_parameter1[2]=0x6d;
 423   2              Power_parameter1[3]=0x77;
 424   2              Power_parameter1[4]=0x20;
 425   2              Power_parameter1[5]=0x20;
 426   2            } else if(Laser_Fed_power1<1000)
 427   1      
 428   1            { Power_parameter1[0]=Laser_Fed_power1 /100+48;
 429   2              Power_parameter1[1]=(Laser_Fed_power1 %100)/10+48;
 430   2              Power_parameter1[2]=Laser_Fed_power1 %10+48;
 431   2              Power_parameter1[3]=0x6d;
 432   2              Power_parameter1[4]=0x77;
 433   2              Power_parameter1[5]=0x20;
 434   2            }
 435   1      
 436   1          AD_code=AD_inbuf[9];
 437   1          a=(float)(AD_code);
 438   1          a=a*2.5;
 439   1          a=a/4096+0.02015;
 440   1          b=a*a*117.314+275.543*a-0.806;
 441   1      
 442   1          Laser_Fed_power2=(uint)(b);
 443   1          Laser_meds_power2=Laser_Fed_power2;
 444   1      
 445   1          if (Laser_Fed_power2<10)
 446   1            { Power_parameter2[0]=Laser_Fed_power2+48;
 447   2              Power_parameter2[1]=0x6d;
 448   2              Power_parameter2[2]=0x77;
 449   2              Power_parameter2[3]=0x20;
 450   2              Power_parameter2[4]=0x20;
 451   2              Power_parameter2[5]=0x20;
 452   2      
 453   2            } else if(Laser_Fed_power2<100)
 454   1      
 455   1            { Power_parameter2[0]=Laser_Fed_power2/10+48;
 456   2              Power_parameter2[1]=Laser_Fed_power2 %10+48;
 457   2              Power_parameter2[2]=0x6d;
 458   2              Power_parameter2[3]=0x77;
 459   2              Power_parameter2[4]=0x20;
 460   2              Power_parameter2[5]=0x20;
 461   2            } else if(Laser_Fed_power2<1000)
 462   1      
 463   1            { Power_parameter2[0]=Laser_Fed_power2 /100+48;
 464   2              Power_parameter2[1]=(Laser_Fed_power2 %100)/10+48;
 465   2              Power_parameter2[2]=Laser_Fed_power2 %10+48;
 466   2              Power_parameter2[3]=0x6d;
 467   2              Power_parameter2[4]=0x77;
 468   2              Power_parameter2[5]=0x20;
 469   2            }
 470   1      
 471   1          return;
 472   1      
 473   1      
 474   1      
 475   1      }
 476          /**************************************************************************/
 477          
 478          
 479          /*****************************当前冷却温度*********************************/
 480          void TEC_Temp()
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 9   

 481          {
 482   1          uint  tx1=0;
 483   1          uint  tx2=0;
 484   1          uchar kt=16;
 485   1          AD_inbuf[6]=0;
 486   1          AD_inbuf[7]=0;
 487   1          do
 488   1          {
 489   2            AD_code=AD_Convert(2);        //种子源TEC温度
 490   2            AD_inbuf[6]= AD_code+AD_inbuf[6];
 491   2      
 492   2            AD_code=AD_Convert(5);        //放大级TEC温度
 493   2            AD_inbuf[7]= AD_code+AD_inbuf[7];
 494   2            kt--;
 495   2          }while(kt);
 496   1      
 497   1           AD_inbuf[6]=AD_inbuf[6]/16;
*** ERROR C193 IN LINE 497 OF DUALDRIVER.C: '/': bad operand type
 498   1           AD_inbuf[7]=AD_inbuf[7]/16;
*** ERROR C193 IN LINE 498 OF DUALDRIVER.C: '/': bad operand type
 499   1           TEC_meds_tempture1=AD_inbuf[6];
 500   1           TEC_meds_tempture2=AD_inbuf[7];
 501   1      
 502   1           TEC_Fed_Tempture1=(float)( TEC_meds_tempture1)/23.6749+142.4;
 503   1           TEC_Fed_Tempture2=(float)( TEC_meds_tempture2)/23.6749+142.4;
 504   1           tx1= (uint)(TEC_Fed_Tempture1);
 505   1           TEC_meds_tempture1=tx1;
 506   1           tx2= (uint)(TEC_Fed_Tempture2);
 507   1           TEC_meds_tempture2=tx2;
 508   1      
 509   1           TEC_parameter1[0]=tx1 /100+48;
 510   1           TEC_parameter1[1]=(tx1 /10)%10+48;
 511   1           TEC_parameter1[2]=0x2e;
 512   1           TEC_parameter1[3]=tx1 %10+48;
 513   1      
 514   1      
 515   1           TEC_parameter2[0]=tx2 /100+48;
 516   1           TEC_parameter2[1]=(tx2 /10)%10+48;
 517   1           TEC_parameter2[2]=0x2e;
 518   1           TEC_parameter2[3]=tx2 %10+48;
 519   1      
 520   1      
 521   1        return;
 522   1      }
 523          
 524          /**************************************************************************/
 525          
 526          /*****************************当前TEC两端电压******************************/
 527          void TEC_V_Check()                                                 //???????????????????????
 528          {
 529   1          uchar kk=20;
 530   1          AD_inbuf[4]=0;
 531   1          AD_inbuf[5]=0;
 532   1          do
 533   1          {
 534   2            MCU_ADC(1);
 535   2            AD_inbuf[4]= MCU_AD_code+ AD_inbuf[4];
 536   2            MCU_ADC(2);
 537   2            AD_inbuf[5]= MCU_AD_code+ AD_inbuf[5];
 538   2            kk--;
 539   2          }while(kk);
 540   1      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 10  

 541   1      
 542   1           TEC_VO1=AD_inbuf[4]/20 ;
*** ERROR C193 IN LINE 542 OF DUALDRIVER.C: '/': bad operand type
 543   1           TEC_VO1=TEC_VO1*5;
 544   1           TEC_VO2=AD_inbuf[4]/20 ;
*** ERROR C193 IN LINE 544 OF DUALDRIVER.C: '/': bad operand type
 545   1           TEC_VO2=TEC_VO2*5;
 546   1      
 547   1      //     TEC_parameter[0]=(uchar)(TEC_VO/1024)+48;
 548   1      //     TEC_parameter[1]=0x2e;
 549   1      //     TEC_parameter[2]=(uchar)((TEC_VO%1024)*10/1024)+48;
 550   1      //     TEC_parameter[3]=(uchar)((((TEC_VO%1024)*10)%1024)*10/1024)+48;
 551   1      //     TEC_parameter[4]=0xa0;
 552   1      //     TEC_parameter[5]=0x56;
 553   1          return;
 554   1      }
 555          
 556          /**************************************************************************/
 557          
 558          /*****************************监测二极管电压******************************/
 559          void Pdiod_V_Check()
 560          {
 561   1          uchar kk=10;
 562   1          AD_inbuf[2]=0;
 563   1          AD_inbuf[3]=0;
 564   1          do
 565   1          {
 566   2            AD_code=AD_Convert(1);             //种子源激光二极管
 567   2            AD_inbuf[2]= AD_code+AD_inbuf[2];
 568   2      
 569   2            AD_code=AD_Convert(4);             //放大级激光二极管
 570   2            AD_inbuf[3]= AD_code+AD_inbuf[3];
 571   2            kk--;
 572   2          }while(kk);
 573   1      
 574   1           PDiode_V1= AD_inbuf[2]/10;
*** ERROR C193 IN LINE 574 OF DUALDRIVER.C: '/': bad operand type
 575   1           PDiode_V2= AD_inbuf[3]/10;
*** ERROR C193 IN LINE 575 OF DUALDRIVER.C: '/': bad operand type
 576   1           PDiode_V1=(PDiode_V1*5)/2;
 577   1           PDiode_V2=(PDiode_V2*5)/2;
 578   1          return;
 579   1      }
 580          /**************************************************************************/
 581          
 582          
 583          
 584          /*******************************设定温度值*************************************
 585          
 586          void Set_TEC_TEMP(uint tempture)
 587          {
 588               uint kt;
 589          
 590                kt=(uint)((tempture-15)*4096/35);
 591                DA_Convert(1,kt);
 592          
 593          
 594          
 595          
 596             return;
 597          }
 598          
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 11  

 599          
 600          /******************************************************************************/
 601          
 602          /*****************************设定功率值**********************************/
 603          void Set_laser_power(uchar Channel,uint power)
 604          {
 605   1        float  u,v;
 606   1        uint   temp_p;
 607   1      
 608   1        if (power<3) power=3;
 609   1        if (power>600) power=600;
 610   1        u=(float)(power);
 611   1        v=(u*u/1000)*3.46;
 612   1        v=6.5068*u+29.61-v;
 613   1        temp_p=(uint)(v);
 614   1      
 615   1      
 616   1        if(Channel==3)                                         //设定种子源功率
 617   1        {
 618   2      
 619   2          if(SHDN1)
 620   2           {
 621   3      
 622   3                DA_Convert(3,temp_p);
 623   3                _Nop();
 624   3                DA_Convert(3,temp_p);
 625   3           }
 626   2      
 627   2           Laser_Set_power1=power;
 628   2         }
 629   1      
 630   1      
 631   1          else if(Channel==0)
 632   1        {
 633   2      
 634   2          if(SHDN2)                                             //设定放大级功率
 635   2           {
 636   3      
 637   3                DA_Convert(0,temp_p);
 638   3                _Nop();
 639   3                DA_Convert(0,temp_p);
 640   3           }
 641   2      
 642   2           Laser_Set_power2=power;
 643   2         }
 644   1      
 645   1         else  _Nop();
 646   1      
 647   1         Laser_power_Check();
 648   1      
 649   1      
 650   1          return;
 651   1      
 652   1      }
 653          
 654          
 655          /*************************************************************************/
 656          
 657          /*****************************设定电流值**********************************/
 658          
 659          void Set_laser_current(uchar Channel,uint current)
 660          {
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 12  

 661   1      
 662   1          uint tmp_c1;
 663   1      
 664   1          if (current<30) current=30;
 665   1          if (current>900) current=900;
 666   1      
 667   1      
 668   1      
 669   1            tmp_c1=current*3+current*9/125;                     //R=1.5欧
 670   1      
 671   1      
 672   1      
 673   1      
 674   1      
 675   1          if(Channel==3)
 676   1          {
 677   2             if(SHDN1)
 678   2             {
 679   3      
 680   3                  DA_Convert(3,tmp_c1);
 681   3                  _Nop();
 682   3                  DA_Convert(3,tmp_c1);
 683   3      
 684   3                  Laser_Set_curent1=current;
 685   3             }
 686   2      
 687   2             _Nop();
 688   2          }
 689   1      
 690   1          else if(Channel==0)
 691   1          {
 692   2             if(SHDN2)
 693   2             {
 694   3      
 695   3                  DA_Convert(0,tmp_c1);
 696   3                  _Nop();
 697   3                  DA_Convert(0,tmp_c1);
 698   3      
 699   3                  Laser_Set_curent2=current;
 700   3             }
 701   2      
 702   2             _Nop();
 703   2          }
 704   1      
 705   1      
 706   1      
 707   1      
 708   1      /*
 709   1        if (tmp_c1>tmp_c0)
 710   1          {
 711   1            do
 712   1            {
 713   1      
 714   1              while(!TMPGD)
 715   1              {
 716   1                TEC_Temp();
 717   1                if(tx>280)
 718   1              {
 719   1                uchar inbuf1[11]={'t','m','p','_','e','r','r',0x0d,0x0a};
 720   1                send_string_com(inbuf1,9);
 721   1                t=0;
 722   1                SHDN=0;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 13  

 723   1                tmp_c0=Laser_Set_curent*8+Laser_Set_curent*24/125;
 724   1                tmp_c1=246;
 725   1                Laser_Set_curent=30;
 726   1                 do
 727   1               {
 728   1                tmp_c0=tmp_c0-2;
 729   1                DA_Convert(0,tmp_c0);
 730   1                m++;
 731   1      
 732   1                 if(m==240)
 733   1                 {
 734   1                  Diode_curent_Check();
 735   1                  TEC_Temp();
 736   1                  chn_disp (tab6,6,0x80);
 737   1                  delayR(500);
 738   1                  chn_disp (Diode_parameter,6,0x83);
 739   1                  delayR(500);
 740   1                  chn_disp (tab7,4,0x90);
 741   1                  delayR(500);
 742   1                  chn_disp (TEC_parameter,4,0x92);
 743   1                  delayR(100);
 744   1                  chn_disp (tab11,2,0x94);
 745   1                  m=0;
 746   1                 }
 747   1                 delayR(10000);
 748   1                 }while(tmp_c0-tmp_c1);
 749   1                 chn_disp (inbuf1,7,0x96);
 750   1                 goto quit;
 751   1               }
 752   1              }
 753   1      
 754   1      
 755   1              
 756   1      
 757   1      
 758   1           if(m==160)
 759   1          {
 760   1           TEC_Temp();
 761   1           Diode_curent_Check();
 762   1           chn_disp (tab6,6,0x80);
 763   1           delayR(500);
 764   1           chn_disp (Diode_parameter,6,0x83);
 765   1           delayR(500);
 766   1           chn_disp (tab7,4,0x90);
 767   1           delayR(500);
 768   1           chn_disp (TEC_parameter,4,0x92);
 769   1           delayR(100);
 770   1           chn_disp (tab11,2,0x94);
 771   1           m=0;
 772   1          }
 773   1      
 774   1      
 775   1      
 776   1      
 777   1      
 778   1      
 779   1      
 780   1             delayR(10000);
 781   1            }while((tmp_c1-tmp_c0)&& SHDN);
 782   1      
 783   1             delayR(180);
 784   1      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 14  

 785   1          }
 786   1        else if(tmp_c1<tmp_c0)
 787   1      
 788   1          {
 789   1             do
 790   1            {
 791   1              
 792   1           if(m==160)
 793   1           {
 794   1           Diode_curent_Check();
 795   1           TEC_Temp();
 796   1           chn_disp (tab6,6,0x80);
 797   1           delayR(500);
 798   1           chn_disp (Diode_parameter,6,0x83);
 799   1           delayR(500);
 800   1           chn_disp (tab7,4,0x90);
 801   1           delayR(500);
 802   1           chn_disp (TEC_parameter,4,0x92);
 803   1           delayR(100);
 804   1           chn_disp (tab11,2,0x94);
 805   1           m=0;
 806   1           }
 807   1           delayR(10000);
 808   1            }while(tmp_c0-tmp_c1);
 809   1      
 810   1           delay(100);
 811   1      
 812   1          }        */
 813   1          Diode_curent_Check();
 814   1      
 815   1      
 816   1          return;
 817   1      
 818   1      }
 819          
 820          /***************************************************************************/
 821          
 822          /*****************************外部AD转换程序*******************************/
 823          uint AD_Convert(uchar Channel)
 824          {
 825   1         uchar i,Dath,Datl,temp,Contbit;
 826   1         uint Dat_ad;
 827   1         Dath=0;
 828   1         Datl=0;
 829   1         temp=0;
 830   1         Dat_ad=0;
 831   1         switch (Channel)                        //  内部REF
 832   1          {
 833   2              case 0:Contbit=0x00;break;
 834   2              case 1:Contbit=0x08;break;
 835   2              case 2:Contbit=0x10;break;
 836   2              case 3:Contbit=0x18;break;
 837   2              case 4:Contbit=0x20;break;
 838   2              case 5:Contbit=0x28;break;
 839   2              case 6:Contbit=0x30;break;
 840   2              case 7:Contbit=0x38;break;
 841   2              default: break;
 842   2          }
 843   1      
 844   1          CSAD=0;
 845   1          _Nop();
 846   1          DCLK=1;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 15  

 847   1      
 848   1         for(i=0;i<8;i++)
 849   1         {
 850   2            ADIN=(bit)(Contbit&(0x80>>i));   //串行数据位
 851   2      
 852   2            DCLK=0;
 853   2            _Nop();
 854   2            DCLK=1;
 855   2            _Nop();
 856   2      
 857   2         }
 858   1      
 859   1          CSAD=1;
 860   1          _Nop();
 861   1      
 862   1          CSAD=0;
 863   1          _Nop();
 864   1      
 865   1          for(i=0;i<8;i++)                   //写入控制字，并读取高四位数据
 866   1          {
 867   2            ADIN=(bit)(Contbit&(0x80>>i));
 868   2      
 869   2            DCLK=0;
 870   2            _Nop();
 871   2            DCLK=1;
 872   2            _Nop();
 873   2            Dath=DOUT;
 874   2            Dath=Dath<<(7-i);
 875   2            temp=temp|Dath;
 876   2          }
 877   1      
 878   1           Dath=temp;
 879   1           temp=0;
 880   1          for(i=0;i<8;i++)
 881   1          {
 882   2            DCLK=0;
 883   2            _Nop();
 884   2            DCLK=1;
 885   2            Datl=DOUT;
 886   2            Datl=Datl<<(7-i);
 887   2            temp=temp|Datl;
 888   2            _Nop();
 889   2      
 890   2          }
 891   1      
 892   1           Datl=temp;
 893   1           Dat_ad=(Dath*256+Datl)&0x0fff;
 894   1      
 895   1           CSAD=1;
 896   1      
 897   1      
 898   1      
 899   1            _Nop();
 900   1      
 901   1            return(Dat_ad);
 902   1      }
 903          
 904          
 905          
 906          /**************************************************************************/
 907          /*****************************外部PWM设置程序*******************************/
 908          void Pwm_Set(uint pwm_pulserate, uint pwm_pulsewidth,uint pwm_pulsedelay)
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 16  

 909          { 
 910   1        //脉宽1单位为10NS
 911   1        //延迟1单位为10NS
 912   1        //频率1单位为1KHZ
 913   1      
 914   1        //
 915   1      }
 916          /**************************************************************************/
 917          /*****************************外部DA转换程序*******************************/
 918          void DA_Convert(uchar Channel, uint Dcode)
 919          {
 920   1      
 921   1        uint  Comdat=0;
 922   1         uchar i;
 923   1         switch (Channel)
 924   1          {
 925   2              case 0:Comdat=Dcode+0x1000;break;
 926   2              case 1:Comdat=Dcode+0x5000;break;
 927   2              case 2:Comdat=Dcode+0x9000;break;
 928   2              case 3:Comdat=Dcode+0xd000;break;
 929   2              default: break;
 930   2          }
 931   1      
 932   1          LDAC=1;                               //数据刷新
 933   1          _Nop();
 934   1          CSDA=0;                               //片选有效
 935   1          FS=1;
 936   1          _Nop();
 937   1          FS=0;
 938   1         for(i=0;i<16;i++)
 939   1        {
 940   2             DINDA=(bit)(Comdat&0x8000);
 941   2             SCLK=1;
 942   2             Comdat=Comdat<<1;
 943   2             _Nop();
 944   2             SCLK=0;
 945   2      
 946   2         }
 947   1      
 948   1         LDAC=0;
 949   1         _Nop();
 950   1         CSDA=1;                             //片选无效
 951   1         Dcode=0;
 952   1        return;
 953   1      
 954   1      }
 955          /**************************************************************************/
 956          
 957          
 958          void Error_Process()
 959          {
 960   1      
 961   1       _Nop();
 962   1       return;
 963   1      
 964   1      }
 965          
 966          
 967          
 968          /**************************以下是外部中断0程序************************/
 969           void INT_0() interrupt 0 using 0
 970           {
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 17  

 971   1          if (!LIM1)
 972   1          Error_Process();
 973   1          else  _Nop();
 974   1      
 975   1          if (!LIM2)
 976   1          Error_Process();
 977   1          else  _Nop();
 978   1          return;
 979   1       }
 980          /*********************************************************************/
 981          
 982          /***************************以下是外部中断1程序***********************/
 983          void INT_1() interrupt 2 using 1
 984          {
 985   1        _Nop();
 986   1        chn_disp (tab16,20,0x80);
 987   1        delayR(10000);
 988   1        chn_disp (tab17,20,0x90);
 989   1        delay(1000);
 990   1      }
 991          /***********************************************************************/
 992          
 993          
 994          
 995          
 996          
 997          /*****************以下是串口中断程序*******************************/
 998          
 999          void RS232() interrupt 4 using 3
1000          {
1001   1      
1002   1         if(RI)
1003   1         {
1004   2              RI=0;
1005   2      
1006   2              if (SBUF==0x0A)
1007   2              {
1008   3                   read_flag=1;
1009   3      
1010   3                }
1011   2      
1012   2              else
1013   2              {
1014   3      
1015   3      
1016   3                   inbuf[t]=SBUF;
1017   3                   t++;
1018   3      
1019   3      
1020   3      
1021   3              }
1022   2      
1023   2         }
1024   1      
1025   1           return;
1026   1      }
1027          
1028          /**********************************************************************/
1029          
1030          /*****************定时器中断程序*******************************/
1031          
1032          void tm0_isr() interrupt 1 using 1
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 18  

1033          {
1034   1           TL0 = 0x30;   //设置定时初值
1035   1           TH0 = 0xF8;   //设置定时初值
1036   1           if (count-- == 0)               //1ms * 1000 -> 1s
1037   1           {
1038   2           count = 1000;               //reset counter
1039   2           TEST_LED = ! TEST_LED;      //work LED flash
1040   2           }
1041   1      }
1042          
1043          /**********************************************************************/
1044          
1045          /***********以下是状态初始化程序*********************************/
1046          void stat_initial()
1047          {
1048   1      
1049   1           ADC_RES=0;
1050   1           ADC_RESL=0;
1051   1      
1052   1           read_flag=0;          //读取标志清零
1053   1           las_di_ok=0;
1054   1           t=0;
1055   1           set_flag=0;
1056   1           Sys_mod=0;   //tang
1057   1      
1058   1           AD_code=0;
1059   1      //     Laser_Set_curent=0;
1060   1           Laser_Fed_curent1=0;
1061   1           Laser_Fed_curent2=0;
1062   1           Laser_Fed_power1=0;
1063   1           Laser_Fed_power2=0;
1064   1      
1065   1      /**************DA引脚初始化*************************/
1066   1           CSDA=1;
1067   1           LDAC=1;
1068   1           FS=0;
1069   1           SCLK=0;
1070   1           DINDA=0;
1071   1      /**************************************************/
1072   1           DA_Convert(2,1273);                          //设定种子源TEC温度为25度
1073   1           _Nop();
1074   1           DA_Convert(2,1273);
1075   1           _Nop();
1076   1           DA_Convert(1,1273);                          //设定放大级TEC温度为25度
1077   1           _Nop();
1078   1           DA_Convert(1,1273);
1079   1      /**************************************************/
1080   1        if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
1081   1      
1082   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
1083   1       {
1084   2        Laser_Set_power1=3;                        //记录种子源当前设定功率值
1085   2        Laser_Set_power2=3;                        //记录放大级当前设定功率值
1086   2      
1087   2        DA_Convert(3,25);                          // 种子源
1088   2         _Nop();
1089   2        DA_Convert(3,25);
1090   2      
1091   2        DA_Convert(0,25);                          // 放大级
1092   2         _Nop();
1093   2        DA_Convert(0,25);
1094   2       }
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 19  

1095   1      //////////////////////////////////////////////////////////////////////////////////////////////
1096   1      
1097   1        else
1098   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
1099   1       {
1100   2        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
1101   2        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
1102   2      
1103   2        DA_Convert(3,init_current1);                            // 种子源
1104   2         _Nop();
1105   2        DA_Convert(3,init_current1);
1106   2      
1107   2        DA_Convert(0,init_current2);                            // 放大级
1108   2        _Nop();
1109   2        DA_Convert(0,init_current2);
1110   2       }
1111   1      //////////////////////////////////////////////////////////////////////////////////////////////
1112   1      
1113   1      
1114   1      
1115   1           P4SW=0x30;            //设定P4.4、P4.5为I/O功能
1116   1           P1M1=0x07;
1117   1           P1M0=0x00;
1118   1      
1119   1           CSAD=1;
1120   1           DCLK=1;
1121   1           DOUT=1;
1122   1      
1123   1      
1124   1      
1125   1      
1126   1      
1127   1      /*************TEC控制器初始化*********************/
1128   1           SHDN1=1;
1129   1      //   TMPGD1=1;
1130   1           LIM1=1;
1131   1      
1132   1           SHDN2=1;
1133   1      //   TMPGD2=1;
1134   1           LIM2=1;
1135   1      /*************************************************/
1136   1      
1137   1      /*    Power_parameter[0]='P';
1138   1            Power_parameter[1]='O';
1139   1            Power_parameter[2]='W';
1140   1            Power_parameter[3]=':';
1141   1      
1142   1            Diode_parameter[0]='L';
1143   1            Diode_parameter[1]='D';
1144   1            Diode_parameter[2]='C';
1145   1            Diode_parameter[3]=':';
1146   1            Diode_parameter[8]=0x20;
1147   1            Diode_parameter[9]=0x20;
1148   1      
1149   1            TEC_parameter[0]='T';
1150   1            TEC_parameter[1]='E';
1151   1            TEC_parameter[2]='C';
1152   1            TEC_parameter[3]=':';
1153   1      */
1154   1      
1155   1           TR0=0;
1156   1           ET0=0;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 20  

1157   1           TR1=0;
1158   1           ET1=0;
1159   1           EX0=0;
1160   1      
1161   1           return;
1162   1      }
1163          
1164          /***************************************************************/
1165          
1166          
1167          /****************************操作指令执行***********************/
1168          void command()
1169          {
1170   1      
1171   1          ///////////////////////////板卡初始化指令////////////////////////////////////////////
1172   1           if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='T')&&(inbuf[4]=='I'))
1173   1              {
1174   2                 stat_initial();
1175   2                 serial_initial();
1176   2                 setsucced();
1177   2              }
1178   1      
1179   1      ///////////////////////////////////设定电流////////////////////////////////////////////
1180   1             else if((inbuf[0]=='S')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='O')&&(inbuf[4]=='='))
1181   1      
1182   1                 {
1183   2                     uint dio_cu;
1184   2                     uchar CH;
1185   2      
1186   2                     if(inbuf[7]==0x0d)                                        //格式为SDIO=N
1187   2                    {
1188   3                       dio_cu=inbuf[6]-48;
1189   3      
1190   3      
1191   3                    }
1192   2                     else if(inbuf[8]==0x0d)                                   //格式为SDIO=NN
1193   2                    {
1194   3                       dio_cu=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
1195   3      
1196   3                    }
1197   2                    else if(inbuf[9]==0x0d)                                    //格式为SDIO=NNN
1198   2                    {
1199   3                       dio_cu=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
1200   3      
1201   3                    }
1202   2      
1203   2                    else                                                    //格式为SDIO=NNNN
1204   2                    {
1205   3                        setfault();
1206   3                        goto setcf;
1207   3                    }
1208   2      
1209   2                    if(inbuf[5]=='S')
1210   2                    {
1211   3                      CH=3;                                     //种子源SEED
1212   3                      Set_laser_current(CH,dio_cu);
1213   3                      setsucced();
1214   3                    }
1215   2                    else if(inbuf[5]=='A')
1216   2                    {
1217   3                      CH=0;                                    //放大级AMP
1218   3                      Set_laser_current(CH,dio_cu);
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 21  

1219   3                      setsucced();
1220   3                    }
1221   2                    else setfault();
1222   2      
1223   2      setcf:       _Nop();
1224   2      
1225   2                 }
1226   1      
1227   1      
1228   1      ///////////////////////////////////设定初始电流////////////////////////////////////////////
1229   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='='))
1230   1      
1231   1                 {
1232   2                     uint init_current;
1233   2                     uchar CH;
1234   2      
1235   2                     if(inbuf[7]==0x0d)                                        //格式为SDIO=N
1236   2                    {
1237   3                       init_current=inbuf[6]-48;
1238   3      
1239   3      
1240   3                    }
1241   2                     else if(inbuf[8]==0x0d)                                   //格式为SDIO=NN
1242   2                    {
1243   3                       init_current=(uint)((inbuf[6]-48)*10+(inbuf[7]-48));
1244   3      
1245   3                    }
1246   2                    else if(inbuf[9]==0x0d)                                    //格式为SDIO=NNN
1247   2                    {
1248   3                       init_current=(uint)((inbuf[6]-48)*100+(inbuf[7]-48)*10+(inbuf[8]-48));
1249   3      
1250   3                    }
1251   2      
1252   2                    else                                                    //格式为SDIO=NNNN
1253   2                    {
1254   3                        setfault();
1255   3                        goto seticf;
1256   3                    }
1257   2      
1258   2                    if(inbuf[5]=='S')
1259   2                    {
1260   3                      init_current1=init_current;
1261   3                    }
1262   2                    else if(inbuf[5]=='A')
1263   2                    {
1264   3                      init_current2=init_current;
1265   3                    }
1266   2                    else setfault();
1267   2      
1268   2      seticf:       _Nop();
1269   2      
1270   2                 }
1271   1      
1272   1      
1273   1      
1274   1      ///////////////////////////////////设定初始化模式 0/1/2/3 /////////////////////////////////////////
             -///
1275   1             else if((inbuf[0]=='I')&&(inbuf[1]=='N')&&(inbuf[2]=='I')&&(inbuf[3]=='E')&&(inbuf[4]=='='))
1276   1      
1277   1                 {   
1278   2                     uint init_flag_temp;
1279   2                     uchar CH;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 22  

1280   2      
1281   2                     if(inbuf[6]==0x0d)                                        //格式为SDIO=N
1282   2                    {
1283   3                       init_flag_temp=inbuf[5]-48;
1284   3                      if ((init_flag_temp<0)||(init_flag_temp>3))
1285   3                        goto setief;
1286   3                      else
1287   3                        init_flag=init_flag_temp;
1288   3                    }
1289   2                    else                                                    //格式为SDIO=NNNN
1290   2                    {
1291   3                        setfault();
1292   3                        goto setief;
1293   3                    }
1294   2      
1295   2      setief:       _Nop();
1296   2      
1297   2                 }
1298   1      
1299   1      
1300   1       //////////////////////////////设定功率//////////////////////////////////////////////////
1301   1              else if((inbuf[0]=='S')&&(inbuf[1]=='P')&&(inbuf[2]=='O')&&(inbuf[3]=='W')&&(inbuf[4]=='='))
1302   1                  {
1303   2                     uint las_pow;
1304   2                     uchar CHH;
1305   2                     if(inbuf[6]==0x0d)                                        //格式为SPOW=N
1306   2                    {
1307   3                       las_pow=(uint)(inbuf[5]-48);
1308   3      
1309   3                    }
1310   2                     else if(inbuf[7]==0x0d)                                   //格式为SPOW=NN
1311   2                    {
1312   3                       las_pow=(uint)((inbuf[5]-48)*10+(inbuf[6]-48));
1313   3      
1314   3                    }
1315   2                    else if(inbuf[8]==0x0d)                                    //格式为SPOW=NNN
1316   2                    {
1317   3                       las_pow=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
1318   3      
1319   3                    }
1320   2      
1321   2                    else                                                      //格式为SPOW=NNNN
1322   2                    {
1323   3                        setfault();
1324   3                        goto setpf;
1325   3                    }
1326   2      
1327   2                    if(inbuf[5]=='S')
1328   2                    {
1329   3                      CH=3;                                     //种子源SEED
1330   3                      Set_laser_power(CHH,las_pow);
1331   3                      setsucced();
1332   3                    }
1333   2                    else if(inbuf[5]=='A')
1334   2                    {
1335   3                      CH=0;                                    //放大级AMP
1336   3                      Set_laser_power(CHH,las_pow);
1337   3                      setsucced();
1338   3                    }
1339   2                    else setfault();
1340   2      
1341   2      setpf:       _Nop();
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 23  

1342   2      
1343   2      
1344   2                  }
1345   1       ////////////////////////////////////////////////////////////////////////////////////////
1346   1       //////////////////////////////设定温度//////////////////////////////////////////////////
1347   1              else if((inbuf[0]=='S')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='P')&&(inbuf[4]=='='))
1348   1                 {
1349   2                    uint  tmp_tec=0;
1350   2                    uint kt=0;
1351   2                    if(inbuf[8]==0x0d)
1352   2                    {
1353   3                       tmp_tec=(inbuf[6]-48)*10+(inbuf[7]-48);
1354   3      
1355   3      
1356   3      
1357   3      
1358   3                       kt=((tmp_tec-15)*691+180)/2000+(tmp_tec-15)*118+90;
1359   3      
1360   3                    }
1361   2                    else if(inbuf[10]==0x0d)
1362   2                    {
1363   3                       tmp_tec=(inbuf[6]-48)*10+(inbuf[7]-48);
1364   3      
1365   3                       kt=((tmp_tec-15)*691+(inbuf[9]-48)*69+180)/2000+(tmp_tec-15)*118+(inbuf[9]-48)*59/5+90;
1366   3      
1367   3                    }
1368   2      
1369   2                    else
1370   2                    {
1371   3                       setfault();
1372   3                       goto settf;
1373   3                    }
1374   2      
1375   2                     if(inbuf[5]=='S')
1376   2                    {
1377   3                      DA_Convert(2,kt);                         //种子源SEED
1378   3                      _Nop();
1379   3                      DA_Convert(2,kt);
1380   3                      setsucced();
1381   3                    }
1382   2                    else if(inbuf[5]=='A')
1383   2                    {
1384   3                      DA_Convert(1,kt);                         //放大级AMP
1385   3                      _Nop();
1386   3                      DA_Convert(1,kt);
1387   3                      setsucced();
1388   3                    }
1389   2                    else setfault();
1390   2      
1391   2      settf:       _Nop();
1392   2      
1393   2      
1394   2                 }
1395   1      
1396   1       ////////////////////////////////////////////////////////////////////////////////////////
1397   1       //////////////////////////////设定PWM频率//////////////////////////////////////////////////
1398   1              else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='R')&&(inbuf[3]=='A')&&(inbuf[4]=='='))
1399   1               {
1400   2                     uint pwm_pulserate;
1401   2                   
1402   2                     if(inbuf[6]==0x0d)                                        //格式为PURA=N
1403   2                    {
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 24  

1404   3                       pwm_pulserate=inbuf[5]-48;
1405   3      
1406   3      
1407   3                    }
1408   2                     else if(inbuf[7]==0x0d)                                   //格式为PURA=NN
1409   2                    {
1410   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
1411   3      
1412   3                    }
1413   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
1414   2                    {
1415   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
1416   3      
1417   3                    }
1418   2                    else if(inbuf[8]==0x0d)                                    //格式为PURA=NNN
1419   2                    {
1420   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
1421   3      
1422   3                    }
1423   2                    else                                                    //格式为PURA=NNNN
1424   2                    {
1425   3                        setfault();
1426   3                        goto setprf;
1427   3                    }
1428   2                      Pwm_Set(1,1,1);
1429   2                      setsucced();
1430   2                  
1431   2                    else setfault();
1432   2      
1433   2      setprf:       _Nop();
1434   2      
1435   2                 }
1436   1                ////////////////////////////////////////////////////////////////////////////////////////
1437   1       //////////////////////////////设定PWM脉宽//////////////////////////////////////////////////
1438   1                     else if((inbuf[0]=='P')&&(inbuf[1]=='U')&&(inbuf[2]=='W')&&(inbuf[3]=='I')&&(inbuf[4]=='=')
             -)
1439   1               {
1440   2                     uint pwm_pulserate;
1441   2                   
1442   2                     if(inbuf[6]==0x0d)                                        //格式为PUWI=N
1443   2                    {
1444   3                       pwm_pulserate=inbuf[5]-48;
1445   3      
1446   3      
1447   3                    }
1448   2                     else if(inbuf[7]==0x0d)                                   //格式为PUWI=NN
1449   2                    {
1450   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
1451   3      
1452   3                    }
1453   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
1454   2                    {
1455   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
1456   3      
1457   3                    }
1458   2                    else if(inbuf[8]==0x0d)                                    //格式为PUWI=NNN
1459   2                    {
1460   3                       pwm_pulserate=(uint)((inbuf[5]-48)*100+(inbuf[6]-48)*10+(inbuf[7]-48));
1461   3      
1462   3                    }
1463   2                    else                                                    //格式为PUWI=NNNN
1464   2                    {
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 25  

1465   3                        setfault();
1466   3                        goto setpwf;
1467   3                    }
1468   2                        Pwm_Set(1,1,1);
1469   2                      setsucced();
1470   2                   
1471   2                    else setfault();
1472   2      
1473   2      setpwf:       _Nop();
1474   2      
1475   2                 }
1476   1      
1477   1                 ////////////////////////////////////////////////////////////////////////////////////////
1478   1       //////////////////////////////设定PWM延迟时间//////////////////////////////////////////////////
1479   1                     else if((inbuf[0]=='D')&&(inbuf[1]=='E')&&(inbuf[2]=='L')&&(inbuf[3]=='Y')&&(inbuf[4]=='=')
             -)
1480   1               {
1481   2                     uint pwm_pulserate;
1482   2                   
1483   2                     if(inbuf[6]==0x0d)                                        //格式为DELY=N
1484   2                    {
1485   3                       pwm_pulserate=inbuf[5]-48;
1486   3      
1487   3      
1488   3                    }
1489   2                     else if(inbuf[7]==0x0d)                                   //格式为DELY=NN
1490   2                    {
1491   3                       pwm_pulserate=(uint)((inbuf[6]-48)*10+(inbuf[5]-48));
1492   3      
1493   3                    }
1494   2                    else                                                    //格式为DELY=NNNN
1495   2                    {
1496   3                        setfault();
1497   3                        goto setpdf;
1498   3                    }
1499   2                      Pwm_Set(1,1,1);
1500   2                      setsucced();
1501   2      
1502   2                    else setfault();
1503   2      
1504   2      setpdf:       _Nop();
1505   2      
1506   2                 }
1507   1      
1508   1      /////////////////////////////////关闭或开启TEC控制器////////////////////////////////
1509   1             else if((inbuf[0]=='S')&&(inbuf[1]=='H')&&(inbuf[2]=='D')&&(inbuf[3]=='N')&&(inbuf[4]=='='))
1510   1      
1511   1                 {
1512   2                    if((inbuf[5]=='S')&&(inbuf[7]==0x0d))             //种子源TEC
1513   2                    {
1514   3                       SHDN1=(bit)((inbuf[6]-48)&0x01);
1515   3                       setsucced();
1516   3                    }
1517   2                    else if((inbuf[5]=='A')&&(inbuf[7]==0x0d))        //放大级TEC
1518   2                    {
1519   3                       SHDN2=(bit)((inbuf[6]-48)&0x01);
1520   3                       setsucced();
1521   3                    }
1522   2                    setfault();
1523   2      
1524   2                 }
1525   1      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 26  

1526   1       //////////////////////////////////强制关电流///////////////////////////////////////
1527   1      
1528   1            else if((inbuf[0]=='D')&&(inbuf[1]=='L')&&(inbuf[2]=='I')&&(inbuf[3]=='M')&&(inbuf[4]=='='))
1529   1      
1530   1                 {
1531   2                    if(inbuf[7]==0x0d)
1532   2                    {
1533   3                       if(inbuf[5]=='S')
1534   3                         LIM1=(bit)((inbuf[6]-48)&0x01);
1535   3                       else  if(inbuf[5]=='A')
1536   3                         LIM2=(bit)((inbuf[6]-48)&0x01);
1537   3                       else
1538   3                        {
1539   4                         setfault();
1540   4                         goto setdf;
1541   4                        }
1542   3                       if (!LIM1)
1543   3                       {
1544   4                         Set_laser_current(3,50);
1545   4                         setsucced();
1546   4                        }
1547   3                       else if(!LIM2)
1548   3                       {
1549   4                         Set_laser_current(0,50);
1550   4                         setsucced();
1551   4                        }
1552   3                       else
1553   3                        {
1554   4                         setfault();
1555   4                         goto setdf;
1556   4                        }
1557   3                    }
1558   2                    else
1559   2                       setfault();
1560   2      setdf:       _Nop();
1561   2                 }
1562   1       //////////////////////////////////查询当前实际电流/////////////////////////////////
1563   1            else if((inbuf[0]=='D')&&(inbuf[1]=='I')&&(inbuf[2]=='O')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1564   1      
1565   1                 {
1566   2      
1567   2                    if(Laser_Fed_curent1<10)
1568   2                    {
1569   3                      inbuf[4]='S';
1570   3                      inbuf[5]='=';
1571   3                      inbuf[6]=(uchar)(Laser_Fed_curent1)+48;
1572   3                      inbuf[7]=0x0d;
1573   3                      inbuf[8]=0x0a;
1574   3                      send_string_com(inbuf,9);
1575   3                    }else if (Laser_Fed_curent1<100)
1576   2                    {
1577   3                      inbuf[4]='S';
1578   3                      inbuf[5]='=';
1579   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 /10)+48;
1580   3                      inbuf[7]=(uchar)(Laser_Fed_curent1 %10)+48;
1581   3                      inbuf[8]=0x0d;
1582   3                      inbuf[9]=0x0a;
1583   3                      send_string_com(inbuf,10);
1584   3                    }else if (Laser_Fed_curent1<1000)
1585   2                    {
1586   3                      inbuf[4]='S';
1587   3                      inbuf[5]='=';
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 27  

1588   3                      inbuf[6]=(uchar)(Laser_Fed_curent1 /100)+48;
1589   3                      inbuf[7]=(uchar)((Laser_Fed_curent1 /10)%10)+48;
1590   3                      inbuf[8]=(uchar)(Laser_Fed_curent1 %10)+48;
1591   3                      inbuf[9]=0x0d;
1592   3                      inbuf[10]=0x0a;
1593   3                      send_string_com(inbuf,11);
1594   3                    }
1595   2                    else
1596   2                      setfault();
1597   2       //////////////////////////////////////////////////////////
1598   2                     if(Laser_Fed_curent2<10)
1599   2                    {
1600   3                      inbuf[4]='A';
1601   3                      inbuf[5]='=';
1602   3                      inbuf[6]=(uchar)(Laser_Fed_curent2)+48;
1603   3                      inbuf[7]=0x0d;
1604   3                      inbuf[8]=0x0a;
1605   3                      send_string_com(inbuf,9);
1606   3                    }else if (Laser_Fed_curent2<100)
1607   2                    {
1608   3                      inbuf[4]='A';
1609   3                      inbuf[5]='=';
1610   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 /10)+48;
1611   3                      inbuf[7]=(uchar)(Laser_Fed_curent2 %10)+48;
1612   3                      inbuf[8]=0x0d;
1613   3                      inbuf[9]=0x0a;
1614   3                      send_string_com(inbuf,10);
1615   3                    }else if (Laser_Fed_curent2<1000)
1616   2                    {
1617   3                      inbuf[4]='A';
1618   3                      inbuf[5]='=';
1619   3                      inbuf[6]=(uchar)(Laser_Fed_curent2 /100)+48;
1620   3                      inbuf[7]=(uchar)((Laser_Fed_curent2 /10)%10)+48;
1621   3                      inbuf[8]=(uchar)(Laser_Fed_curent2 %10)+48;
1622   3                      inbuf[9]=0x0d;
1623   3                      inbuf[10]=0x0a;
1624   3                      send_string_com(inbuf,11);
1625   3                    }
1626   2                    else
1627   2                      setfault();
1628   2      
1629   2                 }
1630   1      
1631   1      
1632   1       //////////////////////////////////查询当前实际功率/////////////////////////////////
1633   1            else if((inbuf[0]=='L')&&(inbuf[1]=='A')&&(inbuf[2]=='P')&&(inbuf[3]=='O')&&(inbuf[4]=='?'))
1634   1      
1635   1                 {
1636   2      
1637   2                    if(Laser_Fed_power1<10)
1638   2                    {
1639   3                      inbuf[4]='S';
1640   3                      inbuf[5]='=';
1641   3                      inbuf[6]=(uchar)(Laser_Fed_power1)+48;
1642   3                      inbuf[7]=0x0d;
1643   3                      inbuf[8]=0x0a;
1644   3                      send_string_com(inbuf,9);
1645   3                    }else if (Laser_Fed_power1<100)
1646   2                    {
1647   3                      inbuf[4]='S';
1648   3                      inbuf[5]='=';
1649   3                      inbuf[6]=(uchar)(Laser_Fed_power1 /10)+48;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 28  

1650   3                      inbuf[7]=(uchar)(Laser_Fed_power1 %10)+48;
1651   3                      inbuf[8]=0x0d;
1652   3                      inbuf[9]=0x0a;
1653   3                      send_string_com(inbuf,10);
1654   3                    }else if (Laser_Fed_power1<1000)
1655   2                    {
1656   3                      inbuf[4]='S';
1657   3                      inbuf[5]='=';
1658   3                      inbuf[6]=(uchar)(Laser_Fed_power1 /100)+48;
1659   3                      inbuf[7]=(uchar)((Laser_Fed_power1 /10)%10)+48;
1660   3                      inbuf[8]=(uchar)(Laser_Fed_power1 %10)+48;
1661   3                      inbuf[9]=0x0d;
1662   3                      inbuf[10]=0x0a;
1663   3                      send_string_com(inbuf,11);
1664   3                    }
1665   2                    else
1666   2                      setfault();
1667   2      
1668   2                     if(Laser_Fed_power2<10)
1669   2                    {
1670   3                      inbuf[4]='A';
1671   3                      inbuf[5]='=';
1672   3                      inbuf[6]=(uchar)(Laser_Fed_power2)+48;
1673   3                      inbuf[7]=0x0d;
1674   3                      inbuf[8]=0x0a;
1675   3                      send_string_com(inbuf,9);
1676   3                    }else if (Laser_Fed_power2<100)
1677   2                    {
1678   3                      inbuf[4]='A';
1679   3                      inbuf[5]='=';
1680   3                      inbuf[6]=(uchar)(Laser_Fed_power2 /10)+48;
1681   3                      inbuf[7]=(uchar)(Laser_Fed_power2 %10)+48;
1682   3                      inbuf[8]=0x0d;
1683   3                      inbuf[9]=0x0a;
1684   3                      send_string_com(inbuf,10);
1685   3                    }else if (Laser_Fed_power2<1000)
1686   2                    {
1687   3                      inbuf[4]='A';
1688   3                      inbuf[5]='=';
1689   3                      inbuf[6]=(uchar)(Laser_Fed_power2 /100)+48;
1690   3                      inbuf[7]=(uchar)((Laser_Fed_power2 /10)%10)+48;
1691   3                      inbuf[8]=(uchar)(Laser_Fed_power2 %10)+48;
1692   3                      inbuf[9]=0x0d;
1693   3                      inbuf[10]=0x0a;
1694   3                      send_string_com(inbuf,11);
1695   3                    }
1696   2                    else
1697   2                      setfault();
1698   2      
1699   2                 }
1700   1      
1701   1      ///////////////////////////////////查询当前冷却温度////////////////////////////////
1702   1            else if((inbuf[0]=='T')&&(inbuf[1]=='E')&&(inbuf[2]=='C')&&(inbuf[3]=='P')&&(inbuf[4]=='?'))
1703   1      
1704   1                 {
1705   2      
1706   2                    uint ky;
1707   2      //              TEC_Temp();
1708   2      
1709   2                    ky=(uint)(TEC_Fed_Tempture1);
1710   2      
1711   2                    if (ky<1000)
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 29  

1712   2                    {
1713   3                      inbuf[4]='S';
1714   3                      inbuf[5]='=';
1715   3                      inbuf[6]=ky/100+48;
1716   3                      inbuf[7]=(ky/10)%10+48;
1717   3                      inbuf[8]='.';
1718   3                      inbuf[9]=ky%10+48;
1719   3                      inbuf[10]=0x0d;
1720   3                      inbuf[11]=0x0a;
1721   3                      send_string_com(inbuf,12);
1722   3                    }
1723   2                    else
1724   2                     alarm();
1725   2      
1726   2                   ky=(uint)(TEC_Fed_Tempture2);
1727   2      
1728   2                    if (ky<1000)
1729   2                    {
1730   3                      inbuf[4]='A';
1731   3                      inbuf[5]='=';
1732   3                      inbuf[6]=ky/100+48;
1733   3                      inbuf[7]=(ky/10)%10+48;
1734   3                      inbuf[8]='.';
1735   3                      inbuf[9]=ky%10+48;
1736   3                      inbuf[10]=0x0d;
1737   3                      inbuf[11]=0x0a;
1738   3                      send_string_com(inbuf,12);
1739   3                    }
1740   2                    else
1741   2                     alarm();
1742   2      
1743   2                 }
1744   1      ///////////////////////////////////查询当前监测二极管反馈电压/////////////////////
1745   1            else if((inbuf[0]=='P')&&(inbuf[1]=='D')&&(inbuf[2]=='I')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1746   1      
1747   1                 {
1748   2                    inbuf[6]=(uchar)(PDiode_V1/4095);
1749   2                    inbuf[8]=(uchar)((PDiode_V1 %4095)*10/4095);
1750   2                    inbuf[9]=(uchar)((((PDiode_V1 % 4095)*10)%4095)*10/4095);
1751   2      
1752   2                    inbuf[4]='S';
1753   2                    inbuf[5]='=';
1754   2                    inbuf[6]=inbuf[6]+48;
1755   2                    inbuf[7]='.';
1756   2                    inbuf[8]=inbuf[8]+48;
1757   2                    inbuf[9]=inbuf[9]+48;
1758   2                    inbuf[10]=0x0d;
1759   2                    inbuf[11]=0x0a;
1760   2      
1761   2                    send_string_com(inbuf,12);
1762   2      
1763   2                    inbuf[6]=(uchar)(PDiode_V2/4095);
1764   2                    inbuf[8]=(uchar)((PDiode_V2 %4095)*10/4095);
1765   2                    inbuf[9]=(uchar)((((PDiode_V2 % 4095)*10)%4095)*10/4095);
1766   2      
1767   2                    inbuf[4]='A';
1768   2                    inbuf[5]='=';
1769   2                    inbuf[6]=inbuf[6]+48;
1770   2                    inbuf[7]='.';
1771   2                    inbuf[8]=inbuf[8]+48;
1772   2                    inbuf[9]=inbuf[9]+48;
1773   2                    inbuf[10]=0x0d;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 30  

1774   2                    inbuf[11]=0x0a;
1775   2      
1776   2                    send_string_com(inbuf,12);
1777   2      
1778   2      
1779   2                 }
1780   1      
1781   1      ///////////////////////////////////查询当前TEC两端的电压//////////////////////////
1782   1            else if((inbuf[0]=='V')&&(inbuf[1]=='O')&&(inbuf[2]=='T')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1783   1      
1784   1                 {
1785   2      
1786   2      
1787   2      
1788   2                    inbuf[6]=(uchar)(TEC_VO1 /1024);
1789   2                    inbuf[8]=(uchar)((TEC_VO1 %1024)*10/1024);
1790   2                    inbuf[9]=(uchar)((((TEC_VO1 %1024)*10)%1024)*10/1024);
1791   2      
1792   2                    inbuf[4]='S';
1793   2                    inbuf[5]='=';
1794   2                    inbuf[6]=inbuf[6]+48;
1795   2                    inbuf[7]='.';
1796   2                    inbuf[8]=inbuf[8]+48;
1797   2                    inbuf[9]=inbuf[9]+48;
1798   2                    inbuf[10]=0x0d;
1799   2                    inbuf[11]=0x0a;
1800   2      
1801   2                    send_string_com(inbuf,12);
1802   2      
1803   2                    inbuf[6]=(uchar)(TEC_VO2 /1024);
1804   2                    inbuf[8]=(uchar)((TEC_VO2 %1024)*10/1024);
1805   2                    inbuf[9]=(uchar)((((TEC_VO2 %1024)*10)%1024)*10/1024);
1806   2      
1807   2                    inbuf[4]='A';
1808   2                    inbuf[5]='=';
1809   2                    inbuf[6]=inbuf[6]+48;
1810   2                    inbuf[7]='.';
1811   2                    inbuf[8]=inbuf[8]+48;
1812   2                    inbuf[9]=inbuf[9]+48;
1813   2                    inbuf[10]=0x0d;
1814   2                    inbuf[11]=0x0a;
1815   2      
1816   2                    send_string_com(inbuf,12);
1817   2      
1818   2                 }
1819   1      //////////////////////////////////查询当前TEC温度是否OK//////////////////////////
1820   1            else if((inbuf[0]=='T')&&(inbuf[1]=='P')&&(inbuf[2]=='G')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1821   1      
1822   1                 {
1823   2                    if (TMPGD1)
1824   2                    {
1825   3                      inbuf[4]='S';
1826   3                      inbuf[5]=' ';
1827   3                      inbuf[6]='O';
1828   3                      inbuf[7]='K';
1829   3                      inbuf[8]=0x0d;
1830   3                      inbuf[9]=0x0a;
1831   3                      send_string_com(inbuf,10);
1832   3                    }
1833   2      
1834   2                    else
1835   2                    {
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 31  

1836   3                      inbuf[4]='S';
1837   3                      inbuf[5]=' ';
1838   3                      inbuf[6]='N';
1839   3                      inbuf[7]='O';
1840   3                      inbuf[8]=0x0d;
1841   3                      inbuf[9]=0x0a;
1842   3                      send_string_com(inbuf,10);
1843   3                    }
1844   2      
1845   2                    if (TMPGD2)
1846   2                    {
1847   3                      inbuf[4]='A';
1848   3                      inbuf[5]=' ';
1849   3                      inbuf[6]='O';
1850   3                      inbuf[7]='K';
1851   3                      inbuf[8]=0x0d;
1852   3                      inbuf[9]=0x0a;
1853   3                      send_string_com(inbuf,10);
1854   3                    }
1855   2      
1856   2                    else
1857   2                    {
1858   3                      inbuf[4]='A';
1859   3                      inbuf[5]=' ';
1860   3                      inbuf[6]='N';
1861   3                      inbuf[7]='O';
1862   3                      inbuf[8]=0x0d;
1863   3                      inbuf[9]=0x0a;
1864   3                      send_string_com(inbuf,10);
1865   3                    }
1866   2      
1867   2                 }
1868   1      
1869   1      ///////////////////////////////////查询TEC控制器是否关闭//////////////////////////
1870   1            else if((inbuf[0]=='U')&&(inbuf[1]=='T')&&(inbuf[2]=='E')&&(inbuf[3]=='C')&&(inbuf[4]=='?'))
1871   1      
1872   1                 {
1873   2                    if (SHDN1)
1874   2                    {
1875   3                      inbuf[0]='T';
1876   3                      inbuf[1]='E';
1877   3                      inbuf[2]='C';
1878   3                      inbuf[3]='1';
1879   3                      inbuf[4]=' ';
1880   3                      inbuf[5]='O';
1881   3                      inbuf[6]='N';
1882   3                      inbuf[7]=0x0d;
1883   3                      inbuf[8]=0x0a;
1884   3                      send_string_com(inbuf,9);
1885   3                    }
1886   2      
1887   2                    else
1888   2                    {
1889   3                      inbuf[0]='T';
1890   3                      inbuf[1]='E';
1891   3                      inbuf[2]='C';
1892   3                      inbuf[3]='1';
1893   3                      inbuf[4]=' ';
1894   3                      inbuf[5]='O';
1895   3                      inbuf[6]='F';
1896   3                      inbuf[7]='F';
1897   3                      inbuf[8]=0x0d;
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 32  

1898   3                      inbuf[9]=0x0a;
1899   3                      send_string_com(inbuf,10);
1900   3                    }
1901   2      
1902   2                    if (SHDN2)
1903   2                    {
1904   3                      inbuf[0]='T';
1905   3                      inbuf[1]='E';
1906   3                      inbuf[2]='C';
1907   3                      inbuf[3]='2';
1908   3                      inbuf[4]=' ';
1909   3                      inbuf[5]='O';
1910   3                      inbuf[6]='N';
1911   3                      inbuf[7]=0x0d;
1912   3                      inbuf[8]=0x0a;
1913   3                      send_string_com(inbuf,9);
1914   3                    }
1915   2      
1916   2                    else
1917   2                    {
1918   3                      inbuf[0]='T';
1919   3                      inbuf[1]='E';
1920   3                      inbuf[2]='C';
1921   3                      inbuf[3]='2';
1922   3                      inbuf[4]=' ';
1923   3                      inbuf[5]='O';
1924   3                      inbuf[6]='F';
1925   3                      inbuf[7]='F';
1926   3                      inbuf[8]=0x0d;
1927   3                      inbuf[9]=0x0a;
1928   3                      send_string_com(inbuf,10);
1929   3                    }
1930   2                 }
1931   1      
1932   1      ///////////////////////////////////////////////////////////////////////////////////
1933   1      
1934   1      ///////////////////////////////////控制模式查询////////////////////////////////////
1935   1             else if((inbuf[0]=='C')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='?'))
1936   1      
1937   1                 {
1938   2                    if (CONT_MOD)
1939   2                    {
1940   3                      inbuf[0]='M';
1941   3                      inbuf[1]='O';
1942   3                      inbuf[2]='D';
1943   3                      inbuf[3]='=';
1944   3                      inbuf[4]='A';
1945   3                      inbuf[5]='P';
1946   3                      inbuf[6]='C';
1947   3                      inbuf[7]=0x0d;
1948   3                      inbuf[8]=0x0a;
1949   3                      send_string_com(inbuf,9);
1950   3                    }
1951   2      
1952   2                    else
1953   2                    {
1954   3                      inbuf[0]='M';
1955   3                      inbuf[1]='O';
1956   3                      inbuf[2]='D';
1957   3                      inbuf[3]='=';
1958   3                      inbuf[4]='A';
1959   3                      inbuf[5]='C';
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 33  

1960   3                      inbuf[6]='C';
1961   3                      inbuf[7]=0x0d;
1962   3                      inbuf[8]=0x0a;
1963   3                      send_string_com(inbuf,9);
1964   3                    }
1965   2                 }
1966   1      
1967   1      
1968   1      /////////////////////////////////////系统工作模式切换////////////////////////////////////////////
1969   1            else if((inbuf[0]=='S')&&(inbuf[1]=='M')&&(inbuf[2]=='O')&&(inbuf[3]=='D')&&(inbuf[4]=='='))
1970   1            {
1971   2                 if(inbuf[6]==0x0d)
1972   2                    {
1973   3                       Sys_mod=(bit)((inbuf[5]-48)&0x01);        //1:主动模式，0：系统采集模式
1974   3                       setsucced();
1975   3                    }
1976   2                 else
1977   2                    setfault();
1978   2            }
1979   1      ////////////////////////////////////////////////////////////////////////////////////////////////
1980   1      
1981   1            else
1982   1             setfault();                              //设置错误
1983   1      
1984   1      
1985   1      
1986   1           return;
1987   1      
1988   1      }
1989          /*******************************************************************************/
1990          
1991          /************************主程序*******************************/
1992          void main()
1993          {
1994   1         uchar  i=10;
1995   1         uchar  tmp0=0;
1996   1      
1997   1         stat_initial();                               //状态初始划
1998   1         serial_initial();                             //串口初始化
1999   1      
2000   1      /*   if(CONT_MOD)                                  //CONT_MOD: 1 APC, 0 ACC
2001   1      
2002   1      ///////////////////////////////////APC模式设定初始功率//////////////////////////////////////////
2003   1       {
2004   1        Laser_Set_power1=3;                        //记录种子源当前设定功率值
2005   1        Laser_Set_power2=3;                        //记录放大级当前设定功率值
2006   1      
2007   1        DA_Convert(3,25);                          // 种子源
2008   1         _Nop();
2009   1        DA_Convert(3,25);
2010   1      
2011   1        DA_Convert(0,25);                          // 放大级
2012   1         _Nop();
2013   1        DA_Convert(0,25);
2014   1       }
2015   1      //////////////////////////////////////////////////////////////////////////////////////////////
2016   1      
2017   1        else
2018   1      //////////////////////////////////ACC模式设定初始电流//////////////////////////////////////////
2019   1       {
2020   1        Laser_Set_curent1=30;                          //记录种子源当前设定电流值
2021   1        Laser_Set_curent2=30;                          //记录放大级当前设定电流值
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 34  

2022   1      
2023   1        DA_Convert(3,88);                            // 种子源
2024   1         _Nop();
2025   1        DA_Convert(3,88);
2026   1      
2027   1        DA_Convert(0,88);                            // 放大级
2028   1        _Nop();
2029   1        DA_Convert(0,88);
2030   1       }
2031   1      //////////////////////////////////////////////////////////////////////////////////////////////*/
2032   1      ///////////////////////////////////上电开始显示///////////////////////////////////////////////
2033   1         init_lcd ();
2034   1         delay(5);
2035   1         wr_lcd (comm,0x30);
2036   1         delay(30);                                    //需要足够的等待延时
2037   1         chn_disp (tab1,14,0x80);
2038   1         delay(5);
2039   1         chn_disp (tab2,20,0x90);
2040   1         delay(5);
2041   1         clrram();
2042   1         delay(5);
2043   1         chn_disp (tab3,10,0x80);
2044   1         chn_disp (tab4,12,0x90);
2045   1      
2046   1         clrram();
2047   1         delay(10);
2048   1         chn_disp (tab5,10,0x80);
2049   1         delay(5);
2050   1      /////////////////////////////////////////////////////////////////////////////////////////////
2051   1      
2052   1      
2053   1      
2054   1        do
2055   1         {
2056   2      
2057   2           delay(1);
2058   2      
2059   2           if(read_flag)
2060   2            {
2061   3              command();                        //指令识别
2062   3              read_flag=0;                      //取数标志清0
2063   3              t=0;
2064   3            }
2065   2      
2066   2           _Nop();
2067   2      
2068   2      
2069   2          if(Sys_mod)
2070   2       {
2071   3      
2072   3      
2073   3      /***************************检查按键**************************************/
2074   3      
2075   3       // Key_Button();  tang
2076   3      
2077   3      
2078   3      ///////////////////////////////////////////////////////////////////////////
2079   3      
2080   3      /***************************检查当前实际功率值****************************/
2081   3       //Laser_power_Check(); tang
2082   3      
2083   3      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 35  

2084   3      /*************************************************************************/
2085   3      /***************************检测当前实际电流值****************************/
2086   3      
2087   3       Diode_curent_Check();
2088   3      
2089   3      
2090   3      
2091   3      
2092   3      ///////////////////////////////////////////////////////////////////////////
2093   3      
2094   3      
2095   3      /***************************检测当前冷却温度******************************/
2096   3         TEC_Temp();
2097   3      
2098   3      
2099   3      
2100   3         if(TEC_meds_tempture1>280)
2101   3      
2102   3         {
2103   4      
2104   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2105   4           if(CONT_MOD)
2106   4           {
2107   5           Set_laser_power(0,3);       //tang
2108   5           Set_laser_power(3,3);
2109   5           }
2110   4           else
2111   4           {
2112   5           Set_laser_current(0,30);
2113   5           Set_laser_current(3,30);
2114   5           }
2115   4           SHDN1=0;
2116   4           SHDN2=0;
2117   4           send_string_com(inbuf1,9);
2118   4           t=0;
2119   4           chn_disp (inbuf1,7,0x86);
2120   4         }
2121   3      
2122   3         if(TEC_meds_tempture2>280)
2123   3      
2124   3         {
2125   4      
2126   4           uchar inbuf1[9]={'t','m','p','_','e','r','r',0x0d,0x0a};
2127   4           if(CONT_MOD)
2128   4           {
2129   5           Set_laser_power(0,3);       //tang
2130   5           Set_laser_power(3,3);
2131   5           }
2132   4           else
2133   4           {
2134   5           Set_laser_current(0,30);
2135   5           Set_laser_current(3,30);
2136   5           }
2137   4           SHDN1=0;
2138   4           
2139   4           SHDN2=0;
2140   4           send_string_com(inbuf1,9);
2141   4           t=0;
2142   4           chn_disp (inbuf1,7,0x96);
2143   4         }
2144   3      //////////////////////////////////////////////////////////////////////////
2145   3      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 36  

2146   3      
2147   3      /***************************检测监测二极管反馈电压************************/
2148   3      
2149   3       Pdiod_V_Check();
2150   3      
2151   3      
2152   3      
2153   3      //////////////////////////////////////////////////////////////////////////
2154   3      
2155   3      
2156   3      /***************************检测TEC温控是否完成**************************/
2157   3      
2158   3      
2159   3      
2160   3      
2161   3      
2162   3      /////////////////////////////////////////////////////////////////////////
2163   3      
2164   3      
2165   3      /***************************检测TEC两端电压是否正常*********************/
2166   3      
2167   3        TEC_V_Check();
2168   3      
2169   3        if( TEC_VO1>3.1) Error_Process();
2170   3        if( TEC_VO2>3.1) Error_Process();
2171   3      
2172   3      ////////////////////////////////////////////////////////////////////////
2173   3      
2174   3      
2175   3      /****************************LCD显示***********************************/
2176   3      
2177   3      
2178   3           chn_disp (tab6,4,0x80);
2179   3           delayR(50);
2180   3           chn_disp (Diode_parameter1,6,0x82);      //显示种子源电流
2181   3           delayR(50);
2182   3           chn_disp (TEC_parameter1,4,0x85);        //显示种子源TEC温度
2183   3      
2184   3      
2185   3           chn_disp (tab7,4,0x90);
2186   3           delayR(50);
2187   3           chn_disp (Diode_parameter2,6,0x92);      //显示放大级电流
2188   3           delayR(50);
2189   3           chn_disp (TEC_parameter2,4,0x95);        //显示放大级TEC温度
2190   3      
2191   3      
2192   3      
2193   3      
2194   3      
2195   3           if(CONT_MOD)
2196   3           {
2197   4              chn_disp (tab14,6,0x87);
2198   4              delayR(50);
2199   4              chn_disp (tab14,6,0x97);
2200   4            }
2201   3           else
2202   3           {
2203   4              chn_disp (tab15,6,0x87);
2204   4              delayR(50);
2205   4              chn_disp (tab15,6,0x97);
2206   4           }
2207   3      
C51 COMPILER V7.02b   DUALDRIVER                                                           12/02/2013 13:51:42 PAGE 37  

2208   3      ///////////////////////////////////////////////////////////////////////
2209   3      }
2210   2      
2211   2      else
2212   2      {
2213   3           chn_disp (tab16,20,0x80);
2214   3           delayR(10000);
2215   3           chn_disp (tab17,20,0x90);
2216   3      } 
2217   2      
2218   2          }while(1);
2219   1      
2220   1      
2221   1       }

C51 COMPILATION COMPLETE.  1 WARNING(S),  13 ERROR(S)
